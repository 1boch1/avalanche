:mod:`avalanche.logging`
========================

.. py:module:: avalanche.logging


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   dot_trace/index.rst
   strategy_logger/index.rst
   tensorboard_logger/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   avalanche.logging.StrategyLogger
   avalanche.logging.DotTrace



.. py:class:: StrategyLogger

   Bases: :class:`StrategyCallbacks[None]`, :class:`abc.ABC`

   The base class for the strategy loggers.

   Strategy loggers will receive events, under the form of callback calls,
   from the :class:`EvaluationPlugin` carrying a reference to the strategy
   as well as the values emitted by the metrics.

   Child classes can implement the desired callbacks. An alternative, simpler,
   mechanism exists: child classes may instead implement the `log_metric`
   method which will be invoked with each received metric value.

   Implementing `log_metric` is not mutually exclusive with the callback
   implementation. Make sure, when implementing the callbacks, to call
   the proper super method.

   Initialize self.  See help(type(self)) for accurate signature.

   .. method:: log_metric(self, metric_value: MetricValue, callback: str) -> None

      Helper method that will be invoked each time a metric value will become
      available. To know from which callback the value originated, the
      callback parameter can be used.

      Implementing this method is a practical, non-exclusive, alternative the
      implementation of the single callbacks. See the class description for
      details and hints.

      :param metric_value: The value to be logged.
      :param callback: The callback (event) from which the metric value was
          obtained.
      :return: None


   .. method:: before_training(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: before_training_step(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: adapt_train_dataset(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: before_training_epoch(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: before_training_iteration(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: before_forward(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: after_forward(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: before_backward(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: after_backward(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: after_training_iteration(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: before_update(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: after_update(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: after_training_epoch(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: after_training_step(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: after_training(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: before_test(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: adapt_test_dataset(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: before_test_step(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: after_test_step(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: after_test(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: before_test_iteration(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: before_test_forward(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: after_test_forward(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)


   .. method:: after_test_iteration(self, strategy: PluggableStrategy, metric_values: List['MetricValue'], **kwargs)



.. py:class:: DotTrace(stdout=True, stderr=False, trace_file: Union[str, Path] = None, *, iterations_per_line: int = 50, lines_between_summaries: int = 4)

   Bases: :class:`avalanche.logging.StrategyLogger`

   The base class for the strategy loggers.

   Strategy loggers will receive events, under the form of callback calls,
   from the :class:`EvaluationPlugin` carrying a reference to the strategy
   as well as the values emitted by the metrics.

   Child classes can implement the desired callbacks. An alternative, simpler,
   mechanism exists: child classes may instead implement the `log_metric`
   method which will be invoked with each received metric value.

   Implementing `log_metric` is not mutually exclusive with the callback
   implementation. Make sure, when implementing the callbacks, to call
   the proper super method.

   Initialize self.  See help(type(self)) for accurate signature.

   .. method:: _update_metrics(self, strategy: PluggableStrategy)


   .. method:: _new_line(self)


   .. method:: _message(self, msg: str)


   .. method:: _file_error(self, err, new_line=True)


   .. method:: after_training_iteration(self, strategy: PluggableStrategy, _metric_values, **kwargs)


   .. method:: after_test_iteration(self, strategy: PluggableStrategy, _metric_values, **kwargs)


   .. method:: before_training_step(self, strategy: PluggableStrategy, _metric_values, **kwargs)


   .. method:: before_test_step(self, strategy: PluggableStrategy, _metric_values, **kwargs)


   .. method:: before_training_epoch(self, strategy: PluggableStrategy, _metric_values, **kwargs)


   .. method:: after_training_epoch(self, strategy: PluggableStrategy, _metric_values, **kwargs)


   .. method:: after_test_step(self, strategy: PluggableStrategy, _metric_values, **kwargs)


   .. method:: before_training(self, strategy: PluggableStrategy, _metric_values, **kwargs)


   .. method:: before_test(self, strategy: PluggableStrategy, _metric_values, **kwargs)


   .. method:: after_training(self, strategy: PluggableStrategy, _metric_values, **kwargs)


   .. method:: after_test(self, strategy: PluggableStrategy, _metric_values, **kwargs)


   .. method:: _on_iteration(self, strategy: PluggableStrategy)


   .. method:: _on_step_start(self, strategy: PluggableStrategy)


   .. method:: _on_epoch_end(self, strategy: PluggableStrategy)


   .. method:: _on_phase_start(self, strategy: PluggableStrategy)


   .. method:: _on_phase_end(self, strategy: PluggableStrategy)



