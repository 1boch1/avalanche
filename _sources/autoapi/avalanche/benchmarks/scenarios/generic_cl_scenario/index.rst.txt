:mod:`avalanche.benchmarks.scenarios.generic_cl_scenario`
=========================================================

.. py:module:: avalanche.benchmarks.scenarios.generic_cl_scenario


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   avalanche.benchmarks.scenarios.generic_cl_scenario.GenericCLScenario
   avalanche.benchmarks.scenarios.generic_cl_scenario.AbstractStepInfo
   avalanche.benchmarks.scenarios.generic_cl_scenario.GenericStepInfo



.. data:: TBaseScenario
   

   

.. data:: TStepInfo
   

   

.. data:: TGenericCLScenario
   

   

.. py:class:: GenericCLScenario(: TGenericCLScenario, original_train_dataset: TrainSetWithTargets, original_test_dataset: TestSetWithTargets, train_dataset: TrainSetWithTargets, test_dataset: TestSetWithTargets, train_steps_patterns_assignment: Sequence[Sequence[int]], test_steps_patterns_assignment: Sequence[Sequence[int]], task_labels: Sequence[int], complete_test_set_only: bool = False, reproducibility_data: Optional[Dict[str, Any]] = None, step_factory: Callable[[TGenericCLScenario, int], TStepInfo] = None)

   Bases: :class:`Generic[TrainSetWithTargets, TestSetWithTargets, TStepInfo]`

   Base implementation of a Continual Learning scenario. A Continual Learning
   scenario is defined by a sequence of steps (batches or tasks depending on
   the terminology), with each step containing the training (and test) data
   that becomes available at a certain time instant.

   From a practical point of view, this means that we usually have to define
   two datasets (training and test), and some way to assign the patterns
   contained in these datasets to each step.

   This assignment is usually made in children classes, with this class serving
   as the more general implementation. This class handles the most simple type
   of assignment: each step is defined by a list of patterns (identified by
   their indexes) contained in that step.

   Creates an instance of a Continual Learning scenario.

   The scenario is defined by the train and test datasets plus the
   assignment of patterns to steps (batches/tasks).

   :param train_dataset: The training dataset.
   :param test_dataset:  The test dataset.
   :param train_steps_patterns_assignment: A list of steps. Each step is
       in turn defined by a list of integers describing the pattern index
       inside the training dataset.
   :param test_steps_patterns_assignment: A list of steps. Each step is
       in turn defined by a list of integers describing the pattern index
       inside the test dataset.
   :param task_labels: The mapping from step IDs to task labels, usually
       as a list of integers.
   :param complete_test_set_only: If True, only the complete test
       set will be returned from test set related methods of the linked
       :class:`GenericStepInfo` instances. This also means that the
       ``test_steps_patterns_assignment`` parameter can be a single element
       or even an empty list (in which case, the full set defined by
       the ``test_dataset`` parameter will be returned). The returned
       task label for the complete test set will be the first element
       of the ``task_labels`` parameter. Defaults to False, which means
       that ```train_steps_patterns_assignment`` and
       ``test_steps_patterns_assignment`` parameters must describe an equal
       amount of steps.
   :param reproducibility_data: If not None, overrides the
       ``train/test_steps_patterns_assignment`` and ``task_labels``
       parameters. This is usually a dictionary containing data used to
       reproduce a specific experiment. One can use the
       ``get_reproducibility_data`` method to get (and even distribute)
       the experiment setup so that it can be loaded by passing it as this
       parameter. In this way one can be sure that the same specific
       experimental setup is being used (for reproducibility purposes).
       Beware that, in order to reproduce an experiment, the same train and
       test datasets must be used. Defaults to None.
   :param step_factory: If not None, a callable that, given the scenario
       instance and the step ID, returns a step info instance. This
       parameter is usually used in subclasses (when invoking the super
       constructor) to specialize the step info class. Defaults to None,
       which means that the :class:`GenericStepInfo` constructor will be
       used.

   .. attribute:: original_train_dataset
      :annotation: :TrainSetWithTargets

      The original training set. 


   .. attribute:: original_test_dataset
      :annotation: :TestSetWithTargets

      The original test set. 


   .. attribute:: train_dataset
      :annotation: :TrainSetWithTargets

      The training set used to generate the incremental steps. 


   .. attribute:: test_dataset
      :annotation: :TestSetWithTargets

      The test set used to generate the incremental steps. 


   .. attribute:: train_steps_patterns_assignment
      :annotation: :Sequence[Sequence[int]]

      A list containing which training patterns are assigned to each step.
      Patterns are identified by their id w.r.t. the dataset found in the 
      train_dataset field. 


   .. attribute:: test_steps_patterns_assignment
      :annotation: :Sequence[Sequence[int]]

      A list containing which test patterns are assigned to each step.
      Patterns are identified by their id w.r.t. the dataset found in the 
      test_dataset field 


   .. attribute:: task_labels
      :annotation: :Sequence[int]

      The task label of each step. 


   .. attribute:: slice_ids
      :annotation: :Optional[List[int]]

      Describes which steps are contained in the current scenario slice. 
      Can be None, which means that this object is the original scenario. 


   .. attribute:: complete_test_set_only
      :annotation: :bool

      If True, only the complete test set will be returned from step info
      instances. 


   .. attribute:: n_steps
      :annotation: :int

      The number of incremental steps this scenario is made of. 


   .. method:: __len__(self) -> int

      Gets the number of steps this scenario it's made of.

      :return: The number of steps in this scenario.


   .. method:: __getitem__(self: TGenericCLScenario, step_idx: Union[int, slice, Iterable[int]]) -> Union[TGenericCLScenario, TStepInfo]

      Gets a step given its step index (or a scenario slice given the step
      order).

      :param step_idx: An int describing the step index or an iterable/slice
          object describing a slice of this scenario.

      :return: The step instance associated to the given step index or
          a sliced scenario instance (see parameter step_idx).


   .. method:: get_reproducibility_data(self) -> Dict[str, Any]

      Gets the data needed to reproduce this experiment.

      This data can be stored using the pickle module or some other mechanism.
      It can then be loaded by passing it as the ``reproducibility_data``
      parameter in the constructor.

      Child classes should get the reproducibility dictionary from super class
      and then merge their custom data before returning it.

      :return: A dictionary containing the data needed to reproduce the
          experiment.


   .. method:: get_classes_timeline(self, current_step: int)

      Returns the classes timeline for a this scenario.

      Given a step ID, this method returns the classes in this step,
      previously seen classes, the cumulative class list and a list
      of classes that will be encountered in next steps.

      :param current_step: The reference step ID.
      :return: A tuple composed of four lists: the first list contains the
          IDs of classes in this step, the second contains IDs of classes seen
          in previous steps, the third returns a cumulative list of classes
          (that is, the union of the first two list) while the last one
          returns a list of classes that will be encountered in next steps.


   .. method:: classes_in_step(self) -> Sequence[Set[int]]
      :property:

      A list that, for each step (identified by its index/ID),
      stores a set of the (optionally remapped) IDs of classes of patterns
      assigned to that step. 


   .. method:: _create_slice(self: TGenericCLScenario, steps_slice: Union[int, slice, Iterable[int]]) -> TGenericCLScenario

      Creates a sliced version of this scenario.

      In its base version, a shallow copy of this scenario is created and
      then its ``slice_ids`` field is adapted.

      :param steps_slice: The slice to use.
      :return: A sliced version of this scenario.



.. py:class:: AbstractStepInfo(scenario: TBaseScenario, current_step: int, n_steps: int, classes_in_this_step: Sequence[int], previous_classes: Sequence[int], classes_seen_so_far: Sequence[int], future_classes: Optional[Sequence[int]], train_transform: Optional[Callable] = None, train_target_transform: Optional[Callable] = None, test_transform: Optional[Callable] = None, test_target_transform: Optional[Callable] = None, force_train_transformations: bool = False, force_test_transformations: bool = False, are_transformations_disabled: bool = False)

   Bases: :class:`abc.ABC`, :class:`Generic[TBaseScenario]`

   Definition of a learning step. A learning step contains a set of patterns
   which has become available at a particular time instant. The content and
   size of a Step is defined by the specific benchmark that creates the
   step instance.

   For instance, a step of a New Classes scenario will contain all patterns
   belonging to a subset of classes of the original training set. A step of a
   New Instance scenario will contain patterns from previously seen classes.

   Steps of  Single Incremental Task (a.k.a. task-free) scenarios are usually
   called "batches" while in Multi Task scenarios a Step is usually associated
   to a "task". Finally, in a Multi Incremental Task scenario the Step may be
   composed by patterns from different tasks.

   Creates an instance of the abstract step info given the base scenario,
   the current step ID, the overall number of steps, transformations and
   transformations flags.

   :param scenario: The base scenario.
   :param current_step: The current step, as an integer.
   :param n_steps: The overall number of steps in the base scenario.
   :param train_transform: The train transformation. Can be None.
   :param train_target_transform: The train targets transformation.
       Can be None.
   :param test_transform: The test transformation. Can be None.
   :param test_target_transform: The test targets transformation.
       Can be None.
   :param force_train_transformations: If True, train transformations will
       be applied to the test set too. The ``force_test_transformations``
       parameter can't be True at the same time. Defaults to False.
   :param force_test_transformations: If True, test transformations will be
       applied to the training set too. The ``force_train_transformations``
       parameter can't be True at the same time. Defaults to False.
   :param are_transformations_disabled: If True, transformations are
       disabled. That is, patterns and targets will be returned as
       outputted by  the original training and test Datasets. Overrides
       ``force_train_transformations`` and ``force_test_transformations``.
       Defaults to False.

   .. attribute:: classes_in_this_step
      :annotation: :Sequence[int]

      The list of classes in this step 


   .. attribute:: previous_classes
      :annotation: :Sequence[int]

      The list of classes in previous steps 


   .. attribute:: classes_seen_so_far
      :annotation: :Sequence[int]

      List of classes of current and previous steps 


   .. attribute:: future_classes
      :annotation: :Optional[Sequence[int]]

      The list of classes of next steps 


   .. method:: _make_subset(self, is_train: bool, step: int, **kwargs) -> MTSingleSet
      :abstractmethod:

      Returns the train/test dataset given the step ID.

      :param is_train: If True, the training subset is returned. If False,
          the test subset will be returned instead.
      :param step: The step ID.
      :param kwargs: Other scenario-specific arguments. Subclasses may define
          some utility options.
      :return: The required train/test dataset.


   .. method:: disable_transformations(self) -> 'AbstractStepInfo[TBaseScenario]'
      :abstractmethod:

      Returns a new step info instance in which transformations are disabled.
      The current instance is not affected. This is useful when there is a
      need to access raw data. Can be used when picking and storing
      rehearsal/replay patterns.

      :returns: A new step info in which transformations are disabled.


   .. method:: enable_transformations(self) -> 'AbstractStepInfo[TBaseScenario]'
      :abstractmethod:

      Returns a new step info instance in which transformations are enabled.
      The current instance is not affected. When created, the step instance
      already has transformations enabled. This method can be used to
      re-enable transformations after a previous call to
      disable_transformations().

      :returns: A new step info in which transformations are enabled.


   .. method:: with_train_transformations(self) -> 'AbstractStepInfo[TBaseScenario]'
      :abstractmethod:

      Returns a new step info instance in which train transformations are
      applied to both training and test sets. The current instance is not
      affected.

      :returns: A new step info in which train transformations are applied to
          both training and test sets.


   .. method:: with_test_transformations(self) -> 'AbstractStepInfo[TBaseScenario]'
      :abstractmethod:

      Returns a new step info instance in which test transformations are
      applied to both training and test sets. The current instance is
      not affected. This is useful to get the accuracy on the training set
      without considering the usual training data augmentations.

      :returns: A new step info in which test transformations are applied to
          both training and test sets.


   .. method:: current_training_set(self, **kwargs) -> MTSingleSet

      Gets the training set for the current step.

      :returns: The current step training set, as a tuple containing the
          Dataset and the task label.


   .. method:: cumulative_training_sets(self, include_current_step: bool = True, **kwargs) -> MTMultipleSet

      Gets the list of cumulative training sets.

      :param include_current_step: If True, include the current step training
          set. Defaults to True.

      :returns: The cumulative training sets, as a list. Each element of the
          list is a tuple containing the Dataset and the task label.


   .. method:: complete_training_sets(self, **kwargs) -> MTMultipleSet

      Gets the complete list of training sets.

      :returns: All the training sets, as a list. Each element of
          the list is a tuple containing the Dataset and the task label.


   .. method:: future_training_sets(self, **kwargs) -> MTMultipleSet

      Gets the "future" training set. That is, a dataset made of training
      patterns belonging to not-already-encountered steps.

      :returns: The future training sets, as a list. Each element of the
          list is a tuple containing the Dataset and the task label.


   .. method:: step_specific_training_set(self, step_id: int, **kwargs) -> MTSingleSet

      Gets the training set of a specific step, given its ID.

      :param step_id: The ID of the step.

      :returns: The required training set, as a tuple containing the Dataset
          and the task label.


   .. method:: training_set_part(self, dataset_part: DatasetPart, **kwargs) -> MTMultipleSet

      Gets the training subset of a specific part of the scenario.

      :returns: The training sets of the desired part, as a list. Each element
          of the list is a tuple containing the Dataset and the task label.


   .. method:: current_test_set(self, **kwargs) -> MTSingleSet

      Gets the test set for the current step.

      :returns: The current test sets, as a tuple containing the Dataset and
          the task label.


   .. method:: cumulative_test_sets(self, include_current_step: bool = True, **kwargs) -> MTMultipleSet

      Gets the list of cumulative test sets.

      :param include_current_step: If True, include the current step training
          set. Defaults to True.

      :returns: The cumulative test sets, as a list. Each element of the
          list is a tuple containing the Dataset and the task label.


   .. method:: complete_test_sets(self, **kwargs) -> MTMultipleSet

      Gets the complete list of test sets.

      :returns: All the test sets, as a list. Each element of
          the list is a tuple containing the Dataset and the task label.


   .. method:: future_test_sets(self, **kwargs) -> MTMultipleSet

      Gets the "future" test set. That is, a dataset made of test patterns
      belonging to not-already-encountered steps.

      :returns: The future test sets, as a list. Each element of the
          list is a tuple containing the Dataset and the task label.


   .. method:: step_specific_test_set(self, step_id: int, **kwargs) -> MTSingleSet

      Gets the test set of a specific step, given its ID.

      :param step_id: The ID of the step.

      :returns: The required test set, as a tuple containing the Dataset
          and the task label.


   .. method:: test_set_part(self, dataset_part: DatasetPart, **kwargs) -> MTMultipleSet

      Gets the test subset of a specific part of the scenario.

      :param dataset_part: The part of the scenario.

      :returns: The test sets of the desired part, as a list. Each element
          of the list is a tuple containing the Dataset and the task label.


   .. method:: _make_train_subsets(self, steps: Union[int, Sequence[int]], **kwargs) -> Union[MTMultipleSet]

      Internal utility used to aggregate results from ``_make_subset``.

      :param steps: A list of step IDs whose training dataset must be fetched.
          Can also be a single step ID (as an integer).
      :param kwargs: Other ``_make_subset`` specific options.
      :return: A list of tuples. Each tuples contains the dataset and task
          label for that step (relative to the order defined in the steps
          parameter).


   .. method:: _make_test_subsets(self, steps: Union[int, Sequence[int]], **kwargs) -> Union[MTMultipleSet]

      Internal utility used to aggregate results from ``_make_subset``.

      :param steps: A list of step IDs whose test dataset must be fetched.
          Can also be a single step ID (as an integer).
      :param kwargs: Other ``_make_subset`` specific options.
      :return: A list of tuples. Each tuples contains the dataset and task
          label for that step (relative to the order defined in the steps
          parameter).



.. py:class:: GenericStepInfo(scenario: TGenericCLScenario, current_step: int, force_train_transformations: bool = False, force_test_transformations: bool = False, are_transformations_disabled: bool = False, transformation_step_factory: Optional[Callable] = None)

   Bases: :class:`AbstractStepInfo[TGenericCLScenario]`

   Definition of a learning step based on a :class:`GenericCLScenario`
   instance.

   This step implementation uses the generic step-patterns assignment defined
   in the :class:`GenericCLScenario` instance. Instances of this class are
   usually obtained as the output of the iteration of the base scenario
   instance.

   Creates an instance of a generic step info given the base generic
   scenario and the current step ID and transformations
   flags.

   :param scenario: The base generic scenario.
   :param current_step: The current step, as an integer.
   :param force_train_transformations: If True, train transformations will
       be applied to the test set too. The ``force_test_transformations``
       parameter can't be True at the same time. Defaults to False.
   :param force_test_transformations: If True, test transformations will be
       applied to the training set too. The ``force_train_transformations``
       parameter can't be True at the same time. Defaults to False.
   :param are_transformations_disabled: If True, transformations are
       disabled. That is, patterns and targets will be returned as
       outputted by  the original training and test Datasets. Overrides
       ``force_train_transformations`` and ``force_test_transformations``.
       Defaults to False.

   .. method:: _get_task_label(self, step: int)

      Returns the task label given the step ID.

      :param step: The step ID.

      :return: The task label of the step.


   .. method:: _make_subset(self, is_train: bool, step: int, bucket_classes=False, sort_classes=False, sort_indexes=False, **kwargs) -> MTSingleSet

      Returns the train/test dataset given the step ID.

      :param is_train: If True, the training subset is returned. If False,
          the test subset will be returned instead.
      :param step: The step ID.
      :param bucket_classes: If True, dataset patterns will be grouped by
          class. Defaults to False.
      :param sort_classes: If True (and ``bucket_classes`` is True), class
          groups will be sorted by class ID (ascending). Defaults to False.
      :param sort_indexes: If True patterns will be ordered by their ID
          (ascending). If ``sort_classes`` and ``bucket_classes`` are both
          True, patterns will be sorted inside their groups.
          Defaults to False.
      :param kwargs: Other scenario-specific arguments. Subclasses may define
          some utility options.
      :return: The required train/test dataset.


   .. method:: disable_transformations(self) -> 'GenericStepInfo[GenericCLScenario[TrainSetWithTargets, TestSetWithTargets]]'


   .. method:: enable_transformations(self) -> 'GenericStepInfo[GenericCLScenario[TrainSetWithTargets, TestSetWithTargets]]'


   .. method:: with_train_transformations(self) -> 'GenericStepInfo[GenericCLScenario[TrainSetWithTargets, TestSetWithTargets]]'


   .. method:: with_test_transformations(self) -> 'GenericStepInfo[GenericCLScenario[TrainSetWithTargets, TestSetWithTargets]]'


   .. method:: _make_test_subsets(self, steps: Union[int, Sequence[int]], **kwargs) -> Union[MTMultipleSet]



