:mod:`avalanche.benchmarks.scenarios.new_instances`
===================================================

.. py:module:: avalanche.benchmarks.scenarios.new_instances


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   ni_scenario/index.rst
   ni_utils/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   avalanche.benchmarks.scenarios.new_instances.NIScenario
   avalanche.benchmarks.scenarios.new_instances.NIStepInfo



Functions
~~~~~~~~~

.. autoapisummary::

   avalanche.benchmarks.scenarios.new_instances.make_ni_transformation_subset


.. py:class:: NIScenario(train_dataset: TrainSet, test_dataset: TestSet, n_steps: int, task_labels: bool = False, shuffle: bool = True, seed: Optional[int] = None, balance_steps: bool = False, min_class_patterns_in_step: int = 0, fixed_step_assignment: Optional[Sequence[Sequence[int]]] = None, reproducibility_data: Optional[Dict[str, Any]] = None)

   Bases: :class:`GenericCLScenario[TrainSet, TestSet, 'NIStepInfo']`, :class:`Generic[TrainSet, TestSet]`

   This class defines a "New Instance" scenario.
   Once created, an instance of this class can be iterated in order to obtain
   the step sequence under the form of instances of :class:`NIStepInfo`.

   Instances of this class can be created using the constructor directly.
   However, we recommend using facilities like
   :func:`avalanche.benchmarks.generators.ni_scenario`.

   Consider that every method from :class:`NIStepInfo` used to retrieve
   parts of the test set (past, current, future, cumulative) always return the
   complete test set. That is, they behave as the getter for the complete test
   set.

   Creates a NIScenario instance given the training and test Datasets and
   the number of steps.

   :param train_dataset: The training dataset. The dataset must be a
       subclass of :class:`TransformationDataset`. For instance, one can
       use the datasets from the torchvision package like that:
       ``train_dataset=TransformationDataset(torchvision_dataset)``.
   :param test_dataset: The test dataset. The dataset must be a
       subclass of :class:`TransformationDataset`. For instance, one can
       use the datasets from the torchvision package like that:
       ``test_dataset=TransformationDataset(torchvision_dataset)``.
   :param n_steps: The number of steps.
   :param task_labels: If True, each step will have an ascending task
       label. If False, the task label will be 0 for all the steps.
       Defaults to False.
   :param shuffle: If True, the patterns order will be shuffled. Defaults
       to True.
   :param seed: If shuffle is True and seed is not None, the class order
       will be shuffled according to the seed. When None, the current
       PyTorch random number generator state will be used.
       Defaults to None.
   :param balance_steps: If True, pattern of each class will be equally
       spread across all steps. If False, patterns will be assigned to
       steps in a complete random way. Defaults to False.
   :param min_class_patterns_in_step: The minimum amount of patterns of
       every class that must be assigned to every step. Compatible with
       the ``balance_steps`` parameter. An exception will be raised if
       this constraint can't be satisfied. Defaults to 0.
   :param fixed_step_assignment: If not None, the pattern assignment
       to use. It must be a list with an entry for each step. Each entry
       is a list that contains the indexes of patterns belonging to that
       step. Overrides the ``shuffle``, ``balance_steps`` and
       ``min_class_patterns_in_step`` parameters.
   :param reproducibility_data: If not None, overrides all the other
       scenario definition options, including ``fixed_step_assignment``.
       This is usually a dictionary containing data used to
       reproduce a specific experiment. One can use the
       ``get_reproducibility_data`` method to get (and even distribute)
       the experiment setup so that it can be loaded by passing it as this
       parameter. In this way one can be sure that the same specific
       experimental setup is being used (for reproducibility purposes).
       Beware that, in order to reproduce an experiment, the same train and
       test datasets must be used. Defaults to None.

   .. method:: classes_in_step(self) -> Sequence[Set[int]]
      :property:


   .. method:: get_reproducibility_data(self) -> Dict[str, Any]



.. py:class:: NIStepInfo(origin_stream: GenericScenarioStream['NIStepInfo', NIScenario[TrainSet, TestSet]], current_step: int)

   Bases: :class:`GenericStepInfo[NIScenario[TrainSet, TestSet], GenericScenarioStream['NIStepInfo', NIScenario[TrainSet, TestSet]]]`, :class:`Generic[TrainSet, TestSet]`

   Defines a "New Instances" step. It defines fields to obtain the current
   dataset and the associated task label. It also keeps a reference to the
   stream from which this step was taken.

   Creates a ``NIStepInfo`` instance given the stream from this
   step was taken and and the current step ID.

   :param origin_stream: The stream from which this step was obtained.
   :param current_step: The current step ID, as an integer.


.. function:: make_ni_transformation_subset(dataset: IDatasetWithTargets, transform: Any, target_transform: Any, patterns_indexes: Union[None, Sequence[int]], bucket_classes: bool = False, sort_classes: bool = False, sort_indexes: bool = False) -> TransformationSubset

   Creates a subset given the list of patterns to include.

   :param dataset: The original dataset
   :param transform: The transform function for patterns. Can be None.
   :param target_transform: The transform function for targets. Can be None.
   :param patterns_indexes: A list of indexes of patterns to include.
       If None, all patterns will be included.
   :param bucket_classes: If True, the final Dataset will output patterns by
       grouping them by class. Defaults to True.
   :param sort_classes: If ``bucket_classes`` and ``sort_classes`` are both
       True, the final Dataset will output patterns by grouping them by class
       and the class groups will be ordered by class ID (ascending). Ignored
       if ``bucket_classes`` is False. Defaults to False.
   :param sort_indexes: If True, pattern indexes will be sorted (ascending).
       When grouping by class, patterns will be sorted inside their respective
       class buckets. Defaults to False.

   :returns: A :class:`TransformationSubset` that includes only the required
       patterns, in the order controlled by the ``bucket_classes``,
       ``sort_classes`` and ``sort_indexes`` parameters.


