:mod:`avalanche.benchmarks`
===========================

.. py:module:: avalanche.benchmarks


Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   classic/index.rst
   datasets/index.rst
   generators/index.rst
   scenarios/index.rst


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   utils/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   avalanche.benchmarks.NCScenario
   avalanche.benchmarks.NCStepInfo
   avalanche.benchmarks.NIScenario
   avalanche.benchmarks.NIStepInfo
   avalanche.benchmarks.DatasetPart
   avalanche.benchmarks.DatasetType
   avalanche.benchmarks.IStepInfo
   avalanche.benchmarks.TinyImagenet
   avalanche.benchmarks.CUB200



Functions
~~~~~~~~~

.. autoapisummary::

   avalanche.benchmarks.make_ni_transformation_subset
   avalanche.benchmarks.create_multi_dataset_generic_scenario
   avalanche.benchmarks.create_generic_scenario_from_filelists
   avalanche.benchmarks.create_generic_scenario_from_tensors
   avalanche.benchmarks.NCBenchmark
   avalanche.benchmarks.NIBenchmark
   avalanche.benchmarks.DatasetScenario
   avalanche.benchmarks.FilelistScenario
   avalanche.benchmarks.TensorScenario
   avalanche.benchmarks.CORe50
   avalanche.benchmarks.NCBenchmark
   avalanche.benchmarks.SplitTinyImageNet
   avalanche.benchmarks.SplitCIFAR10
   avalanche.benchmarks._get_cifar10_dataset
   avalanche.benchmarks.concat_datasets_sequentially
   avalanche.benchmarks.SplitCIFAR100
   avalanche.benchmarks.SplitCIFAR110
   avalanche.benchmarks._get_cifar100_dataset
   avalanche.benchmarks.SplitMNIST
   avalanche.benchmarks.PermutedMNIST
   avalanche.benchmarks.RotatedMNIST
   avalanche.benchmarks._get_mnist_dataset
   avalanche.benchmarks.SplitFMNIST
   avalanche.benchmarks._get_fmnist_dataset
   avalanche.benchmarks.ImageNet
   avalanche.benchmarks.SplitImageNet
   avalanche.benchmarks.SplitCUB200


.. py:class:: NCScenario(train_dataset: TrainSetWithTargets, test_dataset: TestSetWithTargets, n_steps: int, task_labels: bool, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, per_step_classes: Optional[Dict[int, int]] = None, class_ids_from_zero_from_first_step: bool = False, class_ids_from_zero_in_each_step: bool = False, reproducibility_data: Optional[Dict[str, Any]] = None)

   Bases: :class:`GenericCLScenario[TrainSetWithTargets, TestSetWithTargets, 'NCStepInfo']`, :class:`Generic[TrainSetWithTargets, TestSetWithTargets]`

   This class defines a "New Classes" scenario. Once created, an instance
   of this class can be iterated in order to obtain the step sequence
   under the form of instances of :class:`NCStepInfo`.

   This class can be used directly. However, we recommend using facilities like
   :func:`avalanche.benchmarks.generators.NCBenchmark`.

   Creates a ``NCGenericScenario`` instance given the training and test
   Datasets and the number of steps.

   By default, the number of classes will be automatically detected by
   looking at the training Dataset ``targets`` field. Classes will be
   uniformly distributed across ``n_steps`` unless a ``per_step_classes``
   argument is specified.

   The number of classes must be divisible without remainder by the number
   of steps. This also applies when the ``per_step_classes`` argument is
   not None.

   :param train_dataset: The training dataset. The dataset must contain a
       ``targets`` field. For instance, one can safely use the datasets
       from the torchvision package.
   :param test_dataset: The test dataset. The dataset must contain a
       ``targets`` field. For instance, one can safely use the datasets
       from the torchvision package.
   :param n_steps: The number of steps.
   :param task_labels: If True, each step will have an ascending task
       label. If False, the task label will be 0 for all the steps.
   :param shuffle: If True, the class order will be shuffled. Defaults to
       True.
   :param seed: If shuffle is True and seed is not None, the class order
       will be shuffled according to the seed. When None, the current
       PyTorch random number generator state will be used.
       Defaults to None.
   :param fixed_class_order: If not None, the class order to use (overrides
       the shuffle argument). Very useful for enhancing
       reproducibility. Defaults to None.
   :param per_step_classes: Is not None, a dictionary whose keys are
       (0-indexed) step IDs and their values are the number of classes
       to include in the respective steps. The dictionary doesn't
       have to contain a key for each step! All the remaining steps
       will contain an equal amount of the remaining classes. The
       remaining number of classes must be divisible without remainder
       by the remaining number of steps. For instance,
       if you want to include 50 classes in the first step
       while equally distributing remaining classes across remaining
       steps, just pass the "{0: 50}" dictionary as the
       per_step_classes parameter. Defaults to None.
   :param class_ids_from_zero_from_first_step: If True, original class IDs
       will be remapped so that they will appear as having an ascending
       order. For instance, if the resulting class order after shuffling
       (or defined by fixed_class_order) is [23, 34, 11, 7, 6, ...] and
       class_ids_from_zero_from_first_step is True, then all the patterns
       belonging to class 23 will appear as belonging to class "0",
       class "34" will be mapped to "1", class "11" to "2" and so on.
       This is very useful when drawing confusion matrices and when dealing
       with algorithms with dynamic head expansion. Defaults to False.
       Mutually exclusive with the ``class_ids_from_zero_in_each_step``
       parameter.
   :param class_ids_from_zero_in_each_step: If True, original class IDs
       will be mapped to range [0, n_classes_in_step) for each step.
       Defaults to False. Mutually exclusive with the
       ``class_ids_from_zero_from_first_step parameter``.
   :param reproducibility_data: If not None, overrides all the other
       scenario definition options. This is usually a dictionary containing
       data used to reproduce a specific experiment. One can use the
       ``get_reproducibility_data`` method to get (and even distribute)
       the experiment setup so that it can be loaded by passing it as this
       parameter. In this way one can be sure that the same specific
       experimental setup is being used (for reproducibility purposes).
       Beware that, in order to reproduce an experiment, the same train and
       test datasets must be used. Defaults to None.

   .. attribute:: classes_order
      :annotation: :List[int] = []

      Stores the class order (remapped class IDs). 


   .. attribute:: classes_order_original_ids
      :annotation: :List[int]

      Stores the class order (original class IDs) 


   .. attribute:: class_mapping
      :annotation: :List[int] = []

      class_mapping stores the class mapping so that
      mapped_class_id = class_mapping[original_class_id]. 


   .. attribute:: n_classes_per_step
      :annotation: :List[int] = []

      A list that, for each step (identified by its index/ID),
      stores the number of classes assigned to that step. 


   .. attribute:: original_classes_in_step
      :annotation: :List[Set[int]] = []

      A list that, for each step (identified by its index/ID),
      stores a list of the original IDs of classes assigned 
      to that step. 


   .. attribute:: class_ids_from_zero_from_first_step
      :annotation: :bool

      If True the class IDs have been remapped to start from zero. 


   .. attribute:: class_ids_from_zero_in_each_step
      :annotation: :bool

      If True the class IDs have been remapped to start from zero in 
      each step 


   .. attribute:: n_classes
      :annotation: :int

      The number of classes 


   .. method:: classes_in_step(self) -> Sequence[Set[int]]
      :property:

      A list that, for each step (identified by its index/ID),
      stores a set of the (optionally remapped) IDs of classes of patterns
      assigned to that step. 


   .. method:: get_reproducibility_data(self)

      Gets the data needed to reproduce this experiment.

      This data can be stored using the pickle module or some other mechanism.
      It can then be loaded by passing it as the ``reproducibility_data``
      parameter in the constructor.

      Child classes should get the reproducibility dictionary from super class
      and then merge their custom data before returning it.

      :return: A dictionary containing the data needed to reproduce the
          experiment.


   .. method:: classes_in_step_range(self, step_start: int, step_end: Optional[int] = None) -> List[int]

      Gets a list of classes contained in the given steps. The steps are
      defined by range. This means that only the classes in range
      [step_start, step_end) will be included.

      :param step_start: The starting step ID.
      :param step_end: The final step ID. Can be None, which means that all
          the remaining steps will be taken.

      :returns: The classes contained in the required step range.



.. py:class:: NCStepInfo(scenario: NCScenario[TrainSetWithTargets, TestSetWithTargets], current_step: int, force_train_transformations: bool = False, force_test_transformations: bool = False, are_transformations_disabled: bool = False)

   Bases: :class:`GenericStepInfo[NCScenario[TrainSetWithTargets, TestSetWithTargets]]`, :class:`Generic[TrainSetWithTargets, TestSetWithTargets]`

   Defines a "New Classes" step. It defines methods to obtain the current,
   previous, cumulative and future training and test sets. It also defines
   fields that can be used to check which classes are in this, previous and
   future steps. Instances of this class are usually created when iterating
   over a :class:`NCScenario` instance.

   It keeps a reference to that :class:`NCScenario` instance, which can be used
   to retrieve additional info about the scenario.

   Creates a ``NCStepInfo`` instance given the root scenario.
   Instances of this class are usually created automatically while
   iterating over an instance of :class:`NCScenario`.

   :param scenario: A reference to the NC scenario.
   :param current_step: The step ID.
   :param force_train_transformations: If True, train transformations will
       be applied to the test set too. The ``force_test_transformations``
       parameter can't be True at the same time. Defaults to False.
   :param force_test_transformations: If True, test transformations will be
       applied to the training set too. The ``force_train_transformations``
       parameter can't be True at the same time. Defaults to False.
   :param are_transformations_disabled: If True, transformations are
       disabled. That is, patterns and targets will be returned as
       outputted by  the original training and test Datasets. Overrides
       ``force_train_transformations`` and ``force_test_transformations``.
       Defaults to False.

   .. method:: _make_subset(self, is_train: bool, step: int, **kwargs) -> MTSingleSet



.. py:class:: NIScenario(train_dataset: TrainSetWithTargets, test_dataset: TestSetWithTargets, n_steps: int, task_labels: bool = False, shuffle: bool = True, seed: Optional[int] = None, balance_steps: bool = False, min_class_patterns_in_step: int = 0, fixed_step_assignment: Optional[Sequence[Sequence[int]]] = None, reproducibility_data: Optional[Dict[str, Any]] = None)

   Bases: :class:`GenericCLScenario[TrainSetWithTargets, TestSetWithTargets, 'NIStepInfo']`, :class:`Generic[TrainSetWithTargets, TestSetWithTargets]`

   This class defines a "New Instance" scenario.
   Once created, an instance of this class can be iterated in order to obtain
   the step sequence under the form of instances of :class:`NIStepInfo`.

   Instances of this class can be created using the constructor directly.
   However, we recommend using facilities like
   :func:`avalanche.benchmarks.generators.NIBenchmark`.

   Consider that every method from :class:`NIStepInfo` used to retrieve
   parts of the test set (past, current, future, cumulative) always return the
   complete test set. That is, they behave as the getter for the complete test
   set.

   Creates a NIScenario instance given the training and test Datasets and
   the number of steps.

   :param train_dataset: The training dataset. The dataset must contain a
       "targets" field. For instance, one can safely use the datasets from
       the torchvision package.
   :param test_dataset: The test dataset. The dataset must contain a
       "targets" field. For instance, one can safely use the datasets from
       the torchvision package.
   :param n_steps: The number of steps.
   :param task_labels: If True, each step will have an ascending task
       label. If False, the task label will be 0 for all the steps.
       Defaults to False.
   :param shuffle: If True, the patterns order will be shuffled. Defaults
       to True.
   :param seed: If shuffle is True and seed is not None, the class order
       will be shuffled according to the seed. When None, the current
       PyTorch random number generator state will be used.
       Defaults to None.
   :param balance_steps: If True, pattern of each class will be equally
       spread across all steps. If False, patterns will be assigned to
       steps in a complete random way. Defaults to False.
   :param min_class_patterns_in_step: The minimum amount of patterns of
       every class that must be assigned to every step. Compatible with
       the ``balance_steps`` parameter. An exception will be raised if
       this constraint can't be satisfied. Defaults to 0.
   :param fixed_step_assignment: If not None, the pattern assignment
       to use. It must be a list with an entry for each step. Each entry
       is a list that contains the indexes of patterns belonging to that
       step. Overrides the ``shuffle``, ``balance_steps`` and
       ``min_class_patterns_in_step`` parameters.
   :param reproducibility_data: If not None, overrides all the other
       scenario definition options, including ``fixed_step_assignment``.
       This is usually a dictionary containing data used to
       reproduce a specific experiment. One can use the
       ``get_reproducibility_data`` method to get (and even distribute)
       the experiment setup so that it can be loaded by passing it as this
       parameter. In this way one can be sure that the same specific
       experimental setup is being used (for reproducibility purposes).
       Beware that, in order to reproduce an experiment, the same train and
       test datasets must be used. Defaults to None.

   .. method:: classes_in_step(self) -> Sequence[Set[int]]
      :property:

      A list that, for each step (identified by its index/ID),
      stores a set of the (optionally remapped) IDs of classes of patterns
      assigned to that step. 


   .. method:: get_reproducibility_data(self) -> Dict[str, Any]

      Gets the data needed to reproduce this experiment.

      This data can be stored using the pickle module or some other mechanism.
      It can then be loaded by passing it as the ``reproducibility_data``
      parameter in the constructor.

      Child classes should get the reproducibility dictionary from super class
      and then merge their custom data before returning it.

      :return: A dictionary containing the data needed to reproduce the
          experiment.



.. py:class:: NIStepInfo(scenario: NIScenario[TrainSetWithTargets, TestSetWithTargets], current_step: int, force_train_transformations: bool = False, force_test_transformations: bool = False, are_transformations_disabled: bool = False)

   Bases: :class:`GenericStepInfo[NIScenario[TrainSetWithTargets, TestSetWithTargets]]`, :class:`Generic[TrainSetWithTargets, TestSetWithTargets]`

   Defines a "New Instances" step. It defines methods to obtain the current,
   previous, cumulative and future training sets. The returned test
   set is always the complete one (methods used to get previous, cumulative and
   future sets simply return the complete one). It also defines fields that can
   be used to check which classes are in this, previous and
   future steps. Instances of this class are usually created when iterating
   over a :class:`NIScenario` instance.

   It keeps a reference to that :class:`NIScenario` instance, which can be
   used to retrieve additional info about the scenario.

   Creates a NCStepInfo instance given the root scenario.
   Instances of this class are usually created automatically while
   iterating over an instance of :class:`NIScenario`.

   :param scenario: A reference to the NI scenario
   :param current_step: Defines the current step ID.
   :param force_train_transformations: If True, train transformations will
       be applied to the test set too. The ``force_test_transformations``
       parameter can't be True at the same time. Defaults to False.
   :param force_test_transformations: If True, test transformations will be
       applied to the training set too. The ``force_train_transformations``
       parameter can't be True at the same time. Defaults to False.
   :param are_transformations_disabled: If True, transformations are
       disabled. That is, patterns and targets will be returned as
       outputted by  the original training and test Datasets. Overrides
       ``force_train_transformations`` and ``force_test_transformations``.
       Defaults to False.


.. function:: make_ni_transformation_subset(dataset: IDatasetWithTargets, transform: Any, target_transform: Any, patterns_indexes: Union[None, Sequence[int]], bucket_classes: bool = False, sort_classes: bool = False, sort_indexes: bool = False) -> TransformationSubset

   Creates a subset given the list of patterns to include.

   :param dataset: The original dataset
   :param transform: The transform function for patterns. Can be None.
   :param target_transform: The transform function for targets. Can be None.
   :param patterns_indexes: A list of indexes of patterns to include.
       If None, all patterns will be included.
   :param bucket_classes: If True, the final Dataset will output patterns by
       grouping them by class. Defaults to True.
   :param sort_classes: If ``bucket_classes`` and ``sort_classes`` are both
       True, the final Dataset will output patterns by grouping them by class
       and the class groups will be ordered by class ID (ascending). Ignored
       if ``bucket_classes`` is False. Defaults to False.
   :param sort_indexes: If True, pattern indexes will be sorted (ascending).
       When grouping by class, patterns will be sorted inside their respective
       class buckets. Defaults to False.

   :returns: A :class:`TransformationSubset` that includes only the required
       patterns, in the order controlled by the ``bucket_classes``,
       ``sort_classes`` and ``sort_indexes`` parameters.


.. py:class:: DatasetPart

   Bases: :class:`enum.Enum`

   An enumeration defining the different dataset parts

   Create and return a new object.  See help(type) for accurate signature.

   .. attribute:: CURRENT
      :annotation: = 1

      

   .. attribute:: CUMULATIVE
      :annotation: = 2

      

   .. attribute:: OLD
      :annotation: = 3

      

   .. attribute:: FUTURE
      :annotation: = 4

      

   .. attribute:: COMPLETE
      :annotation: = 5

      


.. py:class:: DatasetType

   Bases: :class:`enum.Enum`

   An enumeration defining the different dataset types

   Create and return a new object.  See help(type) for accurate signature.

   .. attribute:: TRAIN
      :annotation: = 1

      

   .. attribute:: VALIDATION
      :annotation: = 2

      


.. data:: TrainSetWithTargets
   

   

.. data:: TestSetWithTargets
   

   

.. data:: MTSingleSet
   

   

.. data:: MTMultipleSet
   

   

.. py:class:: IStepInfo

   Bases: :class:`typing.Protocol`

   Definition of a learning step. A learning step contains a set of patterns
   which has become available at a particular time instant. The content and
   size of a Step is defined by the specific benchmark that creates the
   IStepInfo instance.

   For instance, a step of a New Classes scenario will contain all patterns
   belonging to a subset of classes of the original training set. A step of a
   New Instance scenario will contain patterns from previously seen classes.

   Steps of  Single Incremental Task (a.k.a. task-free) scenarios are usually
   called "batches" while in Multi Task scenarios a Step is usually associated
   to a "task". Finally, in a Multi Incremental Task scenario the Step may be
   composed by patterns from different tasks.

   Create and return a new object.  See help(type) for accurate signature.

   .. attribute:: current_step
      :annotation: :int

      

   .. attribute:: n_steps
      :annotation: :int

      

   .. method:: current_training_set(self, bucket_classes=False, sort_classes=False, sort_indexes=False) -> MTSingleSet

      Gets the training set for the current step (batch/task).

      :param bucket_classes: If True, dataset patterns will be grouped by
          class. Defaults to False.
      :param sort_classes: If True (and ``bucket_classes`` is True), class
          groups will be sorted by class ID (ascending). Defaults to False.
      :param sort_indexes: If True patterns will be ordered by their ID
          (ascending). If ``sort_classes`` and ``bucket_classes`` are both
          True, patterns will be sorted inside their groups.
          Defaults to False.

      :returns: The current step training set, as a tuple containing the
          Dataset and the task label. For SIT scenarios, the task label
          will always be 0.


   .. method:: cumulative_training_sets(self, include_current_step: bool = True, bucket_classes=False, sort_classes=False, sort_indexes=False) -> MTMultipleSet

      Gets the list of cumulative training sets.

      :param include_current_step: If True, include the current step
          training set. Defaults to True.
      :param bucket_classes: If True, dataset patterns will be grouped by
          class. Defaults to False.
      :param sort_classes: If True (and ``bucket_classes`` is True), class
          groups will be sorted by class ID (ascending). Defaults to False.
      :param sort_indexes: If True patterns will be ordered by their ID
          (ascending). If ``sort_classes`` and ``bucket_classes`` are both
          True, patterns will be sorted inside their groups.
          Defaults to False.

      :returns: The cumulative training sets, as a list. Each element of the
          list is a tuple containing the Dataset and the task label. For SIT
          scenarios, the task label will always be 0.


   .. method:: complete_training_sets(self, bucket_classes=False, sort_classes=False, sort_indexes=False) -> MTMultipleSet

      Gets the complete list of training sets.

      :param bucket_classes: If True, dataset patterns will be grouped by
          class. Defaults to False.
      :param sort_classes: If True (and ``bucket_classes`` is True), class
          groups will be sorted by class ID (ascending). Defaults to False.
      :param sort_indexes: If True patterns will be ordered by their ID
          (ascending). If ``sort_classes`` and ``bucket_classes`` are both
          True, patterns will be sorted inside their groups.
          Defaults to False.

      :returns: All the training sets, as a list. Each element of the list is
          a tuple containing the Dataset and the task label. For SIT
          scenarios, the task label will always be 0.


   .. method:: future_training_sets(self, bucket_classes=False, sort_classes=False, sort_indexes=False) -> MTMultipleSet

      Gets the "future" training sets. That is, datasets of future steps.

      :param bucket_classes: If True, dataset patterns will be grouped by
          class. Defaults to False.
      :param sort_classes: If True (and ``bucket_classes`` is True), class
          groups will be sorted by class ID (ascending). Defaults to False.
      :param sort_indexes: If True patterns will be ordered by their ID
          (ascending). If ``sort_classes`` and ``bucket_classes`` are both
          True, patterns will be sorted inside their groups.
          Defaults to False.

      :returns: The future training sets, as a list. Each element of the list
          is a tuple containing the Dataset and the task label. For SIT
          scenarios, the task label will always be 0.


   .. method:: step_specific_training_set(self, step_id: int, bucket_classes=False, sort_classes=False, sort_indexes=False) -> MTSingleSet

      Gets the training set of a specific step (batch/task), given its ID.

      :param step_id: The ID of the step.
      :param bucket_classes: If True, dataset patterns will be grouped by
          class. Defaults to False.
      :param sort_classes: If True (and ``bucket_classes`` is True), class
          groups will be sorted by class ID (ascending). Defaults to False.
      :param sort_indexes: If True patterns will be ordered by their ID
          (ascending). If ``sort_classes`` and ``bucket_classes`` are both
          True, patterns will be sorted inside their groups.
          Defaults to False.

      :returns: The required training set, as a tuple containing the Dataset
          and the task label. For SIT scenarios, the task label will always
          be 0.


   .. method:: training_set_part(self, dataset_part: DatasetPart, bucket_classes=False, sort_classes=False, sort_indexes=False) -> MTMultipleSet

      Gets the training subset of a specific part of the scenario.

      :param dataset_part: The part of the scenario.
      :param bucket_classes: If True, dataset patterns will be grouped by
          class. Defaults to False.
      :param sort_classes: If True (and ``bucket_classes`` is True), class
          groups will be sorted by class ID (ascending). Defaults to False.
      :param sort_indexes: If True patterns will be ordered by their ID
          (ascending). If ``sort_classes`` and ``bucket_classes`` are both
          True, patterns will be sorted inside their groups.
          Defaults to False.

      :returns: The training set of the desired part, as a list. Each element
          of the list is a tuple containing the Dataset and the task label.
          For SIT scenarios, the task label will always be 0.


   .. method:: current_test_set(self, bucket_classes=False, sort_classes=False, sort_indexes=False) -> MTSingleSet

      Gets the test set for the current step (batch/task).

      :param bucket_classes: If True, dataset patterns will be grouped by
          class. Defaults to False.
      :param sort_classes: If True (and ``bucket_classes`` is True), class
          groups will be sorted by class ID (ascending). Defaults to False.
      :param sort_indexes: If True patterns will be ordered by their ID
          (ascending). If ``sort_classes`` and ``bucket_classes`` are both
          True, patterns will be sorted inside their groups.
          Defaults to False.

      :returns: The current test set, as a tuple containing the Dataset and
          the task label. For SIT scenarios, the task label will always be 0.


   .. method:: cumulative_test_sets(self, include_current_step: bool = True, bucket_classes=False, sort_classes=False, sort_indexes=False) -> MTMultipleSet

      Gets the list of cumulative test sets (batch/task).

      :param include_current_step: If True, include the current step
          training set. Defaults to True.
      :param bucket_classes: If True, dataset patterns will be grouped by
          class. Defaults to False.
      :param sort_classes: If True (and ``bucket_classes`` is True), class
          groups will be sorted by class ID (ascending). Defaults to False.
      :param sort_indexes: If True patterns will be ordered by their ID
          (ascending). If ``sort_classes`` and ``bucket_classes`` are both
          True, patterns will be sorted inside their groups.
          Defaults to False.

      :returns: The cumulative test sets, as a list. Each element of the
          list is a tuple containing the Dataset and the task label. For SIT
          scenarios, the task label will always be 0.


   .. method:: complete_test_sets(self, bucket_classes=False, sort_classes=False, sort_indexes=False) -> MTMultipleSet

      Gets the complete list of test sets.

      :param bucket_classes: If True, dataset patterns will be grouped by
          class. Defaults to False.
      :param sort_classes: If True (and ``bucket_classes`` is True), class
          groups will be sorted by class ID (ascending). Defaults to False.
      :param sort_indexes: If True patterns will be ordered by their ID
          (ascending). If ``sort_classes`` and ``bucket_classes`` are both
          True, patterns will be sorted inside their groups.
          Defaults to False.

      :returns: All the test sets, as a list. Each element of the list is a
          tuple containing the Dataset and the task label. For SIT scenarios,
          the task label will always be 0.


   .. method:: future_test_sets(self, bucket_classes=False, sort_classes=False, sort_indexes=False) -> MTMultipleSet

      Gets the "future" test sets. That is, datasets of future steps.

      :param bucket_classes: If True, dataset patterns will be grouped by
          class. Defaults to False.
      :param sort_classes: If True (and ``bucket_classes`` is True), class
          groups will be sorted by class ID (ascending). Defaults to False.
      :param sort_indexes: If True patterns will be ordered by their ID
          (ascending). If ``sort_classes`` and ``bucket_classes`` are both
          True, patterns will be sorted inside their groups.
          Defaults to False.

      :returns: The future test sets, as a list. Each element of the list is a
          tuple containing the Dataset and the task label. For SIT scenarios,
          the task label will always be 0.


   .. method:: step_specific_test_set(self, step_id: int, bucket_classes=False, sort_classes=False, sort_indexes=False) -> MTSingleSet

      Gets the test set of a specific step (batch/task), given its ID.

      :param step_id: The ID of the step (batch/task).
      :param bucket_classes: If True, dataset patterns will be grouped by
          class. Defaults to False.
      :param sort_classes: If True (and ``bucket_classes`` is True), class
          groups will be sorted by class ID (ascending). Defaults to False.
      :param sort_indexes: If True patterns will be ordered by their ID
          (ascending). If ``sort_classes`` and ``bucket_classes`` are both
          True, patterns will be sorted inside their groups.
          Defaults to False.

      :returns: The required test set, as a tuple containing the Dataset
          and the task label. For SIT scenarios, the task label will always
          be 0.


   .. method:: test_set_part(self, dataset_part: DatasetPart, bucket_classes=False, sort_classes=False, sort_indexes=False) -> MTMultipleSet

      Gets the test subset of a specific part of the scenario.

      :param dataset_part: The part of the scenario
      :param bucket_classes: If True, dataset patterns will be grouped by
          class. Defaults to False.
      :param sort_classes: If True (and ``bucket_classes`` is True), class
          groups will be sorted by class ID (ascending). Defaults to False.
      :param sort_indexes: If True patterns will be ordered by their ID
          (ascending). If ``sort_classes`` and ``bucket_classes`` are both
          True, patterns will be sorted inside their groups.
          Defaults to False.

      :returns: The test sets of the desired part, as a list. Each element
          of the list is a tuple containing the Dataset and the task label.
          For SIT scenarios, the task label will always be 0.


   .. method:: disable_transformations(self: TStepInfo) -> 'TStepInfo'

      Returns a new step info instance in which transformations are disabled.
      The current instance is not affected. This is useful when there is a
      need to access raw data. Can be used when picking and storing
      rehearsal/replay patterns.

      :returns: A new ``IStepInfo`` in which transformations are disabled.


   .. method:: enable_transformations(self: TStepInfo) -> 'TStepInfo'

      Returns a new step info instance in which transformations are enabled.
      The current instance is not affected. When created the ``IStepInfo``
      instance already has transformations enabled. This method can be used to
      re-enable transformations after a previous call to
      ``disable_transformations()``.

      :returns: A new ``IStepInfo`` in which transformations are enabled.


   .. method:: with_train_transformations(self: TStepInfo) -> 'TStepInfo'

      Returns a new step info instance in which train transformations are
      applied to both training and test sets. The current instance is not
      affected.

      :returns: A new ``IStepInfo`` in which train transformations are applied
          to both training and test sets.


   .. method:: with_test_transformations(self: TStepInfo) -> 'TStepInfo'

      Returns a new step info instance in which test transformations are
      applied to both training and test sets. The current instance is
      not affected. This is useful to get the accuracy on the training set
      without considering the usual training data augmentations.

      :returns: A new ``IStepInfo`` in which test transformations are applied
          to both training and test sets.



.. data:: TStepInfo
   

   

.. function:: create_multi_dataset_generic_scenario(train_dataset_list: Sequence[IDatasetWithTargets], test_dataset_list: Sequence[IDatasetWithTargets], task_labels: Sequence[int], complete_test_set_only: bool = False) -> GenericCLScenario

   Creates a generic scenario given a list of datasets and the respective task
   labels. Each training dataset will be considered as a separate training
   step. Contents of the datasets will not be changed, including the targets.

   When loading the datasets from a set of fixed filelist, consider using
   the :func:`create_generic_scenario_from_filelists` helper method instead.

   In its base form, this function accepts a list of test datsets that must
   contain the same amount of datasets of the training list.
   Those pairs are then used to create the "past", "cumulative"
   (a.k.a. growing) and "future" test sets. However, in certain Continual
   Learning scenarios only the concept of "complete" test set makes sense. In
   that case, the ``complete_test_set_only`` should be set to True (see the
   parameter description for more info).

   Beware that pattern transformations must already be included in the
   datasets (when needed).

   :param train_dataset_list: A list of training datasets.
   :param test_dataset_list: A list of test datasets.
   :param task_labels: A list of task labels. Must contain the same amount of
       elements of the ``train_dataset_list`` parameter. For
       Single-Incremental-Task (a.k.a. Task-Free) scenarios, this is usually
       a list of zeros. For Multi Task scenario, this is usually a list of
       ascending task labels (starting from 0).
   :param complete_test_set_only: If True, only the complete test set will
       be returned by the scenario. This means that the ``test_dataset_list``
       parameter must be list with a single element (the complete test set).
       Defaults to False, which means that ``train_dataset_list`` and
       ``test_dataset_list`` must contain the same amount of datasets.

   :returns: A :class:`GenericCLScenario` instance.


.. function:: create_generic_scenario_from_filelists(root: Union[str, Path], train_file_lists: Sequence[Union[str, Path]], test_file_lists: Union[Union[str, Path], Sequence[Union[str, Path]]], task_labels: Sequence[int], complete_test_set_only: bool = False, train_transform=None, train_target_transform=None, test_transform=None, test_target_transform=None) -> GenericCLScenario

   Creates a generic scenario given a list of filelists and the respective task
   labels. A separate dataset will be created for each filelist and each of
   those training datasets will be considered a separate training step.
   Contents of the datasets will not be changed, including the targets.

   In its base form, this function accepts a list of filelists for the test
   datsets that must contain the same amount of elements of the training list.
   Those pairs of datasets are then used to create the "past", "cumulative"
   (a.k.a. growing) and "future" test sets. However, in certain Continual
   Learning scenarios only the concept of "complete" test set makes sense. In
   that case, the ``complete_test_set_only`` should be set to True (see the
   parameter description for more info).

   This helper functions is the best shot when loading Caffe-style dataset
   based on filelists.

   :param root: The root path of the dataset.
   :param train_file_lists: A list of filelists describing the
       paths of the training patterns for each step.
   :param test_file_lists: A list of filelists describing the
       paths of the test patterns for each step.
   :param task_labels: A list of task labels. Must contain the same amount of
       elements of the ``train_file_lists`` parameter. For
       Single-Incremental-Task (a.k.a. Task-Free) scenarios, this is usually
       a list of zeros. For Multi Task scenario, this is usually a list of
       ascending task labels (starting from 0).
   :param complete_test_set_only: If True, only the complete test set will
       be returned by the scenario. This means that the ``test_file_lists``
       parameter must be list with a single element (the complete test set).
       Alternatively, can be a plain string or :class:`Path` object.
       Defaults to False, which means that ``train_file_lists`` and
       ``test_file_lists`` must contain the same amount of filelists paths.
   :param train_transform: The transformation to apply to training patterns.
       Defaults to None.
   :param train_target_transform: The transformation to apply to training
       patterns targets. Defaults to None.
   :param test_transform: The transformation to apply to test patterns.
       Defaults to None.
   :param test_target_transform: The transformation to apply to test
       patterns targets. Defaults to None.

   :returns: A :class:`GenericCLScenario` instance.


.. function:: create_generic_scenario_from_tensors(train_data_x: Sequence[Any], train_data_y: Sequence[Sequence[SupportsInt]], test_data_x: Union[Any, Sequence[Any]], test_data_y: Union[Any, Sequence[Sequence[SupportsInt]]], task_labels: Sequence[int], complete_test_set_only: bool = False, train_transform=None, train_target_transform=None, test_transform=None, test_target_transform=None) -> GenericCLScenario

   Creates a generic scenario given lists of Tensors and the respective task
   labels. A separate dataset will be created from each Tensor pair (x + y)
   and each of those training datasets will be considered a separate
   training step. Contents of the datasets will not be changed, including the
   targets. Using this helper function is the lower level way to create a
   Continual Learning scenario. When possible, consider using higher level
   helpers.

   In its base form, the test lists must contain the same amount of elements of
   the training lists. Those pairs of datasets are then used to create the
   "past", "cumulative" (a.k.a. growing) and "future" test sets.
   However, in certain Continual Learning scenarios only the concept of
   "complete" test set makes sense. In that case, the
   ``complete_test_set_only`` should be set to True (see the parameter
   description for more info).

   :param train_data_x: A list of Tensors (one per step) containing the
       patterns of the training sets.
   :param train_data_y: A list of Tensors or int lists containing the
       labels of the patterns of the training sets. Must contain the same
       number of elements of ``train_datasets_x``.
   :param test_data_x: A Tensor or a list of Tensors (one per step) containing
       the patterns of the test sets.
   :param test_data_y: A Tensor or a list of Tensors or int lists containing
       the labels of the patterns of the test sets. Must contain the same
       number of elements of ``test_datasets_x``.
   :param task_labels: A list of task labels. Must contain the same amount of
       elements of the ``train_datasets_x`` parameter. For
       Single-Incremental-Task (a.k.a. Task-Free) scenarios, this is usually
       a list of zeros. For Multi Task scenario, this is usually a list of
       ascending task labels (starting from 0).
   :param complete_test_set_only: If True, only the complete test set will
       be returned by the scenario. This means that the ``test_datasets_x`` and
       ``test_datasets_y`` parameters must be lists with a single element
       (the complete test set). Defaults to False, which means that
       ``train_file_lists`` and ``test_file_lists`` must contain the same
       amount of filelists paths.
   :param train_transform: The transformation to apply to training patterns.
       Defaults to None.
   :param train_target_transform: The transformation to apply to training
       patterns targets. Defaults to None.
   :param test_transform: The transformation to apply to test patterns.
       Defaults to None.
   :param test_target_transform: The transformation to apply to test
       patterns targets. Defaults to None.

   :returns: A :class:`GenericCLScenario` instance.


.. function:: NCBenchmark(train_dataset: Union[Sequence[IDatasetWithTargets], IDatasetWithTargets], test_dataset: Union[Sequence[IDatasetWithTargets], IDatasetWithTargets], n_steps: int, task_labels: bool, *, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Sequence[int] = None, per_step_classes: Dict[int, int] = None, class_ids_from_zero_from_first_step: bool = False, class_ids_from_zero_in_each_step: bool = False, one_dataset_per_step: bool = False, reproducibility_data: Dict[str, Any] = None) -> NCScenario

   This method is the high-level specific scenario generator for the
   "New Classes" (NC) case. Given a sequence of train and test datasets creates
   the continual stream of data as a series of steps. Each step will contain
   all the patterns belonging to a certain set of classes and a class won't be
   assigned to more than one step.

   The ``task_labels`` parameter determines if each incremental step has
   an increasing task label or if, at the contrary, a default task label "0"
   has to be assigned to all steps. This can be useful when differentiating
   between Single-Incremental-Task and Multi-Task scenarios.

   There are other important parameters that can be specified in order to tweak
   the behaviour of the resulting scenario. Please take a few minutes to read
   and understand them as they may save you a lot of work.

   This generator features an integrated reproducibility mechanism that allows
   the user to store and later re-load a scenario. For more info see the
   ``reproducibility_data`` parameter.

   :param train_dataset: A list of training datasets, or a single dataset.
   :param test_dataset: A list of test datasets, or a single test dataset.
   :param n_steps: The number of incremental steps. This is not used when
       using multiple train/test datasets with the ``one_dataset_per_step``
       parameter set to True.
   :param task_labels: If True, each step will have an ascending task
           label. If False, the task label will be 0 for all the steps.
   :param shuffle: If True, the class (or step) order will be shuffled.
       Defaults to True.
   :param seed: If ``shuffle`` is True and seed is not None, the class (or
       step) order will be shuffled according to the seed. When None, the
       current PyTorch random number generator state will be used. Defaults to
       None.
   :param fixed_class_order: If not None, the class order to use (overrides
       the shuffle argument). Very useful for enhancing reproducibility.
       Defaults to None.
   :param per_step_classes: Is not None, a dictionary whose keys are
       (0-indexed) step IDs and their values are the number of classes
       to include in the respective steps. The dictionary doesn't
       have to contain a key for each step! All the remaining steps
       will contain an equal amount of the remaining classes. The
       remaining number of classes must be divisible without remainder
       by the remaining number of steps. For instance,
       if you want to include 50 classes in the first step
       while equally distributing remaining classes across remaining
       steps, just pass the "{0: 50}" dictionary as the
       per_step_classes parameter. Defaults to None.
   :param class_ids_from_zero_from_first_step: If True, original class IDs
       will be remapped so that they will appear as having an ascending
       order. For instance, if the resulting class order after shuffling
       (or defined by fixed_class_order) is [23, 34, 11, 7, 6, ...] and
       class_ids_from_zero_from_first_step is True, then all the patterns
       belonging to class 23 will appear as belonging to class "0",
       class "34" will be mapped to "1", class "11" to "2" and so on.
       This is very useful when drawing confusion matrices and when dealing
       with algorithms with dynamic head expansion. Defaults to False.
       Mutually exclusive with the ``class_ids_from_zero_in_each_step``
       parameter.
   :param class_ids_from_zero_in_each_step: If True, original class IDs
       will be mapped to range [0, n_classes_in_step) for each step.
       Defaults to False. Mutually exclusive with the
       ``class_ids_from_zero_from_first_step`` parameter.
   :param one_dataset_per_step: available only when multiple train-test
       datasets are provided. If True, each dataset will be treated as a step.
       Mutually exclusive with the ``per_step_classes`` and
       ``fixed_class_order`` parameters. Overrides the ``n_steps`` parameter.
       Defaults to False.
   :param reproducibility_data: If not None, overrides all the other
       scenario definition options. This is usually a dictionary containing
       data used to reproduce a specific experiment. One can use the
       ``get_reproducibility_data`` method to get (and even distribute)
       the experiment setup so that it can be loaded by passing it as this
       parameter. In this way one can be sure that the same specific
       experimental setup is being used (for reproducibility purposes).
       Beware that, in order to reproduce an experiment, the same train and
       test datasets must be used. Defaults to None.

   :return: A :class:`NCMultiTaskScenario` or :class:`NCSingleTaskScenario`
       instance initialized for the the SIT or MT scenario.


.. function:: NIBenchmark(train_dataset: Union[Sequence[IDatasetWithTargets], IDatasetWithTargets], test_dataset: Union[Sequence[IDatasetWithTargets], IDatasetWithTargets], n_steps: int, *, task_labels: bool = False, shuffle: bool = True, seed: Optional[int] = None, balance_steps: bool = False, min_class_patterns_in_step: int = 0, fixed_step_assignment: Optional[Sequence[Sequence[int]]] = None, reproducibility_data: Optional[Dict[str, Any]] = None) -> NIScenario

   This method is the high-level specific scenario generator for the
   "New Instances" (NI) case. Given a sequence of train and test datasets
   creates the continual stream of data as a series of steps. Each step will
   contain patterns belonging to different classes.

   The ``task_labels`` parameter determines if each incremental step has
   an increasing task label or if, at the contrary, a default task label "0"
   has to be assigned to all steps. This can be useful when differentiating
   between Single-Incremental-Task and Multi-Task scenarios.

   There are other important parameters that can be specified in order to tweak
   the behaviour of the resulting scenario. Please take a few minutes to read
   and understand them as they may save you a lot of work.

   This generator features an integrated reproducibility mechanism that allows
   the user to store and later re-load a scenario. For more info see the
   ``reproducibility_data`` parameter.

   :param train_dataset: A list of training datasets, or a single dataset.
   :param test_dataset: A list of test datasets, or a single test dataset.
   :param n_steps: The number of steps.
   :param task_labels: If True, each step will have an ascending task
           label. If False, the task label will be 0 for all the steps.
   :param shuffle: If True, patterns order will be shuffled.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param balance_steps: If True, pattern of each class will be equally
       spread across all steps. If False, patterns will be assigned to
       steps in a complete random way. Defaults to False.
   :param min_class_patterns_in_step: The minimum amount of patterns of
       every class that must be assigned to every step. Compatible with
       the ``balance_steps`` parameter. An exception will be raised if
       this constraint can't be satisfied. Defaults to 0.
   :param fixed_step_assignment: If not None, the pattern assignment
       to use. It must be a list with an entry for each step. Each entry
       is a list that contains the indexes of patterns belonging to that
       step. Overrides the ``shuffle``, ``balance_steps`` and
       ``min_class_patterns_in_step`` parameters.
   :param reproducibility_data: If not None, overrides all the other
       scenario definition options, including ``fixed_step_assignment``.
       This is usually a dictionary containing data used to
       reproduce a specific experiment. One can use the
       ``get_reproducibility_data`` method to get (and even distribute)
       the experiment setup so that it can be loaded by passing it as this
       parameter. In this way one can be sure that the same specific
       experimental setup is being used (for reproducibility purposes).
       Beware that, in order to reproduce an experiment, the same train and
       test datasets must be used. Defaults to None.

   :return: A :class:`NIScenario` instance.


.. function:: DatasetScenario(train_dataset_list: Sequence[IDatasetWithTargets], test_dataset_list: Sequence[IDatasetWithTargets], task_labels: Sequence[int], complete_test_set_only: bool = False) -> GenericCLScenario

   Creates a generic scenario given a list of datasets and the respective task
   labels. Each training dataset will be considered as a separate training
   step. Contents of the datasets will not be changed, including the targets.

   When loading the datasets from a set of fixed filelist, consider using
   the :func:`create_generic_scenario_from_filelists` helper method instead.

   In its base form, this function accepts a list of test datsets that must
   contain the same amount of datasets of the training list.
   Those pairs are then used to create the "past", "cumulative"
   (a.k.a. growing) and "future" test sets. However, in certain Continual
   Learning scenarios only the concept of "complete" test set makes sense. In
   that case, the ``complete_test_set_only`` should be set to True (see the
   parameter description for more info).

   Beware that pattern transformations must already be included in the
   datasets (when needed).

   :param train_dataset_list: A list of training datasets.
   :param test_dataset_list: A list of test datasets.
   :param task_labels: A list of task labels. Must contain the same amount of
       elements of the ``train_dataset_list`` parameter. For
       Single-Incremental-Task (a.k.a. Task-Free) scenarios, this is usually
       a list of zeros. For Multi Task scenario, this is usually a list of
       ascending task labels (starting from 0).
   :param complete_test_set_only: If True, only the complete test set will
       be returned by the scenario. This means that the ``test_dataset_list``
       parameter must be list with a single element (the complete test set).
       Defaults to False, which means that ``train_dataset_list`` and
       ``test_dataset_list`` must contain the same amount of datasets.

   :returns: A :class:`GenericCLScenario` instance.


.. function:: FilelistScenario(root: Union[str, Path], train_file_lists: Sequence[Union[str, Path]], test_file_lists: Union[Union[str, Path], Sequence[Union[str, Path]]], task_labels: Sequence[int], complete_test_set_only: bool = False, train_transform=None, train_target_transform=None, test_transform=None, test_target_transform=None) -> GenericCLScenario

   Creates a generic scenario given a list of filelists and the respective task
   labels. A separate dataset will be created for each filelist and each of
   those training datasets will be considered a separate training step.
   Contents of the datasets will not be changed, including the targets.

   In its base form, this function accepts a list of filelists for the test
   datsets that must contain the same amount of elements of the training list.
   Those pairs of datasets are then used to create the "past", "cumulative"
   (a.k.a. growing) and "future" test sets. However, in certain Continual
   Learning scenarios only the concept of "complete" test set makes sense. In
   that case, the ``complete_test_set_only`` should be set to True (see the
   parameter description for more info).

   This helper functions is the best shot when loading Caffe-style dataset
   based on filelists.

   :param root: The root path of the dataset.
   :param train_file_lists: A list of filelists describing the
       paths of the training patterns for each step.
   :param test_file_lists: A list of filelists describing the
       paths of the test patterns for each step.
   :param task_labels: A list of task labels. Must contain the same amount of
       elements of the ``train_file_lists`` parameter. For
       Single-Incremental-Task (a.k.a. Task-Free) scenarios, this is usually
       a list of zeros. For Multi Task scenario, this is usually a list of
       ascending task labels (starting from 0).
   :param complete_test_set_only: If True, only the complete test set will
       be returned by the scenario. This means that the ``test_file_lists``
       parameter must be list with a single element (the complete test set).
       Alternatively, can be a plain string or :class:`Path` object.
       Defaults to False, which means that ``train_file_lists`` and
       ``test_file_lists`` must contain the same amount of filelists paths.
   :param train_transform: The transformation to apply to training patterns.
       Defaults to None.
   :param train_target_transform: The transformation to apply to training
       patterns targets. Defaults to None.
   :param test_transform: The transformation to apply to test patterns.
       Defaults to None.
   :param test_target_transform: The transformation to apply to test
       patterns targets. Defaults to None.

   :returns: A :class:`GenericCLScenario` instance.


.. function:: TensorScenario(train_data_x: Sequence[Any], train_data_y: Sequence[Sequence[SupportsInt]], test_data_x: Union[Any, Sequence[Any]], test_data_y: Union[Any, Sequence[Sequence[SupportsInt]]], task_labels: Sequence[int], complete_test_set_only: bool = False, train_transform=None, train_target_transform=None, test_transform=None, test_target_transform=None) -> GenericCLScenario

   Creates a generic scenario given lists of Tensors and the respective task
   labels. A separate dataset will be created from each Tensor pair (x + y)
   and each of those training datasets will be considered a separate
   training step. Contents of the datasets will not be changed, including the
   targets. Using this helper function is the lower level way to create a
   Continual Learning scenario. When possible, consider using higher level
   helpers.

   In its base form, the test lists must contain the same amount of elements of
   the training lists. Those pairs of datasets are then used to create the
   "past", "cumulative" (a.k.a. growing) and "future" test sets.
   However, in certain Continual Learning scenarios only the concept of
   "complete" test set makes sense. In that case, the
   ``complete_test_set_only`` should be set to True (see the parameter
   description for more info).

   :param train_data_x: A list of Tensors (one per step) containing the
       patterns of the training sets.
   :param train_data_y: A list of Tensors or int lists containing the
       labels of the patterns of the training sets. Must contain the same
       number of elements of ``train_datasets_x``.
   :param test_data_x: A Tensor or a list of Tensors (one per step) containing
       the patterns of the test sets.
   :param test_data_y: A Tensor or a list of Tensors or int lists containing
       the labels of the patterns of the test sets. Must contain the same
       number of elements of ``test_datasets_x``.
   :param task_labels: A list of task labels. Must contain the same amount of
       elements of the ``train_datasets_x`` parameter. For
       Single-Incremental-Task (a.k.a. Task-Free) scenarios, this is usually
       a list of zeros. For Multi Task scenario, this is usually a list of
       ascending task labels (starting from 0).
   :param complete_test_set_only: If True, only the complete test set will
       be returned by the scenario. This means that the ``test_datasets_x`` and
       ``test_datasets_y`` parameters must be lists with a single element
       (the complete test set). Defaults to False, which means that
       ``train_file_lists`` and ``test_file_lists`` must contain the same
       amount of filelists paths.
   :param train_transform: The transformation to apply to training patterns.
       Defaults to None.
   :param train_target_transform: The transformation to apply to training
       patterns targets. Defaults to None.
   :param test_transform: The transformation to apply to test patterns.
       Defaults to None.
   :param test_target_transform: The transformation to apply to test
       patterns targets. Defaults to None.

   :returns: A :class:`GenericCLScenario` instance.


.. function:: CORe50(root=expanduser('~') + '/.avalanche/data/core50/', scenario='nicv2_391', run=0)

   CORe50 continual scenario generator

   :param root: Path indicating where to store the dataset and related
       metadata. By default they will be stored in
       avalanche/datasets/core50/data/.
   :param scenario: CORe50 main scanario. I can be chosen between 'ni', 'nc',
       'nic', 'nicv2_79', 'nicv2_196' or 'nicv2_391.'
   :param run: number of run for the scenario. Batch ordering change based
       on this parameter (a number between 0 and 9).

   :returns: it returns a :class:`GenericCLScenario` instance that can be
       iterated.


.. py:class:: TinyImagenet(data_folder=expanduser('~') + '/.avalanche/data/tinyimagenet/', train=True, transform=ToTensor(), target_transform=None, download=True)

   Bases: :class:`torch.utils.data.Dataset`

   Tiny Imagenet Pytorch Dataset

   Args:
       :param string data_folder: folder in which to download dataset
       :param boolean train: True for train set, False for test set
       :param fun transform: Pytorch transformation founction for x
       :param fun target_transform: Pytorch transformation founction for y
       :param bool download: True for downloading the dataset

   .. method:: download_tinyImageNet(self)

      Downloads the TintImagenet Dataset 


   .. method:: labels2dict(self)

      Returns dictionaries to convert class names into progressive ids
      and viceversa.
      :returns: label2id, id2label: two Python dictionaries.


   .. method:: load_data(self, train=True)

      Load all images paths and targets.

      :param bool train: True for loading the training set, False for the
          test set.
      :return: train_set, test_set: (train_X_paths, train_y).


   .. method:: get_train_images_paths(self, class_name)

      Gets the training set image paths

      :param class_name: names of the classes of the images to be
          collected.
      :returns img_paths: list of strings (paths)


   .. method:: get_test_images_paths(self, class_name)

      Gets the test set image paths

      :param class_name: names of the classes of the images to be
          collected.
      :returns img_paths: list of strings (paths)


   .. method:: __len__(self)

      Returns the lenght of the set 


   .. method:: __getitem__(self, index)

      Returns the index-th x, y pattern of the set 



.. function:: NCBenchmark(train_dataset: Union[Sequence[IDatasetWithTargets], IDatasetWithTargets], test_dataset: Union[Sequence[IDatasetWithTargets], IDatasetWithTargets], n_steps: int, task_labels: bool, *, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Sequence[int] = None, per_step_classes: Dict[int, int] = None, class_ids_from_zero_from_first_step: bool = False, class_ids_from_zero_in_each_step: bool = False, one_dataset_per_step: bool = False, reproducibility_data: Dict[str, Any] = None) -> NCScenario

   This method is the high-level specific scenario generator for the
   "New Classes" (NC) case. Given a sequence of train and test datasets creates
   the continual stream of data as a series of steps. Each step will contain
   all the patterns belonging to a certain set of classes and a class won't be
   assigned to more than one step.

   The ``task_labels`` parameter determines if each incremental step has
   an increasing task label or if, at the contrary, a default task label "0"
   has to be assigned to all steps. This can be useful when differentiating
   between Single-Incremental-Task and Multi-Task scenarios.

   There are other important parameters that can be specified in order to tweak
   the behaviour of the resulting scenario. Please take a few minutes to read
   and understand them as they may save you a lot of work.

   This generator features an integrated reproducibility mechanism that allows
   the user to store and later re-load a scenario. For more info see the
   ``reproducibility_data`` parameter.

   :param train_dataset: A list of training datasets, or a single dataset.
   :param test_dataset: A list of test datasets, or a single test dataset.
   :param n_steps: The number of incremental steps. This is not used when
       using multiple train/test datasets with the ``one_dataset_per_step``
       parameter set to True.
   :param task_labels: If True, each step will have an ascending task
           label. If False, the task label will be 0 for all the steps.
   :param shuffle: If True, the class (or step) order will be shuffled.
       Defaults to True.
   :param seed: If ``shuffle`` is True and seed is not None, the class (or
       step) order will be shuffled according to the seed. When None, the
       current PyTorch random number generator state will be used. Defaults to
       None.
   :param fixed_class_order: If not None, the class order to use (overrides
       the shuffle argument). Very useful for enhancing reproducibility.
       Defaults to None.
   :param per_step_classes: Is not None, a dictionary whose keys are
       (0-indexed) step IDs and their values are the number of classes
       to include in the respective steps. The dictionary doesn't
       have to contain a key for each step! All the remaining steps
       will contain an equal amount of the remaining classes. The
       remaining number of classes must be divisible without remainder
       by the remaining number of steps. For instance,
       if you want to include 50 classes in the first step
       while equally distributing remaining classes across remaining
       steps, just pass the "{0: 50}" dictionary as the
       per_step_classes parameter. Defaults to None.
   :param class_ids_from_zero_from_first_step: If True, original class IDs
       will be remapped so that they will appear as having an ascending
       order. For instance, if the resulting class order after shuffling
       (or defined by fixed_class_order) is [23, 34, 11, 7, 6, ...] and
       class_ids_from_zero_from_first_step is True, then all the patterns
       belonging to class 23 will appear as belonging to class "0",
       class "34" will be mapped to "1", class "11" to "2" and so on.
       This is very useful when drawing confusion matrices and when dealing
       with algorithms with dynamic head expansion. Defaults to False.
       Mutually exclusive with the ``class_ids_from_zero_in_each_step``
       parameter.
   :param class_ids_from_zero_in_each_step: If True, original class IDs
       will be mapped to range [0, n_classes_in_step) for each step.
       Defaults to False. Mutually exclusive with the
       ``class_ids_from_zero_from_first_step`` parameter.
   :param one_dataset_per_step: available only when multiple train-test
       datasets are provided. If True, each dataset will be treated as a step.
       Mutually exclusive with the ``per_step_classes`` and
       ``fixed_class_order`` parameters. Overrides the ``n_steps`` parameter.
       Defaults to False.
   :param reproducibility_data: If not None, overrides all the other
       scenario definition options. This is usually a dictionary containing
       data used to reproduce a specific experiment. One can use the
       ``get_reproducibility_data`` method to get (and even distribute)
       the experiment setup so that it can be loaded by passing it as this
       parameter. In this way one can be sure that the same specific
       experimental setup is being used (for reproducibility purposes).
       Beware that, in order to reproduce an experiment, the same train and
       test datasets must be used. Defaults to None.

   :return: A :class:`NCMultiTaskScenario` or :class:`NCSingleTaskScenario`
       instance initialized for the the SIT or MT scenario.


.. data:: _default_train_transform
   

   

.. data:: _default_test_transform
   

   

.. function:: SplitTinyImageNet(incremental_steps=10, return_task_id=False, seed=0, fixed_class_order=None, train_transform=_default_train_transform, test_transform=_default_test_transform)

   Creates a CL scenario using the Tiny ImageNet dataset.
   If the dataset is not present in the computer the method automatically
   download it and store the data in the data folder.

   :param incremental_steps: The number of incremental steps in the current
       scenario.
   :param return_task_id: if True, for every step the task id is returned and
       the Scenario is Multi Task. This means that the scenario returned
       will be of type ``NCMultiTaskScenario``. If false the task index is
       not returned (default to 0 for every batch) and the returned scenario
       is of type ``NCSingleTaskScenario``.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param fixed_class_order: A list of class IDs used to define the class
       order. If None, value of ``seed`` will be used to define the class
       order. If non-None, ``seed`` parameter will be ignored.
       Defaults to None.
   :param train_transform: The transformation to apply to the training data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCMultiTaskScenario` instance initialized for the the
       MT scenario using CIFAR10 if the parameter ``return_task_id`` is True,
       a :class:`NCSingleTaskScenario` initialized for the SIT scenario using
       CIFAR10 otherwise.
       


.. data:: _default_cifar10_train_transform
   

   

.. data:: _default_cifar10_test_transform
   

   

.. function:: SplitCIFAR10(incremental_steps: int, first_batch_with_half_classes: bool = False, return_task_id=False, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_cifar10_train_transform, test_transform=_default_cifar10_test_transform)

   Creates a CL scenario using the CIFAR10 dataset.
   If the dataset is not present in the computer the method automatically
   download it and store the data in the data folder.

   :param incremental_steps: The number of incremental steps in the current
       scenario. If the first step is a "pretrain" step and it contains
       half of the classes, the number of incremental steps is the number of
       tasks performed after the pretraining task.
       The value of this parameter should be a divisor of 10 if
       first_task_with_half_classes if false, a divisor of 5 otherwise.
   :param first_batch_with_half_classes: A boolean value that indicates if a
       first pretraining batch containing half of the classes should be used.
       If it's True, a pretrain batch with half of the classes (5 for
       cifar100) is used, and a number of incremental tasks, given by the
       parameter incremental_task is constructed. If this paramenter is False
       no pretraining task will be used, and the dataset is simply split into
       a the number of steps defined by the parameter incremental_steps.
       Default to False.
   :param return_task_id: if True, for every step the task id is returned and
       the Scenario is Multi Task. This means that the scenario returned
       will be of type ``NCMultiTaskScenario``. If false the task index is
       not returned (default to 0 for every batch) and the returned scenario
       is of type ``NCSingleTaskScenario``.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param fixed_class_order: A list of class IDs used to define the class
       order. If None, value of ``seed`` will be used to define the class
       order. If non-None, ``seed`` parameter will be ignored.
       Defaults to None.
   :param train_transform: The transformation to apply to the training data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCMultiTaskScenario` instance initialized for the the
       MT scenario using CIFAR10 if the parameter ``return_task_id`` is True,
       a :class:`NCSingleTaskScenario` initialized for the SIT scenario using
       CIFAR10 otherwise.


.. function:: _get_cifar10_dataset(train_transformation, test_transformation)


.. function:: concat_datasets_sequentially(train_dataset_list: Sequence[IDatasetWithTargets], test_dataset_list: Sequence[IDatasetWithTargets])

   Concatenates a list of datasets. This is completely different from
   :class:`ConcatDataset`, in which datasets are merged together without
   other processing. Instead, this function re-maps the datasets class IDs.
   For instance:
   let the dataset[0] contain patterns of 3 different classes,
   let the dataset[1] contain patterns of 2 different classes, then class IDs
   will be mapped as follows:

   dataset[0] class "0" -> new class ID is "0"

   dataset[0] class "1" -> new class ID is "1"

   dataset[0] class "2" -> new class ID is "2"

   dataset[1] class "0" -> new class ID is "3"

   dataset[1] class "1" -> new classID is "4"

   ... -> ...

   dataset[N-1] class "C-1" -> new class ID is "overall_n_classes-1"

   In contract, using PyTorch ConcatDataset:

   dataset[0] class "0" -> ID is "0"

   dataset[0] class "1" -> ID is "1"

   dataset[0] class "2" -> ID is "2"

   dataset[1] class "0" -> ID is "0"

   dataset[1] class "1" -> ID is "1"

   Note: ``train_dataset_list`` and ``test_dataset_list`` must have the same
   number of datasets.

   :param train_dataset_list: A list of training datasets
   :param test_dataset_list: A list of test datasets

   :returns: A concatenated dataset.


.. data:: _default_cifar100_train_transform
   

   

.. data:: _default_cifar100_test_transform
   

   

.. function:: SplitCIFAR100(incremental_steps: int, first_batch_with_half_classes: bool = False, return_task_id=False, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_cifar100_train_transform, test_transform=_default_cifar100_test_transform)

   Creates a CL scenario using the CIFAR100 dataset.
   If the dataset is not present in the computer the method automatically
   download it and store the data in the data folder.

   :param incremental_steps: The number of incremental steps in the current
       scenario. If the first step is a "pretrain" step and it contains
       half of the classes, the number of incremental steps is the number of
       tasks performed after the pretraining task.
       The value of this parameter should be a divisor of 100 if
       first_task_with_half_classes if false, a divisor of 50 otherwise.
   :param first_batch_with_half_classes: A boolean value that indicates if a
       first pretraining batch containing half of the classes should be used.
       If it's True, a pretrain batch with half of the classes (50 for
       cifar100) is used, and a number of incremental tasks, given by the
       parameter incremental_task is constructed. If this paramenter is False
       no pretraining task will be used, and the dataset is simply split into
       a the number of steps defined by the parameter incremental_steps.
       Default to False.
   :param return_task_id: if True, for every step the task id is returned and
       the Scenario is Multi Task. This means that the scenario returned
       will be of type ``NCMultiTaskScenario``. If false the task index is
       not returned (default to 0 for every batch) and the returned scenario
       is of type ``NCSingleTaskScenario``.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param fixed_class_order: A list of class IDs used to define the class
       order. If None, value of ``seed`` will be used to define the class
       order. If non-None, ``seed`` parameter will be ignored.
       Defaults to None.
   :param train_transform: The transformation to apply to the training data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCMultiTaskScenario` instance initialized for the the
       MT scenario using CIFAR100 if the parameter ``return_task_id`` is True,
       a :class:`NCSingleTaskScenario` initialized for the SIT scenario using
       CIFAR100 otherwise.


.. function:: SplitCIFAR110(incremental_steps: int, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_cifar100_train_transform, test_transform=_default_cifar100_test_transform) -> NCScenario

   Creates a Single Incremental Task (SIT) scenario using the CIFAR100 dataset,
   with a pretrain first batch using CIFAR10.
   If the datasets are not present in the computer the method automatically
   download them and store the data in the data folder.

   :param incremental_steps: The number of incremental steps for the
       incremental training on cifar100. The first "pretrain" batch using
       cifar10 is not included in this number of incremental steps.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param fixed_class_order: A list of class IDs used to define the class
       order ONLY for the incremental part on cifar100. The classes must be in
       range 0-99.
       If None, value of ``seed`` will be used to define the class
       order for the incremental batches on cifar100.
       If non-None, ``seed`` parameter will be ignored.
       Defaults to None.
   :param train_transform: The transformation to apply to the training data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCSingleTaskScenario` instance initialized for the the
       SIT scenario using CIFAR10 as a pretrain batch zero and CIFAR100 for the
       incremental training.  


.. function:: _get_cifar100_dataset(train_transformation, test_transformation)


.. data:: _default_mnist_train_transform
   

   

.. data:: _default_mnist_test_transform
   

   

.. function:: SplitMNIST(incremental_steps: int, return_task_id=False, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_mnist_train_transform, test_transform=_default_mnist_test_transform)

   Creates a CL scenario using the MNIST dataset.
   This helper create the basic split MNIST scenario, where the 10 classes of
   the MNIST dataset are evenly splitted into the given nuber of tasks.
   If the dataset is not present in the computer the method automatically
   download it and store the data in the data folder.

   :param incremental_steps: The number of incremental steps in the current
       scenario.
       The value of this parameter should be a divisor of 10.
   :param return_task_id: if True, for every step the task id is returned and
       the Scenario is Multi Task. This means that the scenario returned
       will be of type ``NCMultiTaskScenario``. If false the task index is
       not returned (default to 0 for every batch) and the returned scenario
       is of type ``NCSingleTaskScenario``.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param fixed_class_order: A list of class IDs used to define the class
       order. If None, value of ``seed`` will be used to define the class
       order. If non-None, ``seed`` parameter will be ignored.
       Defaults to None.
   :param train_transform: The transformation to apply to the training data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCMultiTaskScenario` instance initialized for the the
       MT split MNIST scenario if the parameter ``return_task_id`` is True,
       a :class:`NCSingleTaskScenario` initialized for the SIT split MNIST
       scenario otherwise.


.. function:: PermutedMNIST(incremental_steps: int, seed: Optional[int] = None, train_transform=_default_mnist_train_transform, test_transform=_default_mnist_test_transform) -> NCScenario

   This helper create a permuted MNIST scenario: where a given number of random
   pixel permutations is used to permute the MNIST images in
   ``incremental_steps`` different manners, creating an equal number of tasks.
   Each task is composed of all the original MNIST 10 classes, but the pixel
   in the images are permuted in different ways in every task.
   If the dataset is not present in the computer the method automatically
   download it and store the data in the data folder.

   :param incremental_steps: The number of incremental tasks in the current
       scenario. It indicates how many different permutations of the MNIST
       dataset have to be created.
       The value of this parameter should be a divisor of 10.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param train_transform: The transformation to apply to the training data
       before the random permutation, e.g. a random crop, a normalization or a
       concatenation of different transformations (see torchvision.transform
       documentation for a comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data
       before the random permutation, e.g. a random crop, a normalization or a
       concatenation of different transformations (see torchvision.transform
       documentation for a comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCMultiTaskScenario` instance initialized for the the
       MT permuted MNIST scenario.


.. function:: RotatedMNIST(incremental_steps: int, seed: Optional[int] = None, rotations_list: Optional[Sequence[int]] = None, train_transform=_default_mnist_train_transform, test_transform=_default_mnist_test_transform) -> NCScenario

   This helper create a rotated MNIST scenario: where a given number of random
   rotations are used to rotate the MNIST images in
   ``incremental_steps`` different manners, creating an equal number of tasks.
   Each task is composed of all the original MNIST 10 classes, but the images
   are rotated in different ways and using different values in every task.
   If the dataset is not present in the computer the method automatically
   download it and store the data in the data folder.

   :param incremental_steps: The number of incremental tasks in the current
       scenario. It indicates how many different rotations of the MNIST
       dataset have to be created.
       The value of this parameter should be a divisor of 10.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param rotations_list: A list of rotations values in degrees (from -180 to
       180) used to define the rotations. The rotation specified in position
       0 of the list will be applieed to the task 0, the rotation specified in
       position 1 will be applyed to task 1 and so on.
       If None, value of ``seed`` will be used to define the rotations.
       If non-None, ``seed`` parameter will be ignored.
       Defaults to None.
   :param train_transform: The transformation to apply to the training data
       after the random rotation, e.g. a random crop, a normalization or a
       concatenation of different transformations (see torchvision.transform
       documentation for a comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data
       after the random rotation, e.g. a random crop, a normalization or a
       concatenation of different transformations (see torchvision.transform
       documentation for a comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCMultiTaskScenario` instance initialized for the the
       MT rotated MNIST scenario.


.. function:: _get_mnist_dataset(train_transformation, test_transformation)


.. function:: SplitFMNIST(incremental_steps: int, first_batch_with_half_classes: bool = False, return_task_id=False, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_cifar10_train_transform, test_transform=_default_cifar10_test_transform)

   Creates a CL scenario using the Fashion MNIST dataset.
   If the dataset is not present in the computer the method automatically
   download it and store the data in the data folder.

   :param incremental_steps: The number of incremental steps in the current
       scenario. If the first step is a "pretrain" step and it contains
       half of the classes, the number of incremental steps is the number of
       tasks performed after the pretraining task.
       The value of this parameter should be a divisor of 10 if
       first_task_with_half_classes if false, a divisor of 5 otherwise.
   :param first_batch_with_half_classes: A boolean value that indicates if a
       first pretraining batch containing half of the classes should be used.
       If it's True, a pretrain batch with half of the classes (5 for
       cifar100) is used, and a number of incremental tasks, given by the
       parameter incremental_task is constructed. If this paramenter is False
       no pretraining task will be used, and the dataset is simply split into
       a the number of steps defined by the parameter incremental_steps.
       Default to False.
   :param return_task_id: if True, for every step the task id is returned and
       the Scenario is Multi Task. This means that the scenario returned
       will be of type ``NCMultiTaskScenario``. If false the task index is
       not returned (default to 0 for every batch) and the returned scenario
       is of type ``NCSingleTaskScenario``.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param fixed_class_order: A list of class IDs used to define the class
       order. If None, value of ``seed`` will be used to define the class
       order. If non-None, ``seed`` parameter will be ignored.
       Defaults to None.
   :param train_transform: The transformation to apply to the training data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCMultiTaskScenario` instance initialized for the the
       MT scenario using CIFAR10 if the parameter ``return_task_id`` is True,
       a :class:`NCSingleTaskScenario` initialized for the SIT scenario using
       CIFAR10 otherwise.


.. function:: _get_fmnist_dataset(train_transformation, test_transformation)


.. data:: nc_scenario
   

   

.. function:: ImageNet(*args, **kwargs)


.. data:: normalize
   

   

.. function:: SplitImageNet(root, incremental_steps=10, classes_first_batch=None, return_task_id=False, seed=0, fixed_class_order=None, train_transform=_default_train_transform, test_transform=_default_test_transform)

   Creates a CL scenario using the Tiny ImageNet dataset.
   If the dataset is not present in the computer the method automatically
   download it and store the data in the data folder.

   :param root: Base path where Imagenet data are stored.
   :param incremental_steps: The number of incremental steps in the current
       scenario.
   :param classes_first_batch: Number of classes in the first batch.
   Usually this is set to 500. Default to None.
   :param return_task_id: if True, for every step the task id is returned and
       the Scenario is Multi Task. This means that the scenario returned
       will be of type ``NCMultiTaskScenario``. If false the task index is
       not returned (default to 0 for every batch) and the returned scenario
       is of type ``NCSingleTaskScenario``.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param fixed_class_order: A list of class IDs used to define the class
       order. If None, value of ``seed`` will be used to define the class
       order. If non-None, ``seed`` parameter will be ignored.
       Defaults to None.
   :param train_transform: The transformation to apply to the training data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCMultiTaskScenario` instance initialized for the the
       MT scenario using CIFAR10 if the parameter ``return_task_id`` is True,
       a :class:`NCSingleTaskScenario` initialized for the SIT scenario using
       CIFAR10 otherwise.
       


.. data:: scenario
   

   

.. py:class:: CUB200(root, train=True, transform=None, loader=default_loader, download=False)

   Bases: :class:`torch.utils.data.Dataset`

   An abstract class representing a :class:`Dataset`.

   All datasets that represent a map from keys to data samples should subclass
   it. All subclasses should overwrite :meth:`__getitem__`, supporting fetching a
   data sample for a given key. Subclasses could also optionally overwrite
   :meth:`__len__`, which is expected to return the size of the dataset by many
   :class:`~torch.utils.data.Sampler` implementations and the default options
   of :class:`~torch.utils.data.DataLoader`.

   .. note::
     :class:`~torch.utils.data.DataLoader` by default constructs a index
     sampler that yields integral indices.  To make it work with a map-style
     dataset with non-integral indices/keys, a custom sampler must be provided.

   Initialize self.  See help(type(self)) for accurate signature.

   .. attribute:: filename
      :annotation: = images.tgz

      

   .. attribute:: metadata
      :annotation: = lists.tgz

      

   .. attribute:: basefolder
      :annotation: = images

      

   .. attribute:: tgz_md5
      :annotation: = 2bbe304ef1aa3ddb6094aa8f53487cf2

      

   .. method:: _load_metadata(self)


   .. method:: _check_integrity(self)


   .. method:: __len__(self)


   .. method:: __getitem__(self, idx)



.. function:: SplitCUB200(root, incremental_steps=11, classes_first_batch=100, return_task_id=False, seed=0, fixed_class_order=None, shuffle=False, train_transform=_default_train_transform, test_transform=_default_test_transform)

   Creates a CL scenario using the Tiny ImageNet dataset.
   If the dataset is not present in the computer the method automatically
   download it and store the data in the data folder.

   :param root: Base path where Imagenet data are stored.
   :param incremental_steps: The number of incremental steps in the current
       scenario.
   :param classes_first_batch: Number of classes in the first batch.
   Usually this is set to 500. Default to None.
   :param return_task_id: if True, for every step the task id is returned and
       the Scenario is Multi Task. This means that the scenario returned
       will be of type ``NCMultiTaskScenario``. If false the task index is
       not returned (default to 0 for every batch) and the returned scenario
       is of type ``NCSingleTaskScenario``.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param fixed_class_order: A list of class IDs used to define the class
       order. If None, value of ``seed`` will be used to define the class
       order. If non-None, ``seed`` parameter will be ignored.
       Defaults to None.
   :param shuffle: If true, the class order in the incremental steps is
       randomly shuffled. Default to false.
   :param train_transform: The transformation to apply to the training data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCMultiTaskScenario` instance initialized for the the
       MT scenario using CIFAR10 if the parameter ``return_task_id`` is True,
       a :class:`NCSingleTaskScenario` initialized for the SIT scenario using
       CIFAR10 otherwise.
       


