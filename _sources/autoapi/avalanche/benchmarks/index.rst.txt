:mod:`avalanche.benchmarks`
===========================

.. py:module:: avalanche.benchmarks


Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   classic/index.rst
   datasets/index.rst
   generators/index.rst
   scenarios/index.rst


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   utils/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   avalanche.benchmarks.TinyImagenet
   avalanche.benchmarks.NCGenericScenario
   avalanche.benchmarks.NCSingleTaskScenario
   avalanche.benchmarks.NCMultiTaskScenario
   avalanche.benchmarks.CUB200



Functions
~~~~~~~~~

.. autoapisummary::

   avalanche.benchmarks.CORe50
   avalanche.benchmarks.create_nc_single_dataset_sit_scenario
   avalanche.benchmarks.create_nc_single_dataset_multi_task_scenario
   avalanche.benchmarks.SplitTinyImageNet
   avalanche.benchmarks.SplitCIFAR10
   avalanche.benchmarks._get_cifar10_dataset
   avalanche.benchmarks.concat_datasets_sequentially
   avalanche.benchmarks.SplitCIFAR100
   avalanche.benchmarks.SplitCIFAR110
   avalanche.benchmarks._get_cifar100_dataset
   avalanche.benchmarks.create_nc_multi_dataset_multi_task_scenario
   avalanche.benchmarks.SplitMNIST
   avalanche.benchmarks.PermutedMNIST
   avalanche.benchmarks.RotatedMNIST
   avalanche.benchmarks._get_mnist_dataset
   avalanche.benchmarks.SplitFMNIST
   avalanche.benchmarks._get_fmnist_dataset
   avalanche.benchmarks.ImageNet
   avalanche.benchmarks.NCScenario
   avalanche.benchmarks.SplitImageNet
   avalanche.benchmarks.SplitCUB200


.. function:: CORe50(root=expanduser('~') + '/.avalanche/data/core50/', scenario='nicv2_391', run=0)

   CORe50 continual scenario generator

   :param root: Path indicating where to store the dataset and related
       metadata. By default they will be stored in
       avalanche/datasets/core50/data/.
   :param scenario: CORe50 main scanario. I can be chosen between 'ni', 'nc',
       'nic', 'nicv2_79', 'nicv2_196' or 'nicv2_391.'
   :param run: number of run for the scenario. Batch ordering change based
       on this parameter (a number between 0 and 9).

   :returns: it returns a :class:`GenericCLScenario` instance that can be
       iterated.


.. py:class:: TinyImagenet(data_folder=expanduser('~') + '/.avalanche/data/tinyimagenet/', train=True, transform=ToTensor(), target_transform=None, download=True)

   Bases: :class:`torch.utils.data.Dataset`

   Tiny Imagenet Pytorch Dataset

   Args:
       :param string data_folder: folder in which to download dataset
       :param boolean train: True for train set, False for test set
       :param fun transform: Pytorch transformation founction for x
       :param fun target_transform: Pytorch transformation founction for y
       :param bool download: True for downloading the dataset

   .. method:: download_tinyImageNet(self)

      Downloads the TintImagenet Dataset 


   .. method:: labels2dict(self)

      Returns dictionaries to convert class names into progressive ids
      and viceversa.
      :returns: label2id, id2label: two Python dictionaries.


   .. method:: load_data(self, train=True)

      Load all images paths and targets.

      :param bool train: True for loading the training set, False for the
          test set.
      :return: train_set, test_set: (train_X_paths, train_y).


   .. method:: get_train_images_paths(self, class_name)

      Gets the training set image paths

      :param class_name: names of the classes of the images to be
          collected.
      :returns img_paths: list of strings (paths)


   .. method:: get_test_images_paths(self, class_name)

      Gets the test set image paths

      :param class_name: names of the classes of the images to be
          collected.
      :returns img_paths: list of strings (paths)


   .. method:: __len__(self)

      Returns the lenght of the set 


   .. method:: __getitem__(self, index)

      Returns the index-th x, y pattern of the set 



.. function:: create_nc_single_dataset_sit_scenario(train_dataset: IDatasetWithTargets, test_dataset: IDatasetWithTargets, n_batches: int, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, per_batch_classes: Optional[Dict[int, int]] = None, remap_class_ids: bool = False, reproducibility_data: Optional[Dict[str, Any]] = None) -> NCSingleTaskScenario

   Creates a "New Classes - Single Incremental Task" scenario given a couple
   of train and test datasets.

   :param train_dataset: The training dataset.
   :param test_dataset: A list of test dataset.
   :param n_batches: The number of batches.
   :param shuffle: If True, class order will be shuffled.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param fixed_class_order: A list of class IDs used to define the class
       order. If None, values of ``shuffle`` and ``seed`` will be used to
       define the class order. If non-None, ``shuffle`` and ``seed`` parameters
       will be ignored. Defaults to None.
   :param per_batch_classes: Is not None, a dictionary whose keys are
       (0-indexed) batch IDs and their values are the number of classes
       to include in the respective batches. The dictionary doesn't
       have to contain a key for each batch! All the remaining batches
       will contain an equal amount of the remaining classes. The
       remaining number of classes must be divisible without remainder
       by the remaining number of batches. For instance,
       if you want to include 50 classes in the first batch while equally
       distributing remaining classes across remaining batches,
       just pass the "{0: 50}" dictionary as the ``per_batch_classes``
       parameter. Defaults to None.
   :param remap_class_ids: If True, original class IDs will be
       remapped so that they will appear as having an ascending order.
       For instance, if the resulting class order after shuffling
       (or defined by fixed_class_order) is [23, 34, 11, 7, 6, ...] and
       remap_class_indexes is True, then all the patterns belonging to
       class 23 will appear as belonging to class "0", class "34" will
       be mapped to "1", class "11" to "2" and so on. This is very
       useful when drawing confusion matrices and when dealing with
       algorithms with dynamic head expansion. Defaults to False.
   :param reproducibility_data: If not None, overrides all the other
       scenario definition options. This is usually a dictionary containing
       data used to reproduce a specific experiment. One can use the
       ``get_reproducibility_data`` method to get (and even distribute)
       the experiment setup so that it can be loaded by passing it as this
       parameter. In this way one can be sure that the same specific
       experimental setup is being used (for reproducibility purposes).
       Beware that, in order to reproduce an experiment, the same train and
       test datasets must be used. Defaults to None.

   :returns: A :class:`NCMultiTaskScenario` instance initialized for the the
       SIT scenario.


.. function:: create_nc_single_dataset_multi_task_scenario(train_dataset: IDatasetWithTargets, test_dataset: IDatasetWithTargets, n_tasks: int, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, per_task_classes: Optional[Dict[int, int]] = None, classes_ids_from_zero_in_each_task: bool = True, reproducibility_data: Optional[Dict[str, Any]] = None) -> NCMultiTaskScenario

   Creates a "New Classes - Multi Task" scenario given a couple
   of train and test datasets.

   :param train_dataset: The training dataset.
   :param test_dataset: A list of test dataset.
   :param n_tasks: The number of batches.
   :param shuffle: If True, class order will be shuffled.
   :param seed: A valid int used to initialize the random number generator. Can
       be None.
   :param fixed_class_order: A list of class IDs used to define the class
       order. If None, values of shuffle and seed will be used to define the
       class order. If non-None, shuffle and seed parameters will be ignored.
       Defaults to None.
   :param per_task_classes: Is not None, a dictionary whose keys are
       (0-indexed) task IDs and their values are the number of classes
       to include in the respective batches. The dictionary doesn't
       have to contain a key for each task! All the remaining batches
       will contain an equal amount of the remaining classes. The
       remaining number of classes must be divisible without remainder
       by the remaining number of batches. For instance,
       if you want to include 50 classes in the first task while equally
       distributing remaining classes across remaining batches,
       just pass the "{0: 50}" dictionary as the per_task_classes
       parameter. Defaults to None.
   :param classes_ids_from_zero_in_each_task: If True, original class IDs will
       be mapped to range [0, n_classes_in_task) for each task. If False,
       each class will keep its original ID as defined in the input
       datasets. Defaults to True.
   :param reproducibility_data: If not None, overrides all the other
       scenario definition options. This is usually a dictionary containing
       data used to reproduce a specific experiment. One can use the
       ``get_reproducibility_data`` method to get (and even distribute)
       the experiment setup so that it can be loaded by passing it as this
       parameter. In this way one can be sure that the same specific
       experimental setup is being used (for reproducibility purposes).
       Beware that, in order to reproduce an experiment, the same train and
       test datasets must be used. Defaults to None.

   :returns: A :class:`NCMultiTaskScenario` instance.


.. data:: _default_train_transform
   

   

.. data:: _default_test_transform
   

   

.. function:: SplitTinyImageNet(incremental_steps=10, return_task_id=False, seed=0, fixed_class_order=None, train_transform=_default_train_transform, test_transform=_default_test_transform)

   Creates a CL scenario using the Tiny ImageNet dataset.
   If the dataset is not present in the computer the method automatically
   download it and store the data in the data folder.

   :param incremental_steps: The number of incremental steps in the current
       scenario.
   :param return_task_id: if True, for every step the task id is returned and
       the Scenario is Multi Task. This means that the scenario returned
       will be of type ``NCMultiTaskScenario``. If false the task index is
       not returned (default to 0 for every batch) and the returned scenario
       is of type ``NCSingleTaskScenario``.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param fixed_class_order: A list of class IDs used to define the class
       order. If None, value of ``seed`` will be used to define the class
       order. If non-None, ``seed`` parameter will be ignored.
       Defaults to None.
   :param train_transform: The transformation to apply to the training data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCMultiTaskScenario` instance initialized for the the
       MT scenario using CIFAR10 if the parameter ``return_task_id`` is True,
       a :class:`NCSingleTaskScenario` initialized for the SIT scenario using
       CIFAR10 otherwise.
       


.. data:: _default_cifar10_train_transform
   

   

.. data:: _default_cifar10_test_transform
   

   

.. function:: SplitCIFAR10(incremental_steps: int, first_batch_with_half_classes: bool = False, return_task_id=False, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_cifar10_train_transform, test_transform=_default_cifar10_test_transform)

   Creates a CL scenario using the CIFAR10 dataset.
   If the dataset is not present in the computer the method automatically
   download it and store the data in the data folder.

   :param incremental_steps: The number of incremental steps in the current
       scenario. If the first step is a "pretrain" step and it contains
       half of the classes, the number of incremental steps is the number of
       tasks performed after the pretraining task.
       The value of this parameter should be a divisor of 10 if
       first_task_with_half_classes if false, a divisor of 5 otherwise.
   :param first_batch_with_half_classes: A boolean value that indicates if a
       first pretraining batch containing half of the classes should be used.
       If it's True, a pretrain batch with half of the classes (5 for
       cifar100) is used, and a number of incremental tasks, given by the
       parameter incremental_task is constructed. If this paramenter is False
       no pretraining task will be used, and the dataset is simply split into
       a the number of steps defined by the parameter incremental_steps.
       Default to False.
   :param return_task_id: if True, for every step the task id is returned and
       the Scenario is Multi Task. This means that the scenario returned
       will be of type ``NCMultiTaskScenario``. If false the task index is
       not returned (default to 0 for every batch) and the returned scenario
       is of type ``NCSingleTaskScenario``.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param fixed_class_order: A list of class IDs used to define the class
       order. If None, value of ``seed`` will be used to define the class
       order. If non-None, ``seed`` parameter will be ignored.
       Defaults to None.
   :param train_transform: The transformation to apply to the training data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCMultiTaskScenario` instance initialized for the the
       MT scenario using CIFAR10 if the parameter ``return_task_id`` is True,
       a :class:`NCSingleTaskScenario` initialized for the SIT scenario using
       CIFAR10 otherwise.


.. function:: _get_cifar10_dataset(train_transformation, test_transformation)


.. py:class:: NCGenericScenario(train_dataset: TrainSetWithTargets, test_dataset: TestSetWithTargets, n_batches: int, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, per_batch_classes: Optional[Dict[int, int]] = None, remap_class_indexes: bool = False, reproducibility_data: Optional[Dict[str, Any]] = None)

   Bases: :class:`Generic[TrainSetWithTargets, TestSetWithTargets]`

   This class defines a "New Classes" scenario. It is used when creating both
   task-oriented and single-incremental-batches (a.k.a. task-free) as
   it doesn't make any difference between them. Once created, an instance
   of this class can be iterated in order to obtain the batches/batch sequence
   under the form of instances of :class:`NCGenericBatchInfo`.

   This class can be used directly. However, we recommend using facilities like
   :func:`.scenario_creation.create_nc_single_dataset_sit_scenario`,
   :func:`.scenario_creation.create_nc_single_dataset_multi_task_scenario`,
   :func:`.scenario_creation.create_nc_multi_dataset_sit_scenario` and
   :func:`.scenario_creation.create_nc_multi_dataset_multi_task_scenario`.

   Creates a NCGenericScenario instance given the training and test
   Datasets and the number of batches.

   By default, the number of classes will be automatically detected by
   looking at the training Dataset targets field. Classes will be
   uniformly distributed across the "n_batches" unless a per_task_classes
   argument is specified.

   The number of classes must be divisible without remainder by the number
   of batches. This also applies when the per_task_classes argument is not
   None.

   :param train_dataset: The training dataset. The dataset must contain a
       "targets" field. For instance, one can safely use the datasets from
       the torchvision package.
   :param test_dataset: The test dataset. The dataset must contain a
       "targets" field. For instance, one can safely use the datasets from
       the torchvision package.
   :param n_batches: The number of batches.
   :param shuffle: If True, the class order will be shuffled. Defaults to
       True.
   :param seed: If shuffle is True and seed is not None, the class order
       will be shuffled according to the seed. When None, the current
       PyTorch random number generator state will be used.
       Defaults to None.
   :param fixed_class_order: If not None, the class order to use (overrides
       the shuffle argument). Very useful for enhancing
       reproducibility. Defaults to None.
   :param per_batch_classes: Is not None, a dictionary whose keys are
       (0-indexed) batch IDs and their values are the number of classes
       to include in the respective batches. The dictionary doesn't
       have to contain a key for each batch! All the remaining batches
       will contain an equal amount of the remaining classes. The
       remaining number of classes must be divisible without remainder
       by the remaining number of batches. For instance,
       if you want to include 50 classes in the first batch
       while equally distributing remaining classes across remaining
       batches, just pass the "{0: 50}" dictionary as the
       per_batch_classes parameter. Defaults to None.
   :param remap_class_indexes: If True, original class IDs will be
       remapped so that they will appear as having an ascending order.
       For instance, if the resulting class order after shuffling
       (or defined by fixed_class_order) is [23, 34, 11, 7, 6, ...] and
       remap_class_indexes is True, then all the patterns belonging to
       class 23 will appear as belonging to class "0", class "34" will
       be mapped to "1", class "11" to "2" and so on. This is very
       useful when drawing confusion matrices and when dealing with
       algorithms with dynamic head expansion. Defaults to False.
   :param reproducibility_data: If not None, overrides all the other
       scenario definition options. This is usually a dictionary containing
       data used to reproduce a specific experiment. One can use the
       ``get_reproducibility_data`` method to get (and even distribute)
       the experiment setup so that it can be loaded by passing it as this
       parameter. In this way one can be sure that the same specific
       experimental setup is being used (for reproducibility purposes).
       Beware that, in order to reproduce an experiment, the same train and
       test datasets must be used. Defaults to None.

   .. method:: get_reproducibility_data(self)


   .. method:: classes_in_batch_range(self, batch_start: int, batch_end: Optional[int] = None) -> List[int]

      Gets a list of classes contained int the given batches. The batches are
      defined by range. This means that only the classes in range
      [batch_start, batch_end) will be included.

      :param batch_start: The starting batch ID
      :param batch_end: The final batch ID. Can be None, which means that all
          the remaining batches will be taken.

      :returns: The classes contained in the required batch range.


   .. method:: get_class_split(self, batch_id: int)



.. function:: concat_datasets_sequentially(train_dataset_list: Sequence[IDatasetWithTargets], test_dataset_list: Sequence[IDatasetWithTargets])

   Concatenates a list of datasets. This is completely different from
   :class:`ConcatDataset`, in which datasets are merged together without
   other processing. Instead, this function re-maps the datasets class IDs.
   For instance:
   let the dataset[0] contain patterns of 3 different classes,
   let the dataset[1] contain patterns of 2 different classes, then class IDs
   will be mapped as follows:

   dataset[0] class "0" -> new class ID is "0"

   dataset[0] class "1" -> new class ID is "1"

   dataset[0] class "2" -> new class ID is "2"

   dataset[1] class "0" -> new class ID is "3"

   dataset[1] class "1" -> new classID is "4"

   ... -> ...

   dataset[N-1] class "C-1" -> new class ID is "overall_n_classes-1"

   In contract, using PyTorch ConcatDataset:

   dataset[0] class "0" -> ID is "0"

   dataset[0] class "1" -> ID is "1"

   dataset[0] class "2" -> ID is "2"

   dataset[1] class "0" -> ID is "0"

   dataset[1] class "1" -> ID is "1"

   Note: ``train_dataset_list`` and ``test_dataset_list`` must have the same
   number of datasets.

   :param train_dataset_list: A list of training datasets
   :param test_dataset_list: A list of test datasets

   :returns: A concatenated dataset.


.. py:class:: NCSingleTaskScenario(nc_generic_scenario: NCGenericScenario[TrainSetWithTargets, TestSetWithTargets])

   Bases: :class:`GenericCLScenario[TrainSetWithTargets, TestSetWithTargets, 'NCBatchInfo']`, :class:`Generic[TrainSetWithTargets, TestSetWithTargets]`

   This class defines a "New Classes" Single Incremental Task scenario based
   on a :class:`NCGenericScenario` instance. Once created, an instance of this
   class can be iterated in order to obtain the batch sequence under
   the form of instances of :class:`NCBatchInfo`.

   Instances of this class can be created using the constructor directly.
   However, we recommend using facilities like:
   :func:`.scenario_creation.create_nc_single_dataset_sit_scenario`,
   :func:`.scenario_creation.create_nc_single_dataset_multi_task_scenario`,
   :func:`.scenario_creation.create_nc_multi_dataset_sit_scenario` and
   :func:`.scenario_creation.create_nc_multi_dataset_multi_task_scenario`.

   This class acts as a wrapper for :class:`NCGenericScenario`, adding the
   task label (always "0") as the output to training/test set related functions
   (see: :class:`NCBatchInfo`).

   Creates a NC Single Incremental Task scenario given a
   :class:`NCGenericScenario` instance. That instance will be used as the
   batches factory.

   :param nc_generic_scenario: The :class:`NCGenericScenario` instance
       used to populate this scenario.

   .. method:: get_reproducibility_data(self) -> Dict[str, Any]

      Gets the data needed to reproduce this experiment.

      This data can be stored using the pickle module or some other mechanism.
      It can then be loaded by passing it as the ``reproducibility_data``
      parameter in the constructor.

      Child classes should get the reproducibility dictionary from super class
      and then merge their custom data before returning it.

      :return: A dictionary containing the data needed to reproduce the
          experiment.



.. data:: _default_cifar100_train_transform
   

   

.. data:: _default_cifar100_test_transform
   

   

.. function:: SplitCIFAR100(incremental_steps: int, first_batch_with_half_classes: bool = False, return_task_id=False, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_cifar100_train_transform, test_transform=_default_cifar100_test_transform)

   Creates a CL scenario using the CIFAR100 dataset.
   If the dataset is not present in the computer the method automatically
   download it and store the data in the data folder.

   :param incremental_steps: The number of incremental steps in the current
       scenario. If the first step is a "pretrain" step and it contains
       half of the classes, the number of incremental steps is the number of
       tasks performed after the pretraining task.
       The value of this parameter should be a divisor of 100 if
       first_task_with_half_classes if false, a divisor of 50 otherwise.
   :param first_batch_with_half_classes: A boolean value that indicates if a
       first pretraining batch containing half of the classes should be used.
       If it's True, a pretrain batch with half of the classes (50 for
       cifar100) is used, and a number of incremental tasks, given by the
       parameter incremental_task is constructed. If this paramenter is False
       no pretraining task will be used, and the dataset is simply split into
       a the number of steps defined by the parameter incremental_steps.
       Default to False.
   :param return_task_id: if True, for every step the task id is returned and
       the Scenario is Multi Task. This means that the scenario returned
       will be of type ``NCMultiTaskScenario``. If false the task index is
       not returned (default to 0 for every batch) and the returned scenario
       is of type ``NCSingleTaskScenario``.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param fixed_class_order: A list of class IDs used to define the class
       order. If None, value of ``seed`` will be used to define the class
       order. If non-None, ``seed`` parameter will be ignored.
       Defaults to None.
   :param train_transform: The transformation to apply to the training data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCMultiTaskScenario` instance initialized for the the
       MT scenario using CIFAR100 if the parameter ``return_task_id`` is True,
       a :class:`NCSingleTaskScenario` initialized for the SIT scenario using
       CIFAR100 otherwise.


.. function:: SplitCIFAR110(incremental_steps: int, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_cifar100_train_transform, test_transform=_default_cifar100_test_transform) -> NCSingleTaskScenario

   Creates a Single Incremental Task (SIT) scenario using the CIFAR100 dataset,
   with a pretrain first batch using CIFAR10.
   If the datasets are not present in the computer the method automatically
   download them and store the data in the data folder.

   :param incremental_steps: The number of incremental steps for the
       incremental training on cifar100. The first "pretrain" batch using
       cifar10 is not included in this number of incremental steps.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param fixed_class_order: A list of class IDs used to define the class
       order ONLY for the incremental part on cifar100. The classes must be in
       range 0-99.
       If None, value of ``seed`` will be used to define the class
       order for the incremental batches on cifar100.
       If non-None, ``seed`` parameter will be ignored.
       Defaults to None.
   :param train_transform: The transformation to apply to the training data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCSingleTaskScenario` instance initialized for the the
       SIT scenario using CIFAR10 as a pretrain batch zero and CIFAR100 for the
       incremental training.  


.. function:: _get_cifar100_dataset(train_transformation, test_transformation)


.. function:: create_nc_multi_dataset_multi_task_scenario(train_dataset_list: Sequence[IDatasetWithTargets], test_dataset_list: Sequence[IDatasetWithTargets], shuffle: bool = True, seed: Optional[int] = None, classes_ids_from_zero_in_each_task: bool = True, reproducibility_data: Optional[Dict[str, Any]] = None) -> NCMultiTaskScenario

   Creates a "New Classes - Multi Task" scenario given a list of
   datasets and the number of batches. Each dataset will be treated as a task.
   This means that the overall number of batches will be
   len(train_dataset_list).

   Note: train_dataset_list and test_dataset_list must have the same number of
   datasets.

   :param train_dataset_list: A list of training datasets
   :param test_dataset_list: A list of test datasets
   :param shuffle: If True, task order will be shuffled. Defaults to True.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param classes_ids_from_zero_in_each_task: If True, original class IDs will
       be kept as is, that is, in range [0, n_classes_in_task) for each task.
       If False, each class ID will be remapped so that each class ID will
       appear once across all batches. Defaults to True.
       For instance, if the resulting dataset (task) order after shuffling
       is [dataset2, dataset3, dataset0, dataset1] and
       classes_ids_from_zero_in_each_task is False, then all the classes
       belonging to dataset2 will appear as having IDs in range
       [0, n_classes_in_dataset2) while classes in dataset3 will appear
       as having IDs in range [n_classes_in_dataset2,
       n_classes_in_dataset2+n_classes_in_dataset3) and so on.
   :param reproducibility_data: If not None, overrides all the other
       scenario definition options. This is usually a dictionary containing
       data used to reproduce a specific experiment. One can use the
       ``get_reproducibility_data`` method to get (and even distribute)
       the experiment setup so that it can be loaded by passing it as this
       parameter. In this way one can be sure that the same specific
       experimental setup is being used (for reproducibility purposes).
       Beware that, in order to reproduce an experiment, the same train and
       test datasets must be used. Defaults to None.

   :return: A :class:`NCMultiTaskScenario` instance.


.. py:class:: NCMultiTaskScenario(nc_generic_scenario: NCGenericScenario[TrainSetWithTargets, TestSetWithTargets], classes_ids_from_zero_in_each_task: bool = True, reproducibility_data: Optional[Dict[str, Any]] = None)

   Bases: :class:`GenericCLScenario[TrainSetWithTargets, TestSetWithTargets, 'NCTaskInfo']`, :class:`Generic[TrainSetWithTargets, TestSetWithTargets]`

   This class defines a "New Classes" multi task scenario based on a
   :class:`NCGenericScenario` instance. Once created, an instance of this
   class can be iterated in order to obtain the task sequence under
   the form of instances of :class:`NCTaskInfo`.

   Instances of this class can be created using the constructor directly.
   However, we recommend using facilities like:
   :func:`.scenario_creation.create_nc_single_dataset_sit_scenario`,
   :func:`.scenario_creation.create_nc_single_dataset_multi_task_scenario`,
   :func:`.scenario_creation.create_nc_multi_dataset_sit_scenario` and
   :func:`.scenario_creation.create_nc_multi_dataset_multi_task_scenario`.

   This class acts as a wrapper for :class:`NCGenericScenario`, adding the
   task label as the output to training/test set related functions
   (see: :class:`NCTaskInfo`).

   Creates a NC multi task scenario given a :class:`NCGenericScenario`
   instance. That instance will be used as the batches factory.

   :param nc_generic_scenario: The :class:`NCGenericScenario` instance
       used to populate this scenario.
   :param classes_ids_from_zero_in_each_task: If True, class ids will be
       mapped to range [0, n_classes) for each task. Defaults to True.
   :param reproducibility_data: If not None, overrides all the other
       scenario definition options. This is usually a dictionary containing
       data used to reproduce a specific experiment. One can use the
       ``get_reproducibility_data`` method to get (and even distribute)
       the experiment setup so that it can be loaded by passing it as this
       parameter. In this way one can be sure that the same specific
       experimental setup is being used (for reproducibility purposes).
       Beware that, in order to reproduce an experiment, the same train and
       test datasets must be used. Defaults to None.

   .. method:: get_reproducibility_data(self) -> Dict[str, Any]

      Gets the data needed to reproduce this experiment.

      This data can be stored using the pickle module or some other mechanism.
      It can then be loaded by passing it as the ``reproducibility_data``
      parameter in the constructor.

      Child classes should get the reproducibility dictionary from super class
      and then merge their custom data before returning it.

      :return: A dictionary containing the data needed to reproduce the
          experiment.


   .. method:: classes_in_task_range(self, task_start: int, task_end: Optional[int] = None) -> List[int]

      Gets a list of classes contained int the given tasks. The tasks are
      defined by range. This means that only the classes in range
      [task_start, task_end) will be included.

      :param task_start: The starting task ID
      :param task_end: The final task ID. Can be None, which means that all
          the remaining tasks will be taken.

      :returns: The classes contained in the required task range.


   .. method:: get_class_split(self, task_id)



.. data:: _default_mnist_train_transform
   

   

.. data:: _default_mnist_test_transform
   

   

.. function:: SplitMNIST(incremental_steps: int, return_task_id=False, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_mnist_train_transform, test_transform=_default_mnist_test_transform)

   Creates a CL scenario using the MNIST dataset.
   This helper create the basic split MNIST scenario, where the 10 classes of
   the MNIST dataset are evenly splitted into the given nuber of tasks.
   If the dataset is not present in the computer the method automatically
   download it and store the data in the data folder.

   :param incremental_steps: The number of incremental steps in the current
       scenario.
       The value of this parameter should be a divisor of 10.
   :param return_task_id: if True, for every step the task id is returned and
       the Scenario is Multi Task. This means that the scenario returned
       will be of type ``NCMultiTaskScenario``. If false the task index is
       not returned (default to 0 for every batch) and the returned scenario
       is of type ``NCSingleTaskScenario``.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param fixed_class_order: A list of class IDs used to define the class
       order. If None, value of ``seed`` will be used to define the class
       order. If non-None, ``seed`` parameter will be ignored.
       Defaults to None.
   :param train_transform: The transformation to apply to the training data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCMultiTaskScenario` instance initialized for the the
       MT split MNIST scenario if the parameter ``return_task_id`` is True,
       a :class:`NCSingleTaskScenario` initialized for the SIT split MNIST
       scenario otherwise.


.. function:: PermutedMNIST(incremental_steps: int, seed: Optional[int] = None, train_transform=_default_mnist_train_transform, test_transform=_default_mnist_test_transform) -> NCMultiTaskScenario

   This helper create a permuted MNIST scenario: where a given number of random
   pixel permutations is used to permute the MNIST images in
   `incremental_steps` different manners, creating an equal number of tasks.
   Each task is composed of all the original MNIST 10 classes, but the pixel
   in the images are permuted in different ways in every task.
   If the dataset is not present in the computer the method automatically
   download it and store the data in the data folder.

   :param incremental_steps: The number of incremental tasks in the current
       scenario. It indicates how many different permutations of the MNIST
       dataset have to be created.
       The value of this parameter should be a divisor of 10.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param train_transform: The transformation to apply to the training data
       before the random permutation, e.g. a random crop, a normalization or a
       concatenation of different transformations (see torchvision.transform
       documentation for a comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data
       before the random permutation, e.g. a random crop, a normalization or a
       concatenation of different transformations (see torchvision.transform
       documentation for a comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCMultiTaskScenario` instance initialized for the the
       MT permuted MNIST scenario.


.. function:: RotatedMNIST(incremental_steps: int, seed: Optional[int] = None, rotations_list: Optional[Sequence[int]] = None, train_transform=_default_mnist_train_transform, test_transform=_default_mnist_test_transform) -> NCMultiTaskScenario

   This helper create a rotated MNIST scenario: where a given number of random
   rotations are used to rotate the MNIST images in
   `incremental_steps` different manners, creating an equal number of tasks.
   Each task is composed of all the original MNIST 10 classes, but the images
   are rotated in different ways and using different values in every task.
   If the dataset is not present in the computer the method automatically
   download it and store the data in the data folder.

   :param incremental_steps: The number of incremental tasks in the current
       scenario. It indicates how many different rotations of the MNIST
       dataset have to be created.
       The value of this parameter should be a divisor of 10.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param rotations_list: A list of rotations values in degrees (from -180 to
       180) used to define the rotations. The rotation specified in position
       0 of the list will be applieed to the task 0, the rotation specified in
       position 1 will be applyed to task 1 and so on.
       If None, value of ``seed`` will be used to define the rotations.
       If non-None, ``seed`` parameter will be ignored.
       Defaults to None.
   :param train_transform: The transformation to apply to the training data
       after the random rotation, e.g. a random crop, a normalization or a
       concatenation of different transformations (see torchvision.transform
       documentation for a comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data
       after the random rotation, e.g. a random crop, a normalization or a
       concatenation of different transformations (see torchvision.transform
       documentation for a comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCMultiTaskScenario` instance initialized for the the
       MT rotated MNIST scenario.


.. function:: _get_mnist_dataset(train_transformation, test_transformation)


.. function:: SplitFMNIST(incremental_steps: int, first_batch_with_half_classes: bool = False, return_task_id=False, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_cifar10_train_transform, test_transform=_default_cifar10_test_transform)

   Creates a CL scenario using the Fashion MNIST dataset.
   If the dataset is not present in the computer the method automatically
   download it and store the data in the data folder.

   :param incremental_steps: The number of incremental steps in the current
       scenario. If the first step is a "pretrain" step and it contains
       half of the classes, the number of incremental steps is the number of
       tasks performed after the pretraining task.
       The value of this parameter should be a divisor of 10 if
       first_task_with_half_classes if false, a divisor of 5 otherwise.
   :param first_batch_with_half_classes: A boolean value that indicates if a
       first pretraining batch containing half of the classes should be used.
       If it's True, a pretrain batch with half of the classes (5 for
       cifar100) is used, and a number of incremental tasks, given by the
       parameter incremental_task is constructed. If this paramenter is False
       no pretraining task will be used, and the dataset is simply split into
       a the number of steps defined by the parameter incremental_steps.
       Default to False.
   :param return_task_id: if True, for every step the task id is returned and
       the Scenario is Multi Task. This means that the scenario returned
       will be of type ``NCMultiTaskScenario``. If false the task index is
       not returned (default to 0 for every batch) and the returned scenario
       is of type ``NCSingleTaskScenario``.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param fixed_class_order: A list of class IDs used to define the class
       order. If None, value of ``seed`` will be used to define the class
       order. If non-None, ``seed`` parameter will be ignored.
       Defaults to None.
   :param train_transform: The transformation to apply to the training data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCMultiTaskScenario` instance initialized for the the
       MT scenario using CIFAR10 if the parameter ``return_task_id`` is True,
       a :class:`NCSingleTaskScenario` initialized for the SIT scenario using
       CIFAR10 otherwise.


.. function:: _get_fmnist_dataset(train_transformation, test_transformation)


.. data:: nc_scenario
   

   

.. function:: ImageNet(*args, **kwargs)


.. function:: NCScenario(train_dataset: Union[Sequence[IDatasetWithTargets], IDatasetWithTargets], test_dataset: Union[Sequence[IDatasetWithTargets], IDatasetWithTargets], n_steps: int, multi_task: bool = True, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, per_step_classes: Optional[Dict[int, int]] = None, classes_ids_from_zero: bool = True, remap_class_ids: bool = False, one_dataset_per_batch: bool = False, reproducibility_data: Optional[Dict[str, Any]] = None) -> Union[NCMultiTaskScenario, NCSingleTaskScenario]

   This method is the high-level specific scenario generator for the
   "New Classes" (NC) case. Given a sequence of train and test datasets creates
   the continual stream of data as a series of steps (task or batches),
   highly tunable through its parameters.

   The main parameter ``multi_task`` determines if the scenario is a
   Single-Incremental-Task scenario o a Multi-task one. This in turn enable
   other important options specifying the behavious of each of those.

   :param train_dataset: A list of training datasets, or a single dataset.
   :param test_dataset: A list of test datasets, or a single test dataset.
   :param n_steps: The number of batches or tasks. This is not used in the
       case of multiple train/test datasets and when ``multi_task`` is set to
       True.
   :param multi_task: True if the scenario is Multi-Task, False if it is a
       Single-Incremental-Task scenario.
   :param shuffle: If True, class order will be shuffled.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param fixed_class_order: This parameter is valid only if a single
       train-test dataset is provided. A list of class IDs used to define the
       classorder. If None, values of shuffle and seed will be used to define
       the class order. If non-None, shuffle and seed parameters will be
       ignored. Defaults to None.
   :param per_step_classes: not available with multiple train-test
       datasets and ``multi_task`` is set to True. Is not None, a dictionary
       whose keys are (0-indexed) task IDs and their values are the number
       of classes to include in the respective batches. The dictionary doesn't
       have to contain a key for each task! All the remaining batches
       will contain an equal amount of the remaining classes. The
       remaining number of classes must be divisible without remainder
       by the remaining number of steps. For instance,
       if you want to include 50 classes in the first task while equally
       distributing remaining classes across remaining batches,
       just pass the "{0: 50}" dictionary as the per_task_classes
       parameter. Defaults to None.
   :param classes_ids_from_zero: This parametes is valid
       only when ``multi_task`` is set to True. If True, original class IDs
       will be mapped to range [0, n_classes_in_task) for each step. If False,
       each class will keep its original ID as defined in the input
       datasets. Defaults to True.
   :param remap_class_ids: This parameter is only valid when a single
       train/test is given and ``multi_task`` is set to False.
       If True, original class IDs will be remapped so that they will appear
       as having an ascending order. For instance, if the resulting class
       order after shuffling (or defined by fixed_class_order) is [23, 34,
       11, 7, 6, ...] and remap_class_indexes is True, then all the patterns
       belonging to class 23 will appear as belonging to class "0",
       class "34" will be mapped to "1", class "11" to "2" and so on. This
       is very useful when drawing confusion matrices and when dealing with
       algorithms with dynamic head expansion. Defaults to False.
   :param one_dataset_per_batch: available only when multile train-test
       datasets are provided and ``multi_task`` is set to False. If True, each
       dataset will be treated as a batch. Mutually exclusive with the
       per_task_classes parameter. Overrides the n_batches parameter.
   :param reproducibility_data: If not None, overrides all the other
       scenario definition options. This is usually a dictionary containing
       data used to reproduce a specific experiment. One can use the
       ``get_reproducibility_data`` method to get (and even distribute)
       the experiment setup so that it can be loaded by passing it as this
       parameter. In this way one can be sure that the same specific
       experimental setup is being used (for reproducibility purposes).
       Beware that, in order to reproduce an experiment, the same train and
       test datasets must be used. Defaults to None.

   :return: A :class:`NCMultiTaskScenario` or :class:`NCSingleTaskScenario`
       instance initialized for the the SIT or MT scenario.


.. data:: normalize
   

   

.. function:: SplitImageNet(root, incremental_steps=10, classes_first_batch=None, return_task_id=False, seed=0, fixed_class_order=None, train_transform=_default_train_transform, test_transform=_default_test_transform)

   Creates a CL scenario using the Tiny ImageNet dataset.
   If the dataset is not present in the computer the method automatically
   download it and store the data in the data folder.

   :param root: Base path where Imagenet data are stored.
   :param incremental_steps: The number of incremental steps in the current
       scenario.
   :param classes_first_batch: Number of classes in the first batch.
   Usually this is set to 500. Default to None.
   :param return_task_id: if True, for every step the task id is returned and
       the Scenario is Multi Task. This means that the scenario returned
       will be of type ``NCMultiTaskScenario``. If false the task index is
       not returned (default to 0 for every batch) and the returned scenario
       is of type ``NCSingleTaskScenario``.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param fixed_class_order: A list of class IDs used to define the class
       order. If None, value of ``seed`` will be used to define the class
       order. If non-None, ``seed`` parameter will be ignored.
       Defaults to None.
   :param train_transform: The transformation to apply to the training data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCMultiTaskScenario` instance initialized for the the
       MT scenario using CIFAR10 if the parameter ``return_task_id`` is True,
       a :class:`NCSingleTaskScenario` initialized for the SIT scenario using
       CIFAR10 otherwise.
       


.. data:: scenario
   

   

.. py:class:: CUB200(root, train=True, transform=None, loader=default_loader, download=False)

   Bases: :class:`torch.utils.data.Dataset`

   An abstract class representing a :class:`Dataset`.

   All datasets that represent a map from keys to data samples should subclass
   it. All subclasses should overwrite :meth:`__getitem__`, supporting fetching a
   data sample for a given key. Subclasses could also optionally overwrite
   :meth:`__len__`, which is expected to return the size of the dataset by many
   :class:`~torch.utils.data.Sampler` implementations and the default options
   of :class:`~torch.utils.data.DataLoader`.

   .. note::
     :class:`~torch.utils.data.DataLoader` by default constructs a index
     sampler that yields integral indices.  To make it work with a map-style
     dataset with non-integral indices/keys, a custom sampler must be provided.

   Initialize self.  See help(type(self)) for accurate signature.

   .. attribute:: filename
      :annotation: = images.tgz

      

   .. attribute:: metadata
      :annotation: = lists.tgz

      

   .. attribute:: basefolder
      :annotation: = images

      

   .. attribute:: tgz_md5
      :annotation: = 2bbe304ef1aa3ddb6094aa8f53487cf2

      

   .. method:: _load_metadata(self)


   .. method:: _check_integrity(self)


   .. method:: __len__(self)


   .. method:: __getitem__(self, idx)



.. function:: SplitCUB200(root, incremental_steps=11, classes_first_batch=100, return_task_id=False, seed=0, fixed_class_order=None, shuffle=False, train_transform=_default_train_transform, test_transform=_default_test_transform)

   Creates a CL scenario using the Tiny ImageNet dataset.
   If the dataset is not present in the computer the method automatically
   download it and store the data in the data folder.

   :param root: Base path where Imagenet data are stored.
   :param incremental_steps: The number of incremental steps in the current
       scenario.
   :param classes_first_batch: Number of classes in the first batch.
   Usually this is set to 500. Default to None.
   :param return_task_id: if True, for every step the task id is returned and
       the Scenario is Multi Task. This means that the scenario returned
       will be of type ``NCMultiTaskScenario``. If false the task index is
       not returned (default to 0 for every batch) and the returned scenario
       is of type ``NCSingleTaskScenario``.
   :param seed: A valid int used to initialize the random number generator.
       Can be None.
   :param fixed_class_order: A list of class IDs used to define the class
       order. If None, value of ``seed`` will be used to define the class
       order. If non-None, ``seed`` parameter will be ignored.
       Defaults to None.
   :param shuffle: If true, the class order in the incremental steps is
       randomly shuffled. Default to false.
   :param train_transform: The transformation to apply to the training data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default train transformation
       will be used.
   :param test_transform: The transformation to apply to the test data,
       e.g. a random crop, a normalization or a concatenation of different
       transformations (see torchvision.transform documentation for a
       comprehensive list of possible transformations).
       If no transformation is passed, the default test transformation
       will be used.

   :returns: A :class:`NCMultiTaskScenario` instance initialized for the the
       MT scenario using CIFAR10 if the parameter ``return_task_id`` is True,
       a :class:`NCSingleTaskScenario` initialized for the SIT scenario using
       CIFAR10 otherwise.
       


