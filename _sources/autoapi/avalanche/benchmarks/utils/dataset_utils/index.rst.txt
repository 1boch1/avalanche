:mod:`avalanche.benchmarks.utils.dataset_utils`
===============================================

.. py:module:: avalanche.benchmarks.utils.dataset_utils


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   avalanche.benchmarks.utils.dataset_utils.SubSequence
   avalanche.benchmarks.utils.dataset_utils.LazyClassMapping
   avalanche.benchmarks.utils.dataset_utils.LazyConcatTargets
   avalanche.benchmarks.utils.dataset_utils.LazyConcatIntTargets
   avalanche.benchmarks.utils.dataset_utils.LazyTargetsConversion
   avalanche.benchmarks.utils.dataset_utils.ConstantSequence
   avalanche.benchmarks.utils.dataset_utils.SubsetWithTargets
   avalanche.benchmarks.utils.dataset_utils.ClassificationSubset
   avalanche.benchmarks.utils.dataset_utils.ConcatDatasetWithTargets
   avalanche.benchmarks.utils.dataset_utils.SequenceDataset
   avalanche.benchmarks.utils.dataset_utils.TensorDatasetWrapper



Functions
~~~~~~~~~

.. autoapisummary::

   avalanche.benchmarks.utils.dataset_utils.find_list_from_index
   avalanche.benchmarks.utils.dataset_utils.manage_advanced_indexing
   avalanche.benchmarks.utils.dataset_utils.optimize_sequence


.. py:class:: SubSequence(targets: Sequence[TTargetType], indices: Union[Sequence[int], None])

   Bases: :class:`Sequence[TTargetType]`

   A utility class used to define a lazily evaluated sub-sequence.

   Initialize self.  See help(type(self)) for accurate signature.

   .. method:: __len__(self)


   .. method:: __getitem__(self, item_idx) -> TTargetType


   .. method:: __str__(self)

      Return str(self).



.. py:class:: LazyClassMapping(targets: Sequence[SupportsInt], indices: Union[Sequence[int], None], mapping: Optional[Sequence[int]] = None)

   Bases: :class:`SubSequence[int]`

   This class is used when in need of lazy populating a targets field whose
   elements need to be filtered out (when subsetting, see
   :class:`torch.utils.data.Subset`) and/or transformed (remapped). This will
   allow for a more efficient memory usage as the conversion is done on the fly
   instead of actually allocating a new targets list.

   This class should be used only when mapping int targets (classification).

   Initialize self.  See help(type(self)) for accurate signature.

   .. method:: __getitem__(self, item_idx) -> int



.. py:class:: LazyConcatTargets(targets_list: Sequence[Sequence[TTargetType]])

   Bases: :class:`Sequence[TTargetType]`

   Defines a lazy targets concatenation.

   This class is used when in need of lazy populating a targets created
   as the concatenation of the targets field of multiple datasets.
   This will allow for a more efficient memory usage as the concatenation is
   done on the fly instead of actually allocating a new targets list.

   Initialize self.  See help(type(self)) for accurate signature.

   .. method:: __len__(self)


   .. method:: __getitem__(self, item_idx) -> TTargetType


   .. method:: __str__(self)

      Return str(self).



.. py:class:: LazyConcatIntTargets(targets_list: Sequence[Sequence[SupportsInt]])

   Bases: :class:`LazyConcatTargets[int]`

   Defines a lazy targets concatenation.

   This class is used when in need of lazy populating a targets created
   as the concatenation of the targets field of multiple datasets.
   This will allow for a more efficient memory usage as the concatenation is
   done on the fly instead of actually allocating a new targets list.

   Elements returned by `__getitem__` will be int values.

   Initialize self.  See help(type(self)) for accurate signature.

   .. method:: __getitem__(self, item_idx) -> int



.. py:class:: LazyTargetsConversion(targets: Sequence[SupportsInt])

   Bases: :class:`Sequence[int]`

   Defines a lazy conversion of targets defined in some other format.

   To be used when transforming targets to int (classification).

   Initialize self.  See help(type(self)) for accurate signature.

   .. method:: __len__(self)


   .. method:: __getitem__(self, item_idx) -> int


   .. method:: __str__(self)

      Return str(self).



.. py:class:: ConstantSequence(constant_value: int, size: int)

   Bases: :class:`Sequence[int]`

   Defines a constant sequence given an int value and the length.

   Initialize self.  See help(type(self)) for accurate signature.

   .. method:: __len__(self)


   .. method:: __getitem__(self, item_idx) -> int


   .. method:: __str__(self)

      Return str(self).



.. py:class:: SubsetWithTargets(dataset: IDatasetWithTargets[T_co, TTargetType], indices: Union[Sequence[int], None])

   Bases: :class:`IDatasetWithTargets[T_co, TTargetType]`

   A Dataset that behaves like a PyTorch :class:`torch.utils.data.Subset`.
   However, this dataset also supports the targets field.

   Initialize self.  See help(type(self)) for accurate signature.

   .. method:: __getitem__(self, idx)


   .. method:: __len__(self) -> int



.. py:class:: ClassificationSubset(dataset: ISupportedClassificationDataset[T_co], indices: Union[Sequence[int], None], class_mapping: Optional[Sequence[int]] = None)

   Bases: :class:`SubsetWithTargets[T_co, int]`

   A Dataset that behaves like a PyTorch :class:`torch.utils.data.Subset`.
   However, this dataset also supports the targets field and class mapping.

   .. method:: __getitem__(self, idx)



.. py:class:: ConcatDatasetWithTargets(datasets: Sequence[IDatasetWithTargets[T_co, TTargetType]])

   Bases: :class:`IDatasetWithTargets[T_co, TTargetType]`

   A Dataset that behaves like a PyTorch
   :class:`torch.utils.data.ConcatDataset`. In addition, this dataset also
   supports the concatenation of the targets field.

   Initialize self.  See help(type(self)) for accurate signature.

   .. method:: __getitem__(self, idx)


   .. method:: __len__(self)



.. py:class:: SequenceDataset(*sequences: Sequence)

   Bases: :class:`IDatasetWithTargets[T_co, TTargetType]`

   A Dataset that wraps existing ndarrays, Tensors, lists... to provide
   basic Dataset functionalities. Very similar to TensorDataset.

   Creates a ``SequenceDataset`` instance.

   Beware that the second sequence, will be used to fill the targets
   field without running any kind of type conversion.

   :param sequences: A sequence of sequences, Tensors or ndarrays
       representing the patterns.

   .. method:: __getitem__(self, idx)


   .. method:: __len__(self) -> int



.. py:class:: TensorDatasetWrapper(tensor_dataset: ITensorDataset[T_co])

   Bases: :class:`ClassificationDataset[T_co]`

   A Dataset that wraps a Tensor Dataset to provide the targets field.

   A Tensor Dataset is any dataset with a "tensors" field. The tensors
   field must be a sequence of Tensor. To provide a valid targets field,
   the "tensors" field must contain at least 2 tensors. The second tensor
   must contain elements that can be converted to int.

   Beware that the second element obtained from the wrapped dataset using
   __getitem__ will always be converted to int, This differs from the
   behaviour of PyTorch TensorDataset. This is required to keep a better
   compatibility with torchvision datasets.

   Creates a ``TensorDatasetWrapper`` instance.

   :param tensor_dataset: An instance of a TensorDataset. See class
       description for more details.

   .. method:: __getitem__(self, idx)


   .. method:: __len__(self) -> int



.. function:: find_list_from_index(pattern_idx: int, list_sizes: Sequence[int], max_size: int)


.. function:: manage_advanced_indexing(idx, single_element_getter, max_length, collate_fn)

   Utility function used to manage the advanced indexing and slicing.

   If more than a pattern is selected, the X and Y values will be merged
   in two separate torch Tensor objects using the stack operation.

   :param idx: Either an in, a slice object or a list (including ndarrays and
       torch Tensors) of indexes.
   :param single_element_getter: A callable used to obtain a single element
       given its int index.
   :param max_length: The maximum sequence length.
   :param collate_fn: The function to use to create a batch of data from
       single elements.
   :return: A tuple consisting of two tensors containing the X and Y values
       of the patterns addressed by the idx parameter.


.. function:: optimize_sequence(sequence: Sequence[TTargetType]) -> Sequence[TTargetType]


