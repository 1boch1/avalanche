:mod:`avalanche.extras.strategy_trace`
======================================

.. py:module:: avalanche.extras.strategy_trace


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   avalanche.extras.strategy_trace.StrategyTrace
   avalanche.extras.strategy_trace.DotTrace



.. py:class:: StrategyTrace

   Bases: :class:`typing_extensions.Protocol`

   Base class for protocol classes. Protocol classes are defined as::

     class Proto(Protocol):
         def meth(self) -> int:
             ...

   Such classes are primarily used with static type checkers that recognize
   structural subtyping (static duck-typing), for example::

     class C:
         def meth(self) -> int:
             return 0

     def func(x: Proto) -> int:
         return x.meth()

     func(C())  # Passes static type check

   See PEP 544 for details. Protocol classes decorated with
   @typing_extensions.runtime act as simple-minded runtime protocol that checks
   only the presence of given attributes, ignoring their type signatures.

   Protocol classes can be generic, they are defined as::

     class GenProto({bases}):
         def meth(self) -> T:
             ...

   Create and return a new object.  See help(type) for accurate signature.

   .. method:: __call__(self, eval_data: EvalData) -> None



.. py:class:: DotTrace(stdout=True, stderr=False, trace_file: Union[str, Path] = None, *, iterations_per_line: int = 50, lines_between_summaries: int = 4)

   Bases: :class:`avalanche.extras.strategy_trace.StrategyTrace`

   Base class for protocol classes. Protocol classes are defined as::

     class Proto(Protocol):
         def meth(self) -> int:
             ...

   Such classes are primarily used with static type checkers that recognize
   structural subtyping (static duck-typing), for example::

     class C:
         def meth(self) -> int:
             return 0

     def func(x: Proto) -> int:
         return x.meth()

     func(C())  # Passes static type check

   See PEP 544 for details. Protocol classes decorated with
   @typing_extensions.runtime act as simple-minded runtime protocol that checks
   only the presence of given attributes, ignoring their type signatures.

   Protocol classes can be generic, they are defined as::

     class GenProto({bases}):
         def meth(self) -> T:
             ...

   Initialize self.  See help(type(self)) for accurate signature.

   .. method:: _update_metrics(self, eval_data: EvalData)


   .. method:: _new_line(self)


   .. method:: _message(self, msg: str)


   .. method:: _file_error(self, err, new_line=True)


   .. method:: __call__(self, eval_data: EvalData)



.. data:: DefaultStrategyTrace
   

   

