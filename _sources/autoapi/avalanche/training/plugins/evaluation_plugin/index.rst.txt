:mod:`avalanche.training.plugins.evaluation_plugin`
===================================================

.. py:module:: avalanche.training.plugins.evaluation_plugin


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   avalanche.training.plugins.evaluation_plugin.EvaluationPlugin



.. py:class:: EvaluationPlugin

   Bases: :class:`avalanche.training.skeletons.StrategySkeleton`

   An evaluation plugin that can be plugged in a strategy.

   Instances of this class should be used as strategy plugins.

   This plugin obtains relevant data from the training and testing loops of the
   main strategy by using the integrated callbacks systems.

   Internally, the evaluation plugin tries to use the "evaluation_protocol"
   namespace value. If found and not None, the evaluation protocol
   (usually an instance of :class:`EvalProtocol`), is used to compute the
   required metrics. The "evaluation_protocol" is usually a field of the main
   strategy.

   For an example on how to use it, see :class:`DeepLearningStrategy` and
   :class:`Naive`.

   Beware that, while most of the required callbacks are automatically managed
   by the :class:`DeepLearningStrategy` class, some callbacks such as
   "after_training_iteration" and "after_test_iteration" must be called
   by the implementing strategy subclasses. For an example of a vanilla
   training/testing epoch, see :class:`Naive`.

   Creates a strategy skeleton instance.

   .. method:: get_train_result(self)


   .. method:: get_test_result(self)


   .. method:: before_training(self, step_info: IStepInfo = None)


   .. method:: make_train_dataloader(self, train_dataset=None)


   .. method:: after_training_iteration(self, evaluation_protocol: Optional[EvalProtocol] = None, epoch: int = None, iteration: int = None, train_mb_y: Tensor = None, logits: Tensor = None, loss: Tensor = None, **kwargs)


   .. method:: before_testing(self)


   .. method:: before_step_testing(self, step_info: IStepInfo = None, step_id: int = None)


   .. method:: make_test_dataloader(self, test_dataset=None)


   .. method:: after_test_iteration(self, evaluation_protocol: Optional[EvalProtocol] = None, iteration: int = None, test_mb_y: Tensor = None, test_logits: Tensor = None, test_loss: Tensor = None)


   .. method:: after_step_testing(self, evaluation_protocol: Optional[EvalProtocol] = None)


   .. method:: after_testing(self, evaluation_protocol: Optional[EvalProtocol] = None, step_info: IStepInfo = None)


   .. method:: __missing(*elements)
      :staticmethod:


   .. method:: __no_evaluation_protocol()
      :staticmethod:



