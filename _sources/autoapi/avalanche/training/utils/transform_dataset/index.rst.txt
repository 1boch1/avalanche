:mod:`avalanche.training.utils.transform_dataset`
=================================================

.. py:module:: avalanche.training.utils.transform_dataset


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   avalanche.training.utils.transform_dataset.IDataset
   avalanche.training.utils.transform_dataset.IDatasetWithTargets
   avalanche.training.utils.transform_dataset.DatasetWithTargets
   avalanche.training.utils.transform_dataset.TransformationDataset
   avalanche.training.utils.transform_dataset.TransformationSubset
   avalanche.training.utils.transform_dataset.ConcatDatasetWithTargets
   avalanche.training.utils.transform_dataset.TransformationTensorDataset



Functions
~~~~~~~~~

.. autoapisummary::

   avalanche.training.utils.transform_dataset.concat_datasets_sequentially


.. py:class:: IDataset

   Bases: :class:`Protocol[T_co]`

   Protocol definition of a Dataset.

   Note: no __add__ method is defined.

   .. method:: __getitem__(self, index: int) -> T_co


   .. method:: __len__(self) -> int



.. py:class:: IDatasetWithTargets

   Bases: :class:`IDataset[T_co]`, :class:`typing.Protocol`

   Protocol definition of a Dataset that has a valid targets field (like the
   Datasets in the torchvision package)

   Create and return a new object.  See help(type) for accurate signature.

   .. attribute:: targets
      :annotation: :Sequence[int]

      


.. py:class:: DatasetWithTargets

   Bases: :class:`IDatasetWithTargets[T_co]`, :class:`torch.utils.data.Dataset`

   Dataset that has a valid targets field (like the Datasets in the
   torchvision package)

   The actual value of the targets field should be set by the child class.

   Initialize self.  See help(type(self)) for accurate signature.


.. py:class:: TransformationDataset(dataset: IDatasetWithTargets, transform=None, target_transform=None)

   Bases: :class:`avalanche.training.utils.transform_dataset.DatasetWithTargets`

   A Dataset that applies transformations before returning patterns/targets.
   Also, this Dataset supports basic slicing and advanced indexing.

   Initialize self.  See help(type(self)) for accurate signature.

   .. method:: __getitem__(self, idx)


   .. method:: __len__(self) -> int


   .. method:: __get_single_item(self, idx: int)



.. py:class:: TransformationSubset(dataset: IDatasetWithTargets, indices: Union[Sequence[int], None], transform=None, target_transform=None, class_mapping: Optional[Sequence[int]] = None)

   Bases: :class:`avalanche.training.utils.transform_dataset.DatasetWithTargets`

   A Dataset that behaves like a pytorch :class:`torch.utils.data.Subset`,
   with all the goodness of :class:`TransformationDataset`

   Initialize self.  See help(type(self)) for accurate signature.

   .. method:: __getitem__(self, idx)


   .. method:: __len__(self) -> int


   .. method:: __get_single_item(self, idx: int)



.. py:class:: ConcatDatasetWithTargets(datasets: Sequence[IDatasetWithTargets])

   Bases: :class:`avalanche.training.utils.transform_dataset.DatasetWithTargets`

   A Dataset that behaves like a pytorch
   :class:`torch.utils.data.ConcatDataset`. However, this dataset also
   supports basic slicing and advanced indexing and also has a targets field.

   Initialize self.  See help(type(self)) for accurate signature.

   .. method:: __getitem__(self, idx)


   .. method:: __len__(self) -> int


   .. method:: __get_single_item(self, idx: int)



.. function:: concat_datasets_sequentially(train_dataset_list: Sequence[IDatasetWithTargets], test_dataset_list: Sequence[IDatasetWithTargets])

   Concatenates a list of datasets. This is completely different from
   :class:`ConcatDataset`, in which datasets are merged together without
   other processing. Instead, this function re-maps the datasets class IDs.
   For instance:
   let the dataset[0] contain patterns of 3 different classes,
   let the dataset[1] contain patterns of 2 different classes, then class IDs
   will be mapped as follows:

   dataset[0] class "0" -> new class ID is "0"

   dataset[0] class "1" -> new class ID is "1"

   dataset[0] class "2" -> new class ID is "2"

   dataset[1] class "0" -> new class ID is "3"

   dataset[1] class "1" -> new classID is "4"

   ... -> ...

   dataset[N-1] class "C-1" -> new class ID is "overall_n_classes-1"

   In contract, using PyTorch ConcatDataset:

   dataset[0] class "0" -> ID is "0"

   dataset[0] class "1" -> ID is "1"

   dataset[0] class "2" -> ID is "2"

   dataset[1] class "0" -> ID is "0"

   dataset[1] class "1" -> ID is "1"

   Note: ``train_dataset_list`` and ``test_dataset_list`` must have the same
   number of datasets.

   :param train_dataset_list: A list of training datasets
   :param test_dataset_list: A list of test datasets

   :returns: A concatenated dataset.


.. py:class:: TransformationTensorDataset(dataset_x: Sequence[Any], dataset_y: Sequence[SupportsInt], transform=None, target_transform=None)

   Bases: :class:`avalanche.training.utils.transform_dataset.DatasetWithTargets`

   A Dataset that wraps existing ndarrays, Tensors, lists... to provide
   basic Dataset functionalities. Very similar to TensorDataset from PyTorch,
   this Dataset also supports transformations, basic slicing and advanced
   indexing and the targets field.

   Initialize self.  See help(type(self)) for accurate signature.

   .. method:: __getitem__(self, idx)


   .. method:: __len__(self) -> int


   .. method:: __get_single_item(self, idx: int)



