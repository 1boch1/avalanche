:mod:`avalanche.training.skeletons`
===================================

.. py:module:: avalanche.training.skeletons


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   cl_strategy/index.rst
   strategy_flow/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   avalanche.training.skeletons.IStrategy
   avalanche.training.skeletons.StrategySkeleton
   avalanche.training.skeletons.StrategyTemplate
   avalanche.training.skeletons.FlowGroup
   avalanche.training.skeletons.StrategyFlow



Functions
~~~~~~~~~

.. autoapisummary::

   avalanche.training.skeletons.make_strategy_part_decorator


.. py:class:: IStrategy

   Bases: :class:`typing.Protocol`

   Define the protocol for a strategy.

   A strategy is a class with train and test methods. Those methods must accept
   a step info object as the parameter. Moreover, the test method should allow
   the user to select which part (complete, cumulative, ...) of the test set
   should be considered by the testing phase.


   Create and return a new object.  See help(type) for accurate signature.

   .. method:: train(self, step_info: IStepInfo, **kwargs)

      Executes an incremental training step on the training data.

      This methods takes a "step_info" as a parameter. The "step_info"
      instance can be used to extract data relevant to the current training
      step, like the training dataset, the current task/batch id, any
      previous or future training or testing test, etc.

      :param step_info: The step info instance.
      :param kwargs: A list of strategy parameters.
      :return: Strategy specific.


   .. method:: test(self, step_info: IStepInfo, test_part: DatasetPart, **kwargs)

      Executes a testing procedure step on the testing data.

      This methods takes a "step_info" as a parameter. The "step_info"
      instance can be used to extract data relevant to the current testing
      step, like the test datasets, the current task/batch id, any
      previous or future training or testing test, etc.

      Beware that a dataset part flag must be passed as the second parameter
      (as a value of :class:`DatasetPart`). This flag controls whenever the
      user wants to test on all tasks/batches ("COMPLETE"), only on already
      encountered tasks/batches ("CUMULATIVE"), only on previous ones ("OLD"),
      on the current task/batch only ("CURRENT") or even on future
      tasks/batches ("FUTURE").

      The testing procedure must loop through the different test sets
      to obtain the relevant metrics.

      :param step_info: The step info instance.
      :param kwargs: A list of strategy parameters.
      :return: Strategy specific.



.. py:class:: StrategySkeleton

   Bases: :class:`avalanche.training.skeletons.cl_strategy.IStrategy`

   Defines the skeleton for a Continual Learning strategy.

   This skeleton introduces the "Training" and "Testing" flows, which are the
   two most commonly used flows. The training flow describes how the strategy
   runs an incremental training step on a new batch/task, while the testing
   flow defines the testing procedure.

   This class is usually not used directly. Consider using
   :class:`avalanche.training.strategies.DeepLearningStrategy` instead.

   This class also defines few utility methods to control the strategy
   lifecycle.

   Creates a strategy skeleton instance.

   .. method:: update_namespace(self, **update_dict)

      Updates the "results namespace" using the provided parameters.

      For more info refer to the class :class:`StrategyFlow` documentation.

      :param update_dict: The parameters used to update the "results
          namespace".
      :return: None.


   .. method:: is_training(self)

      Check if the training flow is running.
      :return: True if the training flow is running, False otherwise.


   .. method:: is_testing(self)

      Check if the testing flow is running.
      :return: True if the testing flow is running, False otherwise.


   .. method:: add_plugin(self, plugin: StrategySkeleton)

      Adds a plugin to this strategy.

      :param plugin: The plugin to add.
      :return: None



.. py:class:: StrategyTemplate

   Bases: :class:`avalanche.training.skeletons.cl_strategy.StrategySkeleton`

   Defines a common generic template for Continual Learning strategies.

   Being extremely generic, this template can also be used by non Deep
   Learning approaches.

   The training flow is simply divided in three parts: BeforeTraining,
   ModelTraining and AfterTraining. The only implemented facility for training
   is the extraction of the training dataset from the step_info and the
   creation of the DataLoader.

   The testing flow template is more complex as it involves managing a list
   of test subsets (usually one for each task/batch) obtained from step_info.
   By using this template as the  base class for a strategy, the procedures
   needed to loop through the  different test subsets are already implemented
   and integrated in the testing flow.

   Creates and instance of the Strategy Template.

   .. method:: make_train_dataset(self, step_info: IStepInfo)

      Returns the training dataset, given the step_info instance.

      This is a part of the training flow. Sets the train_dataset namespace
      value.

      :param step_info: The step info instance, as returned from the CL
          scenario.
      :return: The training dataset.


   .. method:: make_train_dataloader(self, train_dataset, num_workers=0, train_mb_size=1)

      Return a DataLoader initialized with the training dataset.

      This is a part of the training flow. Sets the train_data_loader
      namespace value.

      :param train_dataset: The training dataset. Usually set by the
          make_train_dataset method.
      :param num_workers: The number of workers to use. Defaults to 0.
          Usually set by the user when calling the train method of the
          strategy or as a strategy field.
      :param train_mb_size: The minibatch size. Defaults to 1. Usually set
          as a strategy field.
      :return: The DataLoader for the training set.


   .. method:: make_test_dataset(self, step_info: IStepInfo, step_id: int)

      Returns the test dataset, given the step_info instance and the
      identifier of the step (task/batch) to test.

      This is a part of the testing flow. Sets the test_dataset namespace
      value.

      :param step_info: The step info instance, as returned from the CL
          scenario.
      :param step_id: The ID of the step for which to obtain the test set.
      :return: The training dataset.


   .. method:: make_test_dataloader(self, test_dataset, num_workers=0, test_mb_size=1)

      Return a DataLoader initialized with the test dataset.

      This is a part of the testing flow. Sets the test_data_loader
      namespace value.

      :param test_dataset: The test dataset. Usually set by the
          make_test_dataset method.
      :param num_workers: The number of workers to use. Defaults to 0.
          Usually set by the user when calling the test method of the
          strategy or as a strategy field.
      :param test_mb_size: The minibatch size. Defaults to 1. Usually set
          as a strategy field.
      :return: The DataLoader for the test set.


   .. method:: set_initial_test_step_id(self, step_info: IStepInfo, dataset_part: DatasetPart = None)

      An internal method that sets the initial step_id for the testing flow.

      The initial step id depends on the dataset_part passed to the test
      method of the strategy.

      For the complete, cumulative and old parts, the initial step_id will be
      zero. For the future part, the step id will be the current step plus
      one. For the current part, step_id will be set to the current step id.

      :param step_info: The step info instance, as returned from the CL
          scenario.
      :param dataset_part: The dataset part to consider for testing (as passed
          to the test method of the strategy), as a value of
          :class:`DatasetPart`.
      :return: None


   .. method:: next_testing_step(self, step_id: int, step_info: IStepInfo, test_part: DatasetPart = None)

      Checks if another testing step has to be done and sets the step_id
      namespace value accordingly.

      :param step_id: The current test step id.
      :param step_info: The step info instance, as returned from the CL
          scenario.
      :param test_part: The dataset part to consider for testing (as passed
          to the test method of the strategy), as a value of
          :class:`DatasetPart`.
      :return: True, if other testing steps are to be executed. False
          otherwise.


   .. method:: has_testing_steps_left(self, step_id, step_info: IStepInfo, test_part: DatasetPart = None)

      Checks if another testing step has to be done.

      Doesn't set any namespace value.

      :param step_id: The current test step id.
      :param step_info: The step info instance, as returned from the CL
          scenario.
      :param test_part: The dataset part to consider for testing (as passed
          to the test method of the strategy), as a value of
          :class:`DatasetPart`.
      :return: True, if other testing steps are to be executed. False
          otherwise.


   .. method:: train(self, step_info: IStepInfo, **kwargs)

      Executes an incremental training step on the training data.

      This methods takes a "step_info" as a parameter. The "step_info"
      instance can be used to extract data relevant to the current training
      step, like the training dataset, the current task/batch id, any
      previous or future training or testing test, etc.

      :param step_info: The step info instance.
      :param kwargs: A list of strategy parameters.
      :return: Strategy specific.


   .. method:: test(self, step_info: IStepInfo, test_part: DatasetPart, **kwargs)

      Executes a testing procedure step on the testing data.

      This methods takes a "step_info" as a parameter. The "step_info"
      instance can be used to extract data relevant to the current testing
      step, like the test datasets, the current task/batch id, any
      previous or future training or testing test, etc.

      Beware that a dataset part flag must be passed as the second parameter
      (as a value of :class:`DatasetPart`). This flag controls whenever the
      user wants to test on all tasks/batches ("COMPLETE"), only on already
      encountered tasks/batches ("CUMULATIVE"), only on previous ones ("OLD"),
      on the current task/batch only ("CURRENT") or even on future
      tasks/batches ("FUTURE").

      The testing procedure must loop through the different test sets
      to obtain the relevant metrics.

      :param step_info: The step info instance.
      :param kwargs: A list of strategy parameters.
      :return: Strategy specific.



.. data:: StrategyPart
   

   

.. data:: StrategyChild
   

   

.. data:: StrategyChildId
   

   

.. function:: make_strategy_part_decorator(flow_field: str)

   Factory for a strategy part decorator.

   :param flow_field: The name of the decorator.
   :return: A decorator that can be used to decorate class methods.


.. data:: TrainingFlow
   

   

.. data:: TestingFlow
   

   

.. py:class:: FlowGroup(flow: StrategyFlow, elements: List[StrategyChild], group_name: str, is_loop: bool = False)

   This class defines a flow group.

   Simply put, a flow group contains a sequence of parts that are executed
   one after another when the group's __call__ method is invoked. A FlowGroup
   can be  also flagged as a loop, which means that the last element of the
   parts sequence controls whenever the loops would stop or continue by
   returning True (continue) or False (break). Parts can be class methods
   (usually decorated with @TrainingFlow or @TestingFlow) or another FlowGroup.
   This means that flow groups are organized in a tree where methods are the
   leaves and flow groups are intermediate nodes.

   In a StrategyFlow can't exist parts with duplicate names. A name of a part
   is the method name for class methods or the FlowGroup name for FlowGroups.

   Creates a new flow group.

   :param flow: The flow this group belongs to.
   :param elements: The initial sequence of parts. Parts can be methods
       or other FlowGroups. No duplicate names are allowed.
   :param group_name: The group name. Must be unique through the entire
       StrategyFlow tree.
   :param is_loop: If True, the __call__ will loop through the parts
       until the last part return False.

   .. method:: __call__(self, *args, **kwargs)

      Executes the contained parts sequentially.

      If this group was created with the is_loop flag set as True, all parts
      will be executed in a loop until the last part returns False.
      :param args: Ignored
      :param kwargs: A dictionary of values to be set in the call namespace.
          Children parts that have any of these parameters in their method
          signature will get the relative value with the same name. This works
          very similar to a dependency injection.

          For instance, calling this group as "group(device="cpu")" will
          expose the "device" value to all children parts.

      :return: The return value of the last part. Please note that if this
          group is a loop, the return value will be True.


   .. method:: _append_elements(self, to_group: StrategyChildId, after_child: Optional[StrategyChildId], new_elements: List[StrategyChild], at_beginning: bool = False)


   .. method:: _replace(self, to_be_replaced: StrategyChildId, new_element: StrategyChild) -> StrategyChild


   .. method:: _remove(self, to_be_removed: StrategyChildId) -> StrategyChild


   .. method:: _update_child_names(self)


   .. method:: _check_compatibility(added_elements: List[StrategyChild], existing_elements: List[StrategyChild])
      :staticmethod:


   .. method:: _change_part_flow(self, flow: StrategyFlow)


   .. method:: _set_parts_flow(flow: StrategyFlow, parts: Sequence[StrategyChild])
      :staticmethod:



.. py:class:: StrategyFlow(self_ref: Any, flow_name: str, root_group_name: str)

   Implementation of a strategy flow.

   A strategy flow describes the parts of a Continual Learning strategy.
   A parts is usually implemented as a class method of a strategy class.
   Parts can be joined in named groups, which makes it easier to define the
   flow and compose parts in higher-level nodes. Also, groups can be used to
   create loops (usually used to describe epochs or testing steps).

   Considering that parts are strategy class methods, parts are commonly used
   as callback mechanism (for instance "before_training",
   "after_training_epoch", etc.).

   Parts and groups can't be duplicated inside a flow.

   The two default flows are the training and testing flows, which are found
   in every strategy. Methods belonging to the training flow must be
   annotated using the @TrainingFlow decorator while methods belonging to the
   testing flow must be annotated with the @TestingFlow decorator. A method
   can be annotated with more than a flow decorator at the same time.

   Each strategy can also define plugins. Plugins are commonly used to
   modularize common reusable Continual Learning patterns such as multi-head
   management, rehearsal (a.k.a. replay), distillation, ... or even to attach
   the desired metrics system (accuracy, time, ram usage, confusion matrices,
   ...).

   The StrategyFlow is a callable object that, when executed, runs the
   described parts sequentially. Each call to the training flow executes an
   incremental training step on a "batch" (or "task") of new data while the
   testing flow will run an evaluation loop on the test sets. A strategy should
   implement the desired training and testing procedures as parts.

   Each part, being a class method, can define method parameters as usual.
   The flow will inject the correct parameter values by looking at different
   locations:
       - first, a parameter with the same name is searched in the arguments
       passed to the flow. Considering that a strategy part can call other
       parts (to provide a callback or to obtain results), parameters passed to
       previous method calls in the stack are searched for, too. The collection
       of those values is called "arguments namespace";
       - second, a global flow namespace exists where each part may publish its
       results. These values are stored and used for parameter injection and,
       like the arguments passed to the flow, they are discarded after each
       flow execution. Those values form the "results namespace". The good part
       of it is that this namespace is shared with plugins, which makes it
       easier to modularize some common behaviours. When a part publishes a
       result, values with the same name found in the first group are
       discarded;
       - third, fields of the strategy class or any of its attached plugins
       are searched for. This is called "self namespace". It goes without
       saying, those are the only namespace values that are persisted across
       different flow executions. Fields starting with "_" are not considered.
       Also, fields whose values are instances of "StrategyFlow" or "FlowGroup"
       are not considered, as they would pollute the namespace.

   All those values form a global namespace. For values with the same, elements
   or the first group take precedence over the ones in the second group. Values
   from the second group take precedence over the ones in the last group. This
   means that

   This mechanism ensures that any part can have total visibility over the
   state of the strategy.

   Creates a flow group.

   :param self_ref: The reference to the object this flow belongs to. This
       is usually the the strategy (or the plugin) object.
   :param flow_name: The name of the flow.
   :param root_group_name: The name of the root group.

   .. method:: append_part_list(self, parts: Sequence[StrategyChild], to_group: Optional[StrategyChildId] = None, after_part: Optional[StrategyChildId] = None, at_beginning: bool = False)

      Appends a list of parts to a flow group.

      A flow group is a sequence of parts semantically tied together. For
      instance "TrainingEpoch". Parts in a group are executed sequentially.

      :param parts: A list of parts to append to an existing group.
      :param to_group: The name of object reference to the group. Defaults to
          the root group.
      :param after_part: If not None, the parts list will be appended after
          the given part/group (described by name or reference).
      :param at_beginning: If True, the parts will be appended at the
          beginning of the group. Defaults to False, which means that parts
          will be appended at the end. Can't be True at the same time of the
          "after_part" parameter.
      :return: None.


   .. method:: append_new_group(self, group_name: str, parts: Sequence[StrategyChild], is_loop: bool = False, to_group: Optional[StrategyChildId] = None, after_part: Optional[StrategyChildId] = None, at_beginning: bool = False)

      Creates a new flow group.

      :param group_name: The group name.
      :param parts: A list of initial parts belonging to the group. Can be
          an empty list.
      :param is_loop: If True, the group will be flagged as a loop, which
          means that its parts will be executed in a loop until the last
          part returns False.
      :param to_group: Appends the newly created group to the group described
          (by name or reference) by this parameter. Defaults to None, which
          means that the root group is used.
      :param after_part: If not None, the group will be appended after
          the given part/group (described by name or reference).
      :param at_beginning: If True, the group will be appended at the
          beginning of the group. Defaults to False, which means that the
          group will be appended at the end. Can't be True at the same time
          of the "after_part" parameter.
      :return: The new group


   .. method:: remove_part(self, part_name: StrategyChildId)

      Removes a part (or group) from the flow.

      The part will be searched in any flow sub-group.
      :param part_name: The part name or reference.
      :return: The removed part.


   .. method:: replace_part(self, part_name: StrategyChildId, replacement: StrategyChild)

      Replaces a part with another.

      :param part_name: The part (by name or reference) to replace.
      :param replacement: The replacement.
      :return: The replaced part.


   .. method:: __call__(self, **kwargs)

      Executes this flow .

      :param kwargs: A dictionary of named parameters that will be passed
          to the parts of the strategy (see class description).
      :return: The return value of the last part.


   .. method:: is_running(self)

      Checks if this flow is running.

      :return: True if this flow is running, False otherwise.


   .. method:: add_part_change_listener(self, part_change_listener)

      Adds a flow listener.

      :param part_change_listener: The flow listener to attach. The listener
          will receive a callback each time a part is executed.
      :return: None


   .. method:: remove_part_change_listener(self, part_change_listener)

      Removes a flow listener.

      :param part_change_listener: The flow listener to remove.
      :return: None


   .. method:: add_strategy_plugin(self, plugin)

      Adds a plugin to the strategy.

      This will check the plugin for a flow with the same name. If a flow
      with the same name can't be found, an exception is raised. The flow
      found in the plugin is then instrumented to consider this instance as
      the root flow.

      :param plugin: The added plugin.
      :return: None


   .. method:: set_root_flow(self, root_flow)

      Sets the root flow.

      When a root flow is set, the current flow will delegate any operation
      to the root flow. This usually happens in plugins, where the root
      flow is the strategy one.

      :param root_flow: The root flow.
      :return: None


   .. method:: get_strategy_plugins(self)

      Returns a list of strategy plugins.

      :return: A list of plugins.


   .. method:: is_plugin_flow(self)

      Checks if this is a flow belonging to a plugin.

      That is, this returns True if a root flow is set.

      :return: True if this is a plugin flow, False if it's the main
          strategy object flow.


   .. method:: extract_self_namespace(self)

      Extracts the "self namespace" from the strategy object and any of its
      plugins. The namespace is then usually searched for when injecting
      parameter values of the parts.

      Simply put, the "self namespace" is the collection of class fields
      belonging to the strategy object and any of its plugins. Fields
      starting with and underscore "_" will be ignored. For more info, refer
      to the class documentation.

      :return: A dictionary containing the self namespace.


   .. method:: get_results_namespace(self)

      Returns the "results namespace". The namespace is then usually searched
      for when injecting parameter values of the parts.

      The results namespace is the namespace containing all the results
      published from any part of the strategy or its plugins. This
      namespace is cleaned up after each flow execution.

      For a result to be stored in the "results namespace", the part must
      publish it using the "update_results_namespace" method. However, it is
      recommended to use the "update_namespace" method provided by class
      :class:`StrategySkeleton`, which is easier to use.

      :return: A dictionary containing the results namespace.


   .. method:: update_results_namespace(self, update_dict)

      Updates the "results namespace".

      For a result to be stored in the "results namespace", the part must
      publish it using this method. However, it is recommended to use the
      "update_namespace" method provided by class :class:`StrategySkeleton`,
      which is easier to use.

      :param update_dict: The dictionary or named tuple to merge in the
          results namespace.
      :return: None


   .. method:: get_flattened_kwargs(self) -> Dict[str, Any]

      Gets the "arguments namespace". This dictionary is then usually
      searched for when injecting parameter values of the parts.

      For more info refer to the class documentation.

      This method looks at the whole call stack on previous strategy parts
      to gather all previous named parameters. Their values are then flattened
      (giving priority at values from the most recent call) in the single
      dictionary returned my this method.

      Not all parameter from previous part calls are included:

      -   Only parameters of part calls from the current call *stack* are
          included, which means that parameters from part calls that already
          returned are not included.
      -   Positional only parameters are not included, while "positional
          or keyword" or "keyword only" parameters are included.
      -   When the "result namespace" is updated using
          "update_results_namespace", any element of the "arguments namespace"
          with a name included in the update dictionary is eliminated (because
          part results take precedence over parameters from the call stack).
          For instance, consider a part that receives as an input a batch,
          executes a data augmentation procedure and returns it. Let's call
          this value "train_batch". It wouldn't make sense if, after that part
          call, the value of "train_batch" pointed to its previous,
          non-augmented, version. This is why result values take precedence
          over values from the arguments namespace.

      :return: The "arguments namespace". That is, a dictionary of keyword
          arguments form previous (stack) part calls.


   .. method:: push_kwargs(self, args_dict: Dict[str, Any]) -> None

      Pushes keyword arguments.

      This is usually automatically done when calling a part decorated
      for the current flow. This updates the "arguments namespace".

      :param args_dict: The keyword arguments.
      :return: None


   .. method:: pop_kwargs(self) -> None

      Pops keyword arguments.

      This is usually automatically done when returning from a part decorated
      for the current flow. This updates the "arguments namespace".

      :return: None


   .. method:: signal_internal_traceback(self, tb)

      Adds a traceback object to the ignore list.

      This is usually done to prevent the traceback from showing a huge list
      of internal decorator calls.

      :param tb: The traceback object to be ignored.
      :return: None


   .. method:: _update_namespace_using_return_value(self, update_dict)

      Updates the results namespace.

      :param update_dict: The dictionary or named tuple to merge in the
          results namespace.
      :return: The new results namespace.


   .. method:: _cleanup_traceback(self, tb)

      Cleanups the exception traceback.

      This is done to ensure that internal decorator called are not shown
      to the user.

      This method works in-place.

      :param tb: The traceback.
      :return: A cleaned up version of the traceback.


   .. method:: _extract_self_data(self)

      Extract all fields from the strategy and any plugin.

      Fields from the main strategy object take precedence over plugins
      ones.

      :return: A list of fields from the strategy and its plugins.


   .. method:: _remove_kwargs_from_stack(self, arg_names: Iterable[Any])

      Removes parameters from the call stack.

      This is used to remove elements from the "argument namespace", which
      has to be done when the "results namespace" is updated.

      :param arg_names: The names of the parameters.
      :return: None



