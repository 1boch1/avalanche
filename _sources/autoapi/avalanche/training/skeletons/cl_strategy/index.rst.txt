:mod:`avalanche.training.skeletons.cl_strategy`
===============================================

.. py:module:: avalanche.training.skeletons.cl_strategy


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   avalanche.training.skeletons.cl_strategy.IStrategy
   avalanche.training.skeletons.cl_strategy.StrategySkeleton
   avalanche.training.skeletons.cl_strategy.StrategyTemplate



.. py:class:: IStrategy

   Bases: :class:`typing.Protocol`

   Define the protocol for a strategy.

   A strategy is a class with train and test methods. Those methods must accept
   a step info object as the parameter. Moreover, the test method should allow
   the user to select which part (complete, cumulative, ...) of the test set
   should be considered by the testing phase.


   Create and return a new object.  See help(type) for accurate signature.

   .. method:: train(self, step_info: IStepInfo, **kwargs)

      Executes an incremental training step on the training data.

      This methods takes a "step_info" as a parameter. The "step_info"
      instance can be used to extract data relevant to the current training
      step, like the training dataset, the current task/batch id, any
      previous or future training or testing test, etc.

      :param step_info: The step info instance.
      :param kwargs: A list of strategy parameters.
      :return: Strategy specific.


   .. method:: test(self, step_info: IStepInfo, test_part: DatasetPart, **kwargs)

      Executes a testing procedure step on the testing data.

      This methods takes a "step_info" as a parameter. The "step_info"
      instance can be used to extract data relevant to the current testing
      step, like the test datasets, the current task/batch id, any
      previous or future training or testing test, etc.

      Beware that a dataset part flag must be passed as the second parameter
      (as a value of :class:`DatasetPart`). This flag controls whenever the
      user wants to test on all tasks/batches ("COMPLETE"), only on already
      encountered tasks/batches ("CUMULATIVE"), only on previous ones ("OLD"),
      on the current task/batch only ("CURRENT") or even on future
      tasks/batches ("FUTURE").

      The testing procedure must loop through the different test sets
      to obtain the relevant metrics.

      :param step_info: The step info instance.
      :param kwargs: A list of strategy parameters.
      :return: Strategy specific.



.. py:class:: StrategySkeleton

   Bases: :class:`avalanche.training.skeletons.cl_strategy.IStrategy`

   Defines the skeleton for a Continual Learning strategy.

   This skeleton introduces the "Training" and "Testing" flows, which are the
   two most commonly used flows. The training flow describes how the strategy
   runs an incremental training step on a new batch/task, while the testing
   flow defines the testing procedure.

   This class is usually not used directly. Consider using
   :class:`avalanche.training.strategies.DeepLearningStrategy` instead.

   This class also defines few utility methods to control the strategy
   lifecycle.

   Creates a strategy skeleton instance.

   .. method:: update_namespace(self, **update_dict)

      Updates the "results namespace" using the provided parameters.

      For more info refer to the class :class:`StrategyFlow` documentation.

      :param update_dict: The parameters used to update the "results
          namespace".
      :return: None.


   .. method:: is_training(self)

      Check if the training flow is running.
      :return: True if the training flow is running, False otherwise.


   .. method:: is_testing(self)

      Check if the testing flow is running.
      :return: True if the testing flow is running, False otherwise.


   .. method:: add_plugin(self, plugin: StrategySkeleton)

      Adds a plugin to this strategy.

      :param plugin: The plugin to add.
      :return: None



.. py:class:: StrategyTemplate

   Bases: :class:`avalanche.training.skeletons.cl_strategy.StrategySkeleton`

   Defines a common generic template for Continual Learning strategies.

   Being extremely generic, this template can also be used by non Deep
   Learning approaches.

   The training flow is simply divided in three parts: BeforeTraining,
   ModelTraining and AfterTraining. The only implemented facility for training
   is the extraction of the training dataset from the step_info and the
   creation of the DataLoader.

   The testing flow template is more complex as it involves managing a list
   of test subsets (usually one for each task/batch) obtained from step_info.
   By using this template as the  base class for a strategy, the procedures
   needed to loop through the  different test subsets are already implemented
   and integrated in the testing flow.

   Creates and instance of the Strategy Template.

   .. method:: make_train_dataset(self, step_info: IStepInfo)

      Returns the training dataset, given the step_info instance.

      This is a part of the training flow. Sets the train_dataset namespace
      value.

      :param step_info: The step info instance, as returned from the CL
          scenario.
      :return: The training dataset.


   .. method:: make_train_dataloader(self, train_dataset, num_workers=0, train_mb_size=1)

      Return a DataLoader initialized with the training dataset.

      This is a part of the training flow. Sets the train_data_loader
      namespace value.

      :param train_dataset: The training dataset. Usually set by the
          make_train_dataset method.
      :param num_workers: The number of workers to use. Defaults to 0.
          Usually set by the user when calling the train method of the
          strategy or as a strategy field.
      :param train_mb_size: The minibatch size. Defaults to 1. Usually set
          as a strategy field.
      :return: The DataLoader for the training set.


   .. method:: make_test_dataset(self, step_info: IStepInfo, step_id: int)

      Returns the test dataset, given the step_info instance and the
      identifier of the step (task/batch) to test.

      This is a part of the testing flow. Sets the test_dataset namespace
      value.

      :param step_info: The step info instance, as returned from the CL
          scenario.
      :param step_id: The ID of the step for which to obtain the test set.
      :return: The training dataset.


   .. method:: make_test_dataloader(self, test_dataset, num_workers=0, test_mb_size=1)

      Return a DataLoader initialized with the test dataset.

      This is a part of the testing flow. Sets the test_data_loader
      namespace value.

      :param test_dataset: The test dataset. Usually set by the
          make_test_dataset method.
      :param num_workers: The number of workers to use. Defaults to 0.
          Usually set by the user when calling the test method of the
          strategy or as a strategy field.
      :param test_mb_size: The minibatch size. Defaults to 1. Usually set
          as a strategy field.
      :return: The DataLoader for the test set.


   .. method:: set_initial_test_step_id(self, step_info: IStepInfo, dataset_part: DatasetPart = None)

      An internal method that sets the initial step_id for the testing flow.

      The initial step id depends on the dataset_part passed to the test
      method of the strategy.

      For the complete, cumulative and old parts, the initial step_id will be
      zero. For the future part, the step id will be the current step plus
      one. For the current part, step_id will be set to the current step id.

      :param step_info: The step info instance, as returned from the CL
          scenario.
      :param dataset_part: The dataset part to consider for testing (as passed
          to the test method of the strategy), as a value of
          :class:`DatasetPart`.
      :return: None


   .. method:: next_testing_step(self, step_id: int, step_info: IStepInfo, test_part: DatasetPart = None)

      Checks if another testing step has to be done and sets the step_id
      namespace value accordingly.

      :param step_id: The current test step id.
      :param step_info: The step info instance, as returned from the CL
          scenario.
      :param test_part: The dataset part to consider for testing (as passed
          to the test method of the strategy), as a value of
          :class:`DatasetPart`.
      :return: True, if other testing steps are to be executed. False
          otherwise.


   .. method:: has_testing_steps_left(self, step_id, step_info: IStepInfo, test_part: DatasetPart = None)

      Checks if another testing step has to be done.

      Doesn't set any namespace value.

      :param step_id: The current test step id.
      :param step_info: The step info instance, as returned from the CL
          scenario.
      :param test_part: The dataset part to consider for testing (as passed
          to the test method of the strategy), as a value of
          :class:`DatasetPart`.
      :return: True, if other testing steps are to be executed. False
          otherwise.


   .. method:: train(self, step_info: IStepInfo, **kwargs)

      Executes an incremental training step on the training data.

      This methods takes a "step_info" as a parameter. The "step_info"
      instance can be used to extract data relevant to the current training
      step, like the training dataset, the current task/batch id, any
      previous or future training or testing test, etc.

      :param step_info: The step info instance.
      :param kwargs: A list of strategy parameters.
      :return: Strategy specific.


   .. method:: test(self, step_info: IStepInfo, test_part: DatasetPart, **kwargs)

      Executes a testing procedure step on the testing data.

      This methods takes a "step_info" as a parameter. The "step_info"
      instance can be used to extract data relevant to the current testing
      step, like the test datasets, the current task/batch id, any
      previous or future training or testing test, etc.

      Beware that a dataset part flag must be passed as the second parameter
      (as a value of :class:`DatasetPart`). This flag controls whenever the
      user wants to test on all tasks/batches ("COMPLETE"), only on already
      encountered tasks/batches ("CUMULATIVE"), only on previous ones ("OLD"),
      on the current task/batch only ("CURRENT") or even on future
      tasks/batches ("FUTURE").

      The testing procedure must loop through the different test sets
      to obtain the relevant metrics.

      :param step_info: The step info instance.
      :param kwargs: A list of strategy parameters.
      :return: Strategy specific.



