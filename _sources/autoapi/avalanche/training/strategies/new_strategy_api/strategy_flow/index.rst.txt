:mod:`avalanche.training.strategies.new_strategy_api.strategy_flow`
===================================================================

.. py:module:: avalanche.training.strategies.new_strategy_api.strategy_flow


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   avalanche.training.strategies.new_strategy_api.strategy_flow.FlowGroup
   avalanche.training.strategies.new_strategy_api.strategy_flow.StrategyFlow



Functions
~~~~~~~~~

.. autoapisummary::

   avalanche.training.strategies.new_strategy_api.strategy_flow.make_strategy_part_decorator


.. data:: StrategyPart
   

   

.. data:: StrategyChild
   

   

.. data:: StrategyChildId
   

   

.. function:: make_strategy_part_decorator(flow_field: str)

   Factory for a strategy part decorator.

   :param flow_field: The name of the decorator.
   :return: A decorator that can be used to decorate class methods.


.. data:: TrainingFlow
   

   

.. data:: TestingFlow
   

   

.. py:class:: FlowGroup(flow: StrategyFlow, elements: List[StrategyChild], group_name: str, is_loop: bool = False)

   This class defines a flow group.

   Simply put, a flow group contains a sequence of parts that are executed
   one after another when the group's __call__ method is invoked. A FlowGroup
   can be  also flagged as a loop, which means that the last element of the
   parts sequence controls whenever the loops would stop or continue by
   returning True (continue) or False (break). Parts can be class methods
   (usually decorated with @TrainingFlow or @TestingFlow) or another FlowGroup.
   This means that flow groups are organized in a tree where methods are the
   leaves and flow groups are intermediate nodes.

   In a StrategyFlow can't exist parts with duplicate names. A name of a part
   is the method name for class methods or the FlowGroup name for FlowGroups.

   Creates a new flow group.

   :param flow: The flow this group belongs to.
   :param elements: The initial sequence of parts. Parts can be methods
       or other FlowGroups. No duplicate names are allowed.
   :param group_name: The group name. Must be unique through the entire
       StrategyFlow tree.
   :param is_loop: If True, the __call__ will loop through the parts
       until the last part return False.

   .. method:: __call__(self, *args, **kwargs)

      Executes the contained parts sequentially.

      If this group was created with the is_loop flag set as True, all parts
      will be executed in a loop until the last part returns False.
      :param args: Ignored
      :param kwargs: A dictionary of values to be set in the call namespace.
          Children parts that have any of these parameters in their method
          signature will get the relative value with the same name. This works
          very similar to a dependency injection.

          For instance, calling this group as "group(device="cpu")" will
          expose the "device" value to all children parts.

      :return: The return value of the last part. Please note that if this
          group is a loop, the return value will be True.


   .. method:: _append_elements(self, to_group: StrategyChildId, after_child: Optional[StrategyChildId], new_elements: List[StrategyChild], at_beginning: bool = False)


   .. method:: _replace(self, to_be_replaced: StrategyChildId, new_element: StrategyChild) -> StrategyChild


   .. method:: _remove(self, to_be_removed: StrategyChildId) -> StrategyChild


   .. method:: _update_child_names(self)


   .. method:: _check_compatibility(added_elements: List[StrategyChild], existing_elements: List[StrategyChild])
      :staticmethod:


   .. method:: _change_part_flow(self, flow: StrategyFlow)


   .. method:: _set_parts_flow(flow: StrategyFlow, parts: Sequence[StrategyChild])
      :staticmethod:



.. py:class:: StrategyFlow(self_ref: Any, flow_name: str, root_group_name: str)

   Implementation of a strategy flow.

   A strategy flow describes the parts of a Continual Learning strategy.
   A parts is usually implemented as a class method of a strategy class.
   Parts can be joined in named groups, which makes it easier to define the
   flow and compose parts in higher-level nodes. Also, groups can be used to
   create loops (usually used to describe epochs or testing steps).

   Considering that parts are strategy class methods, parts are commonly used
   as callback mechanism (for instance "before_training",
   "after_training_epoch", etc.).

   Parts and groups can't be duplicated inside a flow.

   The two default flows are the training and testing flows, which are found
   in every strategy. Methods belonging to the training flow must be
   annotated using the @TrainingFlow decorator while methods belonging to the
   testing flow must be annotated with the @TestingFlow decorator. A method
   can be annotated with more than a flow decorator at the same time.

   Each strategy can also define submodules. Submodules are commonly used to
   modularize common reusable Continual Learning patterns such as multi-head
   management, rehearsal (a.k.a. replay), distillation, ... or even to attach
   the desired metrics system (accuracy, time, ram usage, confusion matrices,
   ...).

   The StrategyFlow is a callable object that, when executed, runs the
   described parts sequentially. Each call to the training flow executes an
   incremental training step on a "batch" (or "task") of new data while the
   testing flow will run an evaluation loop on the test sets. A strategy should
   implement the desired training and testing procedures as parts.

   Each part, being a class method, can define method parameters as usual.
   The flow will inject the correct parameter values by looking at different
   locations:
       - first, a parameter with the same name is searched in the arguments
       passed to the flow. Considering that a strategy part can call other
       parts (to provide a callback or to obtain results), parameters passed to
       previous method calls in the stack are searched for, too. The collection
       of those values is called "arguments namespace";
       - second, a global flow namespace exists where each part may publish its
       results. These values are stored and used for parameter injection and,
       like the arguments passed to the flow, they are discarded after each
       flow execution. Those values form the "results namespace". The good part
       of it is that this namespace is shared with submodules, which makes it
       easier to modularize some common behaviours. When a part publishes a
       result, values with the same name found in the first group are
       discarded;
       - third, fields of the strategy class or any of its attached submodules
       are searched for. This is called "self namespace". It goes without
       saying, those are the only namespace values that are persisted across
       different flow executions. Fields starting with "_" are not considered.
       Also, fields whose values are instances of "StrategyFlow" or "FlowGroup"
       are not considered, as they would pollute the namespace.

   All those values form a global namespace. For values with the same, elements
   or the first group take precedence over the ones in the second group. Values
   from the second group take precedence over the ones in the last group. This
   means that

   This mechanism ensures that any part can have total visibility over the
   state of the strategy.

   Creates a flow group.

   :param self_ref: The reference to the object this flow belongs to. This
       is usually the the strategy (or the submodule) object.
   :param flow_name: The name of the flow.
   :param root_group_name: The name of the root group.

   .. method:: append_part_list(self, parts: Sequence[StrategyChild], to_group: Optional[StrategyChildId] = None, after_part: Optional[StrategyChildId] = None, at_beginning: bool = False)

      Appends a list of parts to a flow group.

      A flow group is a sequence of parts semantically tied together. For
      instance "TrainingEpoch". Parts in a group are executed sequentially.

      :param parts: A list of parts to append to an existing group.
      :param to_group: The name of object reference to the group. Defaults to
          the root group.
      :param after_part: If not None, the parts list will be appended after
          the given part/group (described by name or reference).
      :param at_beginning: If True, the parts will be appended at the
          beginning of the group. Defaults to False, which means that parts
          will be appended at the end. Can't be True at the same time of the
          "after_part" parameter.
      :return: None.


   .. method:: append_new_group(self, group_name: str, parts: Sequence[StrategyChild], is_loop: bool = False, to_group: Optional[StrategyChildId] = None, after_part: Optional[StrategyChildId] = None, at_beginning: bool = False)

      Creates a new flow group.

      :param group_name: The group name.
      :param parts: A list of initial parts belonging to the group. Can be
          an empty list.
      :param is_loop: If True, the group will be flagged as a loop, which
          means that its parts will be executed in a loop until the last
          part returns False.
      :param to_group: Appends the newly created group to the group described
          (by name or reference) by this parameter. Defaults to None, which
          means that the root group is used.
      :param after_part: If not None, the group will be appended after
          the given part/group (described by name or reference).
      :param at_beginning: If True, the group will be appended at the
          beginning of the group. Defaults to False, which means that the
          group will be appended at the end. Can't be True at the same time
          of the "after_part" parameter.
      :return: The new group


   .. method:: remove_part(self, part_name: StrategyChildId)

      Removes a part (or group) from the flow.

      The part will be searched in any flow sub-group.
      :param part_name: The part name or reference.
      :return: The removed part.


   .. method:: replace_part(self, part_name: StrategyChildId, replacement: StrategyChild)

      Replaces a part with another.

      :param part_name: The part (by name or reference) to replace.
      :param replacement: The replacement.
      :return: The replaced part.


   .. method:: __call__(self, **kwargs)

      Executes this flow .

      :param kwargs: A dictionary of named parameters that will be passed
          to the parts of the strategy (see class description).
      :return: The return value of the last part.


   .. method:: is_running(self)

      Checks if this flow is running.

      :return: True if this flow is running, False otherwise.


   .. method:: add_part_change_listener(self, part_change_listener)

      Adds a flow listener.

      :param part_change_listener: The flow listener to attach. The listener
          will receive a callback each time a part is executed.
      :return: None


   .. method:: remove_part_change_listener(self, part_change_listener)

      Removes a flow listener.

      :param part_change_listener: The flow listener to remove.
      :return: None


   .. method:: add_strategy_module(self, module)

      Adds a submodule to the strategy.

      This will check the submodule for a flow with the same name. If a flow
      with the same name can't be found, an exception is raised. The flow
      found in the submodule is then instrumented to consider this instance as
      the root flow.

      :param module: The added submodule.
      :return: None


   .. method:: set_root_flow(self, root_flow)

      Sets the root flow.

      When a root flow is set, the current flow will delegate any operation
      to the root flow. This usually happens in submodules, where the root
      flow is the strategy one.

      :param root_flow: The root flow.
      :return: None


   .. method:: get_strategy_submodules(self)

      Returns a list of strategy submodules.

      :return: A list of submodules.


   .. method:: is_submodule_flow(self)

      Checks if this is a flow belonging to a submodule.

      That is, this returns True if a root flow is set.

      :return: True if this is a submodule flow, False if it's the main
          strategy object flow.


   .. method:: extract_self_namespace(self)

      Extracts the "self namespace" from the strategy object and any of its
      submodules. The namespace is then usually searched for when injecting
      parameter values of the parts.

      Simply put, the "self namespace" is the collection of class fields
      belonging to the strategy object and any of its submodules. Fields
      starting with and underscore "_" will be ignored. For more info, refer
      to the class documentation.

      :return: A dictionary containing the self namespace.


   .. method:: get_results_namespace(self)

      Returns the "results namespace". The namespace is then usually searched
      for when injecting parameter values of the parts.

      The results namespace is the namespace containing all the results
      published from any part of the strategy or its submodules. This
      namespace is cleaned up after each flow execution.

      For a result to be stored in the "results namespace", the part must
      publish it using the "update_results_namespace" method. However, it is
      recommended to use the "update_namespace" method provided by class
      :class:`StrategySkeleton`, which is easier to use.

      :return: A dictionary containing the results namespace.


   .. method:: update_results_namespace(self, update_dict)

      Updates the "results namespace".

      For a result to be stored in the "results namespace", the part must
      publish it using this method. However, it is recommended to use the
      "update_namespace" method provided by class :class:`StrategySkeleton`,
      which is easier to use.

      :param update_dict: The dictionary or named tuple to merge in the
          results namespace.
      :return: None


   .. method:: get_flattened_kwargs(self) -> Dict[str, Any]

      Gets the "arguments namespace". This dictionary is then usually
      searched for when injecting parameter values of the parts.

      For more info refer to the class documentation.

      This method looks at the whole call stack on previous strategy parts
      to gather all previous named parameters. Their values are then flattened
      (giving priority at values from the most recent call) in the single
      dictionary returned my this method.

      Not all parameter from previous part calls are included:

      -   Only parameters of part calls from the current call *stack* are
          included, which means that parameters from part calls that already
          returned are not included.
      -   Positional only parameters are not included, while "positional
          or keyword" or "keyword only" parameters are included.
      -   When the "result namespace" is updated using
          "update_results_namespace", any element of the "arguments namespace"
          with a name included in the update dictionary is eliminated (because
          part results take precedence over parameters from the call stack).
          For instance, consider a part that receives as an input a batch,
          executes a data augmentation procedure and returns it. Let's call
          this value "train_batch". It wouldn't make sense if, after that part
          call, the value of "train_batch" pointed to its previous,
          non-augmented, version. This is why result values take precedence
          over values from the arguments namespace.

      :return: The "arguments namespace". That is, a dictionary of keyword
          arguments form previous (stack) part calls.


   .. method:: push_kwargs(self, args_dict: Dict[str, Any]) -> None

      Pushes keyword arguments.

      This is usually automatically done when calling a part decorated
      for the current flow. This updates the "arguments namespace".

      :param args_dict: The keyword arguments.
      :return: None


   .. method:: pop_kwargs(self) -> None

      Pops keyword arguments.

      This is usually automatically done when returning from a part decorated
      for the current flow. This updates the "arguments namespace".

      :return: None


   .. method:: signal_internal_traceback(self, tb)

      Adds a traceback object to the ignore list.

      This is usually done to prevent the traceback from showing a huge list
      of internal decorator calls.

      :param tb: The traceback object to be ignored.
      :return: None


   .. method:: _update_namespace_using_return_value(self, update_dict)

      Updates the results namespace.

      :param update_dict: The dictionary or named tuple to merge in the
          results namespace.
      :return: The new results namespace.


   .. method:: _cleanup_traceback(self, tb)

      Cleanups the exception traceback.

      This is done to ensure that internal decorator called are not shown
      to the user.

      This method works in-place.

      :param tb: The traceback.
      :return: A cleaned up version of the traceback.


   .. method:: _extract_self_data(self)

      Extract all fields from the strategy and any submodule.

      Fields from the main strategy object take precedence over submodules
      ones.

      :return: A list of fields from the strategy and its submodules.


   .. method:: _remove_kwargs_from_stack(self, arg_names: Iterable[Any])

      Removes parameters from the call stack.

      This is used to remove elements from the "argument namespace", which
      has to be done when the "results namespace" is updated.

      :param arg_names: The names of the parameters.
      :return: None



