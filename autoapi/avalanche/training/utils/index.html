

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>avalanche.training.utils &mdash; Avalanche 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/mystyle.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex/" />
    <link rel="search" title="Search" href="../../../../search/" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../" class="icon icon-home" alt="Documentation Home"> Avalanche
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Avalanche API:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../../">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche</span></code></a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../../#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../../benchmarks/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../evaluation/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.evaluation</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../extras/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.extras</span></code></a></li>
<li class="toctree-l4 current"><a class="reference internal" href="../"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.training</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../#package-contents">Package Contents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../#avalanche.__version__">__version__</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../">Avalanche</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../" class="icon icon-home"></a> &raquo;</li>
        
      <li><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.training.utils</span></code></li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../../_sources/autoapi/avalanche/training/utils/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-avalanche.training.utils">
<span id="avalanche-training-utils"></span><h1><a class="reference internal" href="#module-avalanche.training.utils" title="avalanche.training.utils"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.training.utils</span></code></a><a class="headerlink" href="#module-avalanche.training.utils" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="dataset_utils/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.training.utils.dataset_utils</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="transform_dataset/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.training.utils.transform_dataset</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="utils/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.training.utils.utils</span></code></a></li>
</ul>
</div>
</div>
<div class="section" id="package-contents">
<h2>Package Contents<a class="headerlink" href="#package-contents" title="Permalink to this headline">¶</a></h2>
<div class="section" id="classes">
<h3>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.training.utils.IDataset" title="avalanche.training.utils.IDataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IDataset</span></code></a></p></td>
<td><p>Protocol definition of a Dataset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.training.utils.IDatasetWithTargets" title="avalanche.training.utils.IDatasetWithTargets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IDatasetWithTargets</span></code></a></p></td>
<td><p>Protocol definition of a Dataset that has a valid targets field (like the</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.training.utils.IDatasetWithIntTargets" title="avalanche.training.utils.IDatasetWithIntTargets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IDatasetWithIntTargets</span></code></a></p></td>
<td><p>Protocol definition of a Dataset that has a valid targets field (like the</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.training.utils.DatasetWithTargets" title="avalanche.training.utils.DatasetWithTargets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DatasetWithTargets</span></code></a></p></td>
<td><p>Dataset that has a valid targets field (like the Datasets in the</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.training.utils.LazyClassMapping" title="avalanche.training.utils.LazyClassMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LazyClassMapping</span></code></a></p></td>
<td><p>This class is used when in need of lazy populating a targets field whose</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.training.utils.LazyConcatTargets" title="avalanche.training.utils.LazyConcatTargets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LazyConcatTargets</span></code></a></p></td>
<td><p>Defines a lazy targets concatenation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.training.utils.LazyTargetsConversion" title="avalanche.training.utils.LazyTargetsConversion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LazyTargetsConversion</span></code></a></p></td>
<td><p>Defines a lazy conversion of targets defined in some other format.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.training.utils.SubsetWithTargets" title="avalanche.training.utils.SubsetWithTargets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SubsetWithTargets</span></code></a></p></td>
<td><p>A Dataset that behaves like a PyTorch <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.utils.data.Subset</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.training.utils.ConcatDatasetWithTargets" title="avalanche.training.utils.ConcatDatasetWithTargets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConcatDatasetWithTargets</span></code></a></p></td>
<td><p>A Dataset that behaves like a PyTorch</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.training.utils.SequenceDataset" title="avalanche.training.utils.SequenceDataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SequenceDataset</span></code></a></p></td>
<td><p>A Dataset that wraps existing ndarrays, Tensors, lists… to provide</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.training.utils.TransformationDataset" title="avalanche.training.utils.TransformationDataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransformationDataset</span></code></a></p></td>
<td><p>A Dataset that applies transformations before returning patterns/targets.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.training.utils.TransformationSubset" title="avalanche.training.utils.TransformationSubset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransformationSubset</span></code></a></p></td>
<td><p>A Dataset that behaves like a PyTorch <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.utils.data.Subset</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.training.utils.TransformationConcatDataset" title="avalanche.training.utils.TransformationConcatDataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransformationConcatDataset</span></code></a></p></td>
<td><p>A Dataset that behaves like a PyTorch</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.training.utils.TransformationTensorDataset" title="avalanche.training.utils.TransformationTensorDataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransformationTensorDataset</span></code></a></p></td>
<td><p>A Dataset that wraps existing ndarrays, Tensors, lists… to provide</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.training.utils.get_accuracy" title="avalanche.training.utils.get_accuracy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_accuracy</span></code></a>(model, criterion, batch_size, test_x, test_y, test_it, device=None, mask=None)</p></td>
<td><p>Test accuracy given net and data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.training.utils.train_net" title="avalanche.training.utils.train_net"><code class="xref py py-obj docutils literal notranslate"><span class="pre">train_net</span></code></a>(optimizer, model, criterion, batch_size, train_x, train_y, train_it, device=None, mask=None)</p></td>
<td><p>Train net from memory using pytorch</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.training.utils.preprocess_imgs" title="avalanche.training.utils.preprocess_imgs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocess_imgs</span></code></a>(img_batch, scale=True, norm=True, channel_first=True)</p></td>
<td><p>Here we get a batch of PIL imgs and we return them normalized as for</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.training.utils.maybe_cuda" title="avalanche.training.utils.maybe_cuda"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maybe_cuda</span></code></a>(what, use_cuda=True, **kw)</p></td>
<td><p>Moves <cite>what</cite> to CUDA and returns it, if <cite>use_cuda</cite> and it’s available.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.training.utils.change_lr" title="avalanche.training.utils.change_lr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">change_lr</span></code></a>(optimizer, lr)</p></td>
<td><p>Change the learning rate of the optimizer</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.training.utils.set_classifier" title="avalanche.training.utils.set_classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_classifier</span></code></a>(model, weigth, bias, clas=None)</p></td>
<td><p>Change weights and biases of the last layer in the network.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.training.utils.reset_classifier" title="avalanche.training.utils.reset_classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset_classifier</span></code></a>(model, val=0, std=None)</p></td>
<td><p>Set weights and biases of the last layer in the network to zero.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.training.utils.shuffle_in_unison" title="avalanche.training.utils.shuffle_in_unison"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shuffle_in_unison</span></code></a>(dataset, seed=None, in_place=False)</p></td>
<td><p>Shuffle two (or more) list in unison. It’s important to shuffle the images</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.training.utils.softmax" title="avalanche.training.utils.softmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">softmax</span></code></a>(x)</p></td>
<td><p>Compute softmax values for each sets of scores in x.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.training.utils.count_lines" title="avalanche.training.utils.count_lines"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count_lines</span></code></a>(fpath)</p></td>
<td><p>Count line in file.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.training.utils.pad_data" title="avalanche.training.utils.pad_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pad_data</span></code></a>(dataset, mb_size)</p></td>
<td><p>Padding all the matrices contained in dataset to suit the mini-batch</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.training.utils.compute_one_hot" title="avalanche.training.utils.compute_one_hot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_one_hot</span></code></a>(train_y, class_count)</p></td>
<td><p>Compute one-hot from labels.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.training.utils.imagenet_batch_preproc" title="avalanche.training.utils.imagenet_batch_preproc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">imagenet_batch_preproc</span></code></a>(img_batch, rgb_swap=True, channel_first=True, avg_sub=True)</p></td>
<td><p>Pre-process batch of PIL img for Imagenet pre-trained models with caffe.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.training.utils.load_all_dataset" title="avalanche.training.utils.load_all_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_all_dataset</span></code></a>(dataset: Dataset, num_workers: int = 0)</p></td>
<td><p>Retrieves the contents of a whole dataset by using a DataLoader</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.training.utils.find_list_from_index" title="avalanche.training.utils.find_list_from_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_list_from_index</span></code></a>(pattern_idx: int, list_sizes: Sequence[int], max_size: int)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.training.utils.manage_advanced_indexing" title="avalanche.training.utils.manage_advanced_indexing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">manage_advanced_indexing</span></code></a>(idx, single_element_getter, max_length)</p></td>
<td><p>Utility function used to manage the advanced indexing and slicing.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.training.utils.concat_datasets_sequentially" title="avalanche.training.utils.concat_datasets_sequentially"><code class="xref py py-obj docutils literal notranslate"><span class="pre">concat_datasets_sequentially</span></code></a>(train_dataset_list: Sequence[IDatasetWithTargets[T_co]], test_dataset_list: Sequence[IDatasetWithTargets[T_co]]) → Tuple[TransformationConcatDataset[T_co], TransformationConcatDataset[T_co], List[list]]</p></td>
<td><p>Concatenates a list of datasets. This is completely different from</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.training.utils.as_transformation_dataset" title="avalanche.training.utils.as_transformation_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_transformation_dataset</span></code></a>(dataset: IDatasetWithTargets[T_co]) → TransformationDataset[T_co]</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.training.utils.train_test_transformation_datasets" title="avalanche.training.utils.train_test_transformation_datasets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">train_test_transformation_datasets</span></code></a>(train_dataset: IDatasetWithTargets[T_co], test_dataset: IDatasetWithTargets[T_co], train_transformation, test_transformation)</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt id="avalanche.training.utils.get_accuracy">
<code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">get_accuracy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">criterion</span></em>, <em class="sig-param"><span class="n">batch_size</span></em>, <em class="sig-param"><span class="n">test_x</span></em>, <em class="sig-param"><span class="n">test_y</span></em>, <em class="sig-param"><span class="n">test_it</span></em>, <em class="sig-param"><span class="n">device</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mask</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.get_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Test accuracy given net and data.</p>
</dd></dl>

<dl class="py function">
<dt id="avalanche.training.utils.train_net">
<code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">train_net</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">optimizer</span></em>, <em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">criterion</span></em>, <em class="sig-param"><span class="n">batch_size</span></em>, <em class="sig-param"><span class="n">train_x</span></em>, <em class="sig-param"><span class="n">train_y</span></em>, <em class="sig-param"><span class="n">train_it</span></em>, <em class="sig-param"><span class="n">device</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mask</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.train_net" title="Permalink to this definition">¶</a></dt>
<dd><p>Train net from memory using pytorch</p>
</dd></dl>

<dl class="py function">
<dt id="avalanche.training.utils.preprocess_imgs">
<code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">preprocess_imgs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img_batch</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">norm</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">channel_first</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.preprocess_imgs" title="Permalink to this definition">¶</a></dt>
<dd><p>Here we get a batch of PIL imgs and we return them normalized as for
the pytorch pre-trained models.</p>
</dd></dl>

<dl class="py function">
<dt id="avalanche.training.utils.maybe_cuda">
<code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">maybe_cuda</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">what</span></em>, <em class="sig-param"><span class="n">use_cuda</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.maybe_cuda" title="Permalink to this definition">¶</a></dt>
<dd><p>Moves <cite>what</cite> to CUDA and returns it, if <cite>use_cuda</cite> and it’s available.</p>
</dd></dl>

<dl class="py function">
<dt id="avalanche.training.utils.change_lr">
<code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">change_lr</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">optimizer</span></em>, <em class="sig-param"><span class="n">lr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.change_lr" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the learning rate of the optimizer</p>
</dd></dl>

<dl class="py function">
<dt id="avalanche.training.utils.set_classifier">
<code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">set_classifier</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">weigth</span></em>, <em class="sig-param"><span class="n">bias</span></em>, <em class="sig-param"><span class="n">clas</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.set_classifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Change weights and biases of the last layer in the network.</p>
</dd></dl>

<dl class="py function">
<dt id="avalanche.training.utils.reset_classifier">
<code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">reset_classifier</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">val</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">std</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.reset_classifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Set weights and biases of the last layer in the network to zero.</p>
</dd></dl>

<dl class="py function">
<dt id="avalanche.training.utils.shuffle_in_unison">
<code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">shuffle_in_unison</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dataset</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">in_place</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.shuffle_in_unison" title="Permalink to this definition">¶</a></dt>
<dd><p>Shuffle two (or more) list in unison. It’s important to shuffle the images
and the labels maintaining their correspondence.</p>
<dl class="field-list simple">
<dt class="field-odd">Args dataset</dt>
<dd class="field-odd"><p>list of shuffle with the same order.</p>
</dd>
<dt class="field-even">Args seed</dt>
<dd class="field-even"><p>set of fixed Cifar parameters.</p>
</dd>
<dt class="field-odd">Args in_place</dt>
<dd class="field-odd"><p>if we want to shuffle the same data or we want
to return a new shuffled dataset.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>train and test sets composed of images and labels, if in_place
is set to False.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.training.utils.softmax">
<code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">softmax</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.softmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute softmax values for each sets of scores in x.</p>
</dd></dl>

<dl class="py function">
<dt id="avalanche.training.utils.count_lines">
<code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">count_lines</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fpath</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.count_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Count line in file.</p>
</dd></dl>

<dl class="py function">
<dt id="avalanche.training.utils.pad_data">
<code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">pad_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dataset</span></em>, <em class="sig-param"><span class="n">mb_size</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.pad_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Padding all the matrices contained in dataset to suit the mini-batch
size. We assume they have the same shape.</p>
</dd></dl>

<dl class="py function">
<dt id="avalanche.training.utils.compute_one_hot">
<code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">compute_one_hot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_y</span></em>, <em class="sig-param"><span class="n">class_count</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.compute_one_hot" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute one-hot from labels.</p>
</dd></dl>

<dl class="py function">
<dt id="avalanche.training.utils.imagenet_batch_preproc">
<code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">imagenet_batch_preproc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img_batch</span></em>, <em class="sig-param"><span class="n">rgb_swap</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">channel_first</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">avg_sub</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.imagenet_batch_preproc" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-process batch of PIL img for Imagenet pre-trained models with caffe.
It may be need adjustements depending on the pre-trained model
since it is training dependent.</p>
</dd></dl>

<dl class="py function">
<dt id="avalanche.training.utils.load_all_dataset">
<code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">load_all_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dataset</span><span class="p">:</span> <span class="n">Dataset</span></em>, <em class="sig-param"><span class="n">num_workers</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.load_all_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the contents of a whole dataset by using a DataLoader</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset</strong> – The dataset</p></li>
<li><p><strong>num_workers</strong> – The number of workers the DataLoader should use.
Defaults to 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The content of the whole Dataset</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="avalanche.training.utils.IDataset">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">IDataset</code><a class="headerlink" href="#avalanche.training.utils.IDataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol[T_co]</span></code></p>
<p>Protocol definition of a Dataset.</p>
<p>Note: no __add__ method is defined.</p>
<dl class="py method">
<dt id="avalanche.training.utils.IDataset.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">index</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>T_co<span class="p">, </span>int<span class="p">]</span><a class="headerlink" href="#avalanche.training.utils.IDataset.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.IDataset.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#avalanche.training.utils.IDataset.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="avalanche.training.utils.IDatasetWithTargets">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">IDatasetWithTargets</code><a class="headerlink" href="#avalanche.training.utils.IDatasetWithTargets" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">IDataset[T_co]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Protocol</span></code></p>
<p>Protocol definition of a Dataset that has a valid targets field (like the
Datasets in the torchvision package).</p>
<p>Note: no __add__ method is defined.</p>
<p>Create and return a new object.  See help(type) for accurate signature.</p>
<dl class="py attribute">
<dt id="avalanche.training.utils.IDatasetWithTargets.targets">
<code class="sig-name descname">targets</code><em class="property"> :Sequence[SupportsInt]</em><a class="headerlink" href="#avalanche.training.utils.IDatasetWithTargets.targets" title="Permalink to this definition">¶</a></dt>
<dd><p>A sequence of ints or a PyTorch Tensor or a NumPy ndarray describing the
label of each pattern contained in the dataset.</p>
</dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.IDatasetWithTargets.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">index</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>T_co<span class="p">, </span>int<span class="p">]</span><a class="headerlink" href="#avalanche.training.utils.IDatasetWithTargets.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.IDatasetWithTargets.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#avalanche.training.utils.IDatasetWithTargets.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="avalanche.training.utils.IDatasetWithIntTargets">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">IDatasetWithIntTargets</code><a class="headerlink" href="#avalanche.training.utils.IDatasetWithIntTargets" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">IDatasetWithTargets[T_co]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Protocol</span></code></p>
<p>Protocol definition of a Dataset that has a valid targets field (like the
Datasets in the torchvision package) where the targets field is a sequence
of native ints.</p>
<p>Create and return a new object.  See help(type) for accurate signature.</p>
<dl class="py attribute">
<dt id="avalanche.training.utils.IDatasetWithIntTargets.targets">
<code class="sig-name descname">targets</code><em class="property"> :Sequence[int]</em><a class="headerlink" href="#avalanche.training.utils.IDatasetWithIntTargets.targets" title="Permalink to this definition">¶</a></dt>
<dd><p>A sequence of ints describing the label of each pattern contained in the
dataset.</p>
</dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.IDatasetWithIntTargets.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">index</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>T_co<span class="p">, </span>int<span class="p">]</span><a class="headerlink" href="#avalanche.training.utils.IDatasetWithIntTargets.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.IDatasetWithIntTargets.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#avalanche.training.utils.IDatasetWithIntTargets.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="avalanche.training.utils.DatasetWithTargets">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">DatasetWithTargets</code><a class="headerlink" href="#avalanche.training.utils.DatasetWithTargets" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">IDatasetWithIntTargets[T_co]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.utils.data.dataset.Dataset</span></code></p>
<p>Dataset that has a valid targets field (like the Datasets in the
torchvision package) where the targets field is a sequence of native ints.</p>
<p>The actual value of the targets field should be set by the child class.</p>
<dl class="py attribute">
<dt id="avalanche.training.utils.DatasetWithTargets.targets">
<code class="sig-name descname">targets</code><em class="property"> = []</em><a class="headerlink" href="#avalanche.training.utils.DatasetWithTargets.targets" title="Permalink to this definition">¶</a></dt>
<dd><p>A sequence of ints describing the label of each pattern contained in the
dataset.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="avalanche.training.utils.LazyClassMapping">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">LazyClassMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">targets</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>SupportsInt<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">indices</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">, </span>None<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">mapping</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.LazyClassMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence[int]</span></code></p>
<p>This class is used when in need of lazy populating a targets field whose
elements need to be filtered out (when subsetting, see
<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.utils.data.Subset</span></code>) and/or transformed (remapped). This will
allow for a more efficient memory usage as the conversion is done on the fly
instead of actually allocating a new targets list.</p>
<p>Initialize self.  See help(type(self)) for accurate signature.</p>
<dl class="py method">
<dt id="avalanche.training.utils.LazyClassMapping.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.LazyClassMapping.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.LazyClassMapping.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">item_idx</span></em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#avalanche.training.utils.LazyClassMapping.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.LazyClassMapping.__str__">
<code class="sig-name descname">__str__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.LazyClassMapping.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="avalanche.training.utils.LazyConcatTargets">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">LazyConcatTargets</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">targets_list</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>Sequence<span class="p">[</span>SupportsInt<span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.LazyConcatTargets" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence[int]</span></code></p>
<p>Defines a lazy targets concatenation.</p>
<p>This class is used when in need of lazy populating a targets created
as the concatenation of the targets field of multiple datasets.
This will allow for a more efficient memory usage as the concatenation is
done on the fly instead of actually allocating a new targets list.</p>
<p>Initialize self.  See help(type(self)) for accurate signature.</p>
<dl class="py method">
<dt id="avalanche.training.utils.LazyConcatTargets.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.LazyConcatTargets.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.LazyConcatTargets.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">item_idx</span></em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#avalanche.training.utils.LazyConcatTargets.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.LazyConcatTargets.__str__">
<code class="sig-name descname">__str__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.LazyConcatTargets.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="avalanche.training.utils.LazyTargetsConversion">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">LazyTargetsConversion</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">targets</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>SupportsInt<span class="p">]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.LazyTargetsConversion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence[int]</span></code></p>
<p>Defines a lazy conversion of targets defined in some other format.</p>
<p>Initialize self.  See help(type(self)) for accurate signature.</p>
<dl class="py method">
<dt id="avalanche.training.utils.LazyTargetsConversion.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.LazyTargetsConversion.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.LazyTargetsConversion.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">item_idx</span></em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#avalanche.training.utils.LazyTargetsConversion.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.LazyTargetsConversion.__str__">
<code class="sig-name descname">__str__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.LazyTargetsConversion.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="avalanche.training.utils.SubsetWithTargets">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">SubsetWithTargets</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dataset</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#avalanche.training.utils.IDatasetWithTargets" title="avalanche.training.utils.IDatasetWithTargets">IDatasetWithTargets</a><span class="p">[</span>T_co<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">indices</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">, </span>None<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">class_mapping</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.SubsetWithTargets" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">DatasetWithTargets[T_co]</span></code></p>
<p>A Dataset that behaves like a PyTorch <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.utils.data.Subset</span></code>.
However, this dataset also supports the targets field and class mapping.</p>
<dl class="py method">
<dt id="avalanche.training.utils.SubsetWithTargets.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.SubsetWithTargets.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.SubsetWithTargets.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#avalanche.training.utils.SubsetWithTargets.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="avalanche.training.utils.ConcatDatasetWithTargets">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">ConcatDatasetWithTargets</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">datasets</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span><a class="reference internal" href="#avalanche.training.utils.IDatasetWithTargets" title="avalanche.training.utils.IDatasetWithTargets">IDatasetWithTargets</a><span class="p">[</span>T_co<span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.ConcatDatasetWithTargets" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">DatasetWithTargets[T_co]</span></code></p>
<p>A Dataset that behaves like a PyTorch
<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.utils.data.ConcatDataset</span></code>. However, this dataset also
supports the targets field.</p>
<dl class="py method">
<dt id="avalanche.training.utils.ConcatDatasetWithTargets.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.ConcatDatasetWithTargets.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.ConcatDatasetWithTargets.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#avalanche.training.utils.ConcatDatasetWithTargets.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="avalanche.training.utils.SequenceDataset">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">SequenceDataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dataset_x</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>T_co<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">dataset_y</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>SupportsInt<span class="p">]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.SequenceDataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">DatasetWithTargets[T_co]</span></code></p>
<p>A Dataset that wraps existing ndarrays, Tensors, lists… to provide
basic Dataset functionalities. Very similar to TensorDataset.</p>
<p>Creates a <code class="docutils literal notranslate"><span class="pre">SequenceDataset</span></code> instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset_x</strong> – An sequence, Tensor or ndarray representing the X
values of the patterns.</p></li>
<li><p><strong>dataset_y</strong> – An sequence, Tensor int or ndarray of integers
representing the Y values of the patterns.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="avalanche.training.utils.SequenceDataset.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.SequenceDataset.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.SequenceDataset.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#avalanche.training.utils.SequenceDataset.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="avalanche.training.utils.find_list_from_index">
<code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">find_list_from_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern_idx</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">list_sizes</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>int<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">max_size</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.find_list_from_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="avalanche.training.utils.manage_advanced_indexing">
<code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">manage_advanced_indexing</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">idx</span></em>, <em class="sig-param"><span class="n">single_element_getter</span></em>, <em class="sig-param"><span class="n">max_length</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.manage_advanced_indexing" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function used to manage the advanced indexing and slicing.</p>
<p>If more than a pattern is selected, the X and Y values will be merged
in two separate torch Tensor objects using the stack operation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx</strong> – Either an in, a slice object or a list (including ndarrays and
torch Tensors) of indexes.</p></li>
<li><p><strong>single_element_getter</strong> – A callable used to obtain a single element
given its int index.</p></li>
<li><p><strong>max_length</strong> – The maximum sequence length.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tuple consisting of two tensors containing the X and Y values
of the patterns addressed by the idx parameter.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="avalanche.training.utils.TransformationDataset">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">TransformationDataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dataset</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#avalanche.training.utils.IDatasetWithTargets" title="avalanche.training.utils.IDatasetWithTargets">IDatasetWithTargets</a><span class="p">[</span>T_co<span class="p">]</span></span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">transform</span><span class="p">:</span> <span class="n">XTransform</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_transform</span><span class="p">:</span> <span class="n">YTransform</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">transform_groups</span><span class="p">:</span> <span class="n">Dict<span class="p">[</span>str<span class="p">, </span>Tuple<span class="p">[</span>XTransform<span class="p">, </span>YTransform<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_transform_group</span><span class="o">=</span><span class="default_value">'train'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.TransformationDataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">DatasetWithTargets[T_co]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Generic[T_co]</span></code></p>
<p>A Dataset that applies transformations before returning patterns/targets.
Also, this Dataset supports slicing and advanced indexing.</p>
<p>This dataset can also be used to apply several operations involving
transformations. For instance, it allows the user to add and replace
transformations, freeze them so that they can’t be changed, etc.</p>
<p>This dataset also allows the user to keep distinct transformations groups.
Simply put, a transformation group is a pair of transform+target_transform
(exactly as in torchvision datasets). This dataset natively supports keeping
two transformation groups: the first, ‘train’, contains transformations
applied to training patterns. Those transformations usually involve some
kind of data augmentation. The second one is ‘test’, that will contain
transformations applied to test patterns. Having both groups can be
useful when, for instance, in need to test on the training data (as this
process usually involves removing data augmentation operations). Switching
between transformations can be easily achieved by using the
<a class="reference internal" href="#avalanche.training.utils.TransformationDataset.train" title="avalanche.training.utils.TransformationDataset.train"><code class="xref py py-func docutils literal notranslate"><span class="pre">train()</span></code></a> and <a class="reference internal" href="#avalanche.training.utils.TransformationDataset.eval" title="avalanche.training.utils.TransformationDataset.eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> method.</p>
<p>However, consider that arbitrary groups can be used. For more info see
the constructor and the <a class="reference internal" href="#avalanche.training.utils.TransformationDataset.with_transforms" title="avalanche.training.utils.TransformationDataset.with_transforms"><code class="xref py py-func docutils literal notranslate"><span class="pre">with_transforms()</span></code></a> method.</p>
<p>Creates a <code class="docutils literal notranslate"><span class="pre">TransformationDataset</span></code> instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset</strong> – The dataset to decorate. Beware that
TransformationDataset will not overwrite transformations already
applied by this dataset.</p></li>
<li><p><strong>transform</strong> – A function/transform that takes the X value of a
pattern from the original dataset and returns a transformed version.</p></li>
<li><p><strong>target_transform</strong> – A function/transform that takes in the target
and transforms it.</p></li>
<li><p><strong>transform_groups</strong> – A dictionary containing the transform groups.
Transform groups are used to quickly switch between training and
test transformations. This becomes useful when in need to test on
the training dataset as test transformations usually don’t contain
random augmentations. <code class="docutils literal notranslate"><span class="pre">TransformDataset</span></code> natively supports the
‘train’ and ‘test’ groups by calling the <code class="docutils literal notranslate"><span class="pre">train()</span></code> and <code class="docutils literal notranslate"><span class="pre">eval()</span></code>
methods. When using custom groups one can use the
<code class="docutils literal notranslate"><span class="pre">with_transforms(group_name)</span></code> method instead. Defaults to None,
which means that the current transforms will be used to
handle both ‘train’ and ‘test’ groups (just like in standard
<code class="docutils literal notranslate"><span class="pre">torchvision</span></code> datasets).</p></li>
<li><p><strong>initial_transform_group</strong> – The name of the transform group
to be used. Defaults to ‘train’.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="avalanche.training.utils.TransformationDataset._dataset">
<code class="sig-name descname">_dataset</code><em class="property"> :IDatasetWithTargets[T_co]</em><a class="headerlink" href="#avalanche.training.utils.TransformationDataset._dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>The original dataset.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.training.utils.TransformationDataset.targets">
<code class="sig-name descname">targets</code><em class="property"> :Sequence[int]</em><a class="headerlink" href="#avalanche.training.utils.TransformationDataset.targets" title="Permalink to this definition">¶</a></dt>
<dd><p>A sequence of ints describing the label of each pattern contained in the
dataset.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.training.utils.TransformationDataset.current_transform_group">
<code class="sig-name descname">current_transform_group</code><a class="headerlink" href="#avalanche.training.utils.TransformationDataset.current_transform_group" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the transform group currently in use.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.training.utils.TransformationDataset.transform_groups">
<code class="sig-name descname">transform_groups</code><em class="property"> :Dict[str, Tuple[XTransform, YTransform]]</em><a class="headerlink" href="#avalanche.training.utils.TransformationDataset.transform_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary containing the transform groups. Transform groups are
used to quickly switch between training and test transformations.
This becomes useful when in need to test on the training dataset as test
transformations usually don’t contain random augmentations.</p>
<p>TransformDataset natively supports switching between the ‘train’ and
‘test’ groups by calling the <code class="docutils literal notranslate"><span class="pre">train()</span></code> and <code class="docutils literal notranslate"><span class="pre">eval()</span></code> methods. When
using custom groups one can use the <code class="docutils literal notranslate"><span class="pre">with_transforms(group_name)</span></code>
method instead.</p>
<p>May be null, which means that the current transforms will be used to
handle both ‘train’ and ‘test’ groups.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.training.utils.TransformationDataset.transform">
<code class="sig-name descname">transform</code><em class="property"> :XTransform</em><a class="headerlink" href="#avalanche.training.utils.TransformationDataset.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>A function/transform that takes in an PIL image and returns a
transformed version.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.training.utils.TransformationDataset.target_transform">
<code class="sig-name descname">target_transform</code><em class="property"> :YTransform</em><a class="headerlink" href="#avalanche.training.utils.TransformationDataset.target_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>A function/transform that takes in the target and transforms it.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.training.utils.TransformationDataset._frozen_transforms">
<code class="sig-name descname">_frozen_transforms</code><em class="property"> :Dict[str, Tuple[XTransform, YTransform]]</em><a class="headerlink" href="#avalanche.training.utils.TransformationDataset._frozen_transforms" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary containing frozen transformations.</p>
</dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.TransformationDataset.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.TransformationDataset.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset.train">
<code class="sig-name descname">train</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.TransformationDataset.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new dataset with the transformations of a the ‘train’ group
loaded.</p>
<p>The current dataset will not be affected.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new dataset with the training transformations loaded.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.TransformationDataset.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new dataset with the transformations of a the ‘test’ group
loaded.</p>
<p>Test transformations usually don’t contain augmentation procedures.
This function may be useful when in need to test on training data
(for instance, in order to run a validation pass).</p>
<p>The current dataset will not be affected.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new dataset with the test transformations loaded.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset.freeze_transforms">
<code class="sig-name descname">freeze_transforms</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n">TTransformationDataset</span></em><span class="sig-paren">)</span> &#x2192; TTransformationDataset<a class="headerlink" href="#avalanche.training.utils.TransformationDataset.freeze_transforms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new dataset where the current transformations are frozen.</p>
<p>Frozen transformations will be permanently glued to the original
dataset so that they can’t be changed anymore. This is usually done
when using transformations to create derived datasets: in this way
freezing the transformations will ensure that the user won’t be able
to inadvertently change them by directly setting the transformations
field or by using the other transformations utility methods like
<code class="docutils literal notranslate"><span class="pre">replace_transforms</span></code>. Please note that transformations of all groups
will be frozen. If you want to freeze a specific group, please use
<code class="docutils literal notranslate"><span class="pre">freeze_group_transforms</span></code>.</p>
<p>The current dataset will not be affected.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new dataset with the current transformations frozen.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset.freeze_group_transforms">
<code class="sig-name descname">freeze_group_transforms</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n">TTransformationDataset</span></em>, <em class="sig-param"><span class="n">group_name</span><span class="p">:</span> <span class="n">str</span></em><span class="sig-paren">)</span> &#x2192; TTransformationDataset<a class="headerlink" href="#avalanche.training.utils.TransformationDataset.freeze_group_transforms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new dataset where the transformations for a specific group
are frozen.</p>
<p>Frozen transformations will be permanently glued to the original
dataset so that they can’t be changed anymore. This is usually done
when using transformations to create derived datasets: in this way
freezing the transformations will ensure that the user won’t be able
to inadvertently change them by directly setting the transformations
field or by using the other transformations utility methods like
<code class="docutils literal notranslate"><span class="pre">replace_transforms</span></code>. To freeze transformations of all groups
please use <code class="docutils literal notranslate"><span class="pre">freeze_transforms</span></code>.</p>
<p>The current dataset will not be affected.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A new dataset with the transformations frozen for the given
group.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset.add_transforms">
<code class="sig-name descname">add_transforms</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n">TTransformationDataset</span></em>, <em class="sig-param"><span class="n">transform</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>T_co<span class="p">]</span><span class="p">, </span>Any<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_transform</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>int<span class="p">]</span><span class="p">, </span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; TTransformationDataset<a class="headerlink" href="#avalanche.training.utils.TransformationDataset.add_transforms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new dataset with the given transformations added to
the existing ones.</p>
<p>The transformations will be added to the current transformations group.
Other transformation groups will not be affected.</p>
<p>The given transformations will be added “at the end” of previous
transformations of the current transformations group. This means
that existing transformations will be applied to the patterns first.</p>
<p>The current dataset will not be affected.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transform</strong> – A function/transform that takes the X value of a
pattern from the original dataset and returns a transformed version.</p></li>
<li><p><strong>target_transform</strong> – A function/transform that takes in the target
and transforms it.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new dataset with the added transformations.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset.replace_transforms">
<code class="sig-name descname">replace_transforms</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n">TTransformationDataset</span></em>, <em class="sig-param"><span class="n">transform</span><span class="p">:</span> <span class="n">XTransform</span></em>, <em class="sig-param"><span class="n">target_transform</span><span class="p">:</span> <span class="n">YTransform</span></em><span class="sig-paren">)</span> &#x2192; TTransformationDataset<a class="headerlink" href="#avalanche.training.utils.TransformationDataset.replace_transforms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new dataset with the existing transformations replaced with
the given ones.</p>
<p>The given transformations will replace the ones of the current
transformations group. Other transformation groups will not be affected.</p>
<p>If this dataset was created with <code class="docutils literal notranslate"><span class="pre">chain_transformations</span></code> set to True
and if the original dataset is an instance of
<a class="reference internal" href="#avalanche.training.utils.TransformationDataset" title="avalanche.training.utils.TransformationDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformationDataset</span></code></a>, then the transformations of the
original set will be overwritten as well. This operation will create a
copy of this dataset.</p>
<p>The current dataset will not be affected.</p>
<p>Note that this function will not override frozen transformations. This
will also not affect transformations found in datasets that are not
instances of <a class="reference internal" href="#avalanche.training.utils.TransformationDataset" title="avalanche.training.utils.TransformationDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformationDataset</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transform</strong> – A function/transform that takes the X value of a
pattern from the original dataset and returns a transformed version.</p></li>
<li><p><strong>target_transform</strong> – A function/transform that takes in the target
and transforms it.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new dataset with the new transformations.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset.with_transforms">
<code class="sig-name descname">with_transforms</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n">TTransformationDataset</span></em>, <em class="sig-param"><span class="n">group_name</span><span class="p">:</span> <span class="n">str</span></em><span class="sig-paren">)</span> &#x2192; TTransformationDataset<a class="headerlink" href="#avalanche.training.utils.TransformationDataset.with_transforms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new dataset with the transformations of a different group
loaded.</p>
<p>The current dataset will not be affected.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>group_name</strong> – The name of the transformations group to use.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new dataset with the new transformations.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset.add_transforms_group">
<code class="sig-name descname">add_transforms_group</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n">TTransformationDataset</span></em>, <em class="sig-param"><span class="n">group_name</span><span class="p">:</span> <span class="n">str</span></em>, <em class="sig-param"><span class="n">transform</span><span class="p">:</span> <span class="n">XTransform</span></em>, <em class="sig-param"><span class="n">target_transform</span><span class="p">:</span> <span class="n">YTransform</span></em><span class="sig-paren">)</span> &#x2192; TTransformationDataset<a class="headerlink" href="#avalanche.training.utils.TransformationDataset.add_transforms_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new dataset with a new transformations group.</p>
<p>The current dataset will not be affected.</p>
<p>This method raises an exception if a group with the same name already
exists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group_name</strong> – The name of the new transformations group.</p></li>
<li><p><strong>transform</strong> – A function/transform that takes the X value of a
pattern from the original dataset and returns a transformed version.</p></li>
<li><p><strong>target_transform</strong> – A function/transform that takes in the target
and transforms it.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new dataset with the new transformations.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset._fork_dataset">
<code class="sig-name descname">_fork_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n">TTransformationDataset</span></em><span class="sig-paren">)</span> &#x2192; TTransformationDataset<a class="headerlink" href="#avalanche.training.utils.TransformationDataset._fork_dataset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset._freeze_dataset_group">
<em class="property">static </em><code class="sig-name descname">_freeze_dataset_group</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dataset_copy</span><span class="p">:</span> <span class="n">TTransformationDataset</span></em>, <em class="sig-param"><span class="n">group_name</span><span class="p">:</span> <span class="n">str</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.TransformationDataset._freeze_dataset_group" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset._get_single_item">
<code class="sig-name descname">_get_single_item</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">idx</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.TransformationDataset._get_single_item" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset._apply_transforms">
<code class="sig-name descname">_apply_transforms</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">pattern</span><span class="p">:</span> <span class="n">T_co</span></em>, <em class="sig-param"><span class="n">label</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.TransformationDataset._apply_transforms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset._check_groups_dict_format">
<em class="property">static </em><code class="sig-name descname">_check_groups_dict_format</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">groups_dict</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.TransformationDataset._check_groups_dict_format" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset._initialize_groups_dict">
<code class="sig-name descname">_initialize_groups_dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">transform_groups</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Tuple<span class="p">[</span>XTransform<span class="p">, </span>YTransform<span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">dataset</span><span class="p">:</span> <span class="n">Any</span></em>, <em class="sig-param"><span class="n">transform</span><span class="p">:</span> <span class="n">XTransform</span></em>, <em class="sig-param"><span class="n">target_transform</span><span class="p">:</span> <span class="n">YTransform</span></em><span class="sig-paren">)</span> &#x2192; Dict<span class="p">[</span>str<span class="p">, </span>Tuple<span class="p">[</span>XTransform<span class="p">, </span>YTransform<span class="p">]</span><span class="p">]</span><a class="headerlink" href="#avalanche.training.utils.TransformationDataset._initialize_groups_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple helper method that tries to fill the ‘train’ and ‘test’
groups as those two groups must always exist.</p>
<p>If no transform_groups are passed to the class constructor, then
the transform and target_transform parameters are used for both groups.</p>
<p>If train transformations are set and test transformations are not, then
train transformations will be used for the test group.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset</strong> – The original dataset. Will be used to detect existing
groups.</p></li>
<li><p><strong>transform</strong> – The transformation passed as a parameter to the
class constructor.</p></li>
<li><p><strong>target_transform</strong> – The target transformation passed as a parameter
to the class constructor.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset._initialize_targets_sequence">
<code class="sig-name descname">_initialize_targets_sequence</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">dataset</span></em><span class="sig-paren">)</span> &#x2192; Sequence<span class="p">[</span>int<span class="p">]</span><a class="headerlink" href="#avalanche.training.utils.TransformationDataset._initialize_targets_sequence" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset._set_original_dataset_transform_group">
<code class="sig-name descname">_set_original_dataset_transform_group</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">group_name</span><span class="p">:</span> <span class="n">str</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#avalanche.training.utils.TransformationDataset._set_original_dataset_transform_group" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset._freeze_original_dataset">
<code class="sig-name descname">_freeze_original_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">group_name</span><span class="p">:</span> <span class="n">str</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#avalanche.training.utils.TransformationDataset._freeze_original_dataset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset._replace_original_dataset_group">
<code class="sig-name descname">_replace_original_dataset_group</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">transform</span><span class="p">:</span> <span class="n">XTransform</span></em>, <em class="sig-param"><span class="n">target_transform</span><span class="p">:</span> <span class="n">YTransform</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#avalanche.training.utils.TransformationDataset._replace_original_dataset_group" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset._add_original_dataset_group">
<code class="sig-name descname">_add_original_dataset_group</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">group_name</span><span class="p">:</span> <span class="n">str</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#avalanche.training.utils.TransformationDataset._add_original_dataset_group" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationDataset._add_groups_from_original_dataset">
<code class="sig-name descname">_add_groups_from_original_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">dataset</span></em>, <em class="sig-param"><span class="n">transform_groups</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#avalanche.training.utils.TransformationDataset._add_groups_from_original_dataset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="avalanche.training.utils.TransformationSubset">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">TransformationSubset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dataset</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#avalanche.training.utils.IDatasetWithTargets" title="avalanche.training.utils.IDatasetWithTargets">IDatasetWithTargets</a><span class="p">[</span>T_co<span class="p">]</span></span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">indices</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">class_mapping</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">transform</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>T_co<span class="p">]</span><span class="p">, </span>Any<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_transform</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>int<span class="p">]</span><span class="p">, </span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">transform_groups</span><span class="p">:</span> <span class="n">Dict<span class="p">[</span>str<span class="p">, </span>Tuple<span class="p">[</span>XTransform<span class="p">, </span>YTransform<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_transform_group</span><span class="o">=</span><span class="default_value">'train'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.TransformationSubset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">TransformationDataset[T_co]</span></code></p>
<p>A Dataset that behaves like a PyTorch <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.utils.data.Subset</span></code>.
This Dataset also supports transformations, slicing, advanced indexing,
the targets field and class mapping.</p>
<p>Creates a <code class="docutils literal notranslate"><span class="pre">TransformationSubset</span></code> instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset</strong> – The whole dataset.</p></li>
<li><p><strong>indices</strong> – Indices in the whole set selected for subset. Can
be None, which means that the whole dataset will be returned.</p></li>
<li><p><strong>class_mapping</strong> – A list that, for each possible target (Y) value,
contains its corresponding remapped value. Can be None.</p></li>
<li><p><strong>transform</strong> – A function/transform that takes the X value of a
pattern from the original dataset and returns a transformed version.</p></li>
<li><p><strong>target_transform</strong> – A function/transform that takes in the target
and transforms it.</p></li>
<li><p><strong>transform_groups</strong> – A dictionary containing the transform groups.
Transform groups are used to quickly switch between training and
test transformations. This becomes useful when in need to test on
the training dataset as test transformations usually don’t contain
random augmentations. <code class="docutils literal notranslate"><span class="pre">TransformDataset</span></code> natively supports the
‘train’ and ‘test’ groups by calling the <code class="docutils literal notranslate"><span class="pre">train()</span></code> and <code class="docutils literal notranslate"><span class="pre">eval()</span></code>
methods. When using custom groups one can use the
<code class="docutils literal notranslate"><span class="pre">with_transforms(group_name)</span></code> method instead. Defaults to None,
which means that the current transforms will be used to
handle both ‘train’ and ‘test’ groups (just like in standard
<code class="docutils literal notranslate"><span class="pre">torchvision</span></code> datasets).</p></li>
<li><p><strong>initial_transform_group</strong> – The name of the transform group
to be used. Defaults to ‘train’.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="avalanche.training.utils.TransformationConcatDataset">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">TransformationConcatDataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">datasets</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span><a class="reference internal" href="#avalanche.training.utils.IDatasetWithTargets" title="avalanche.training.utils.IDatasetWithTargets">IDatasetWithTargets</a><span class="p">[</span>T_co<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">transform</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>T_co<span class="p">]</span><span class="p">, </span>Any<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_transform</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>int<span class="p">]</span><span class="p">, </span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">transform_groups</span><span class="p">:</span> <span class="n">Dict<span class="p">[</span>str<span class="p">, </span>Tuple<span class="p">[</span>XTransform<span class="p">, </span>YTransform<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_transform_group</span><span class="o">=</span><span class="default_value">'train'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.TransformationConcatDataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">TransformationDataset[T_co]</span></code></p>
<p>A Dataset that behaves like a PyTorch
<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.utils.data.ConcatDataset</span></code>. However, this Dataset also supports
transformations, slicing, advanced indexing and the targets field.</p>
<p>This dataset guarantees that the operations involving the transformations
and transformations groups are consistent across the concatenated dataset
(if they are subclasses of <a class="reference internal" href="#avalanche.training.utils.TransformationDataset" title="avalanche.training.utils.TransformationDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformationDataset</span></code></a>).</p>
<p>Creates a <code class="docutils literal notranslate"><span class="pre">TransformationConcatDataset</span></code> instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>datasets</strong> – An sequence of datasets.</p></li>
<li><p><strong>transform</strong> – A function/transform that takes the X value of a
pattern from the original dataset and returns a transformed version.</p></li>
<li><p><strong>target_transform</strong> – A function/transform that takes in the target
and transforms it.</p></li>
<li><p><strong>transform_groups</strong> – A dictionary containing the transform groups.
Transform groups are used to quickly switch between training and
test transformations. This becomes useful when in need to test on
the training dataset as test transformations usually don’t contain
random augmentations. <code class="docutils literal notranslate"><span class="pre">TransformDataset</span></code> natively supports the
‘train’ and ‘test’ groups by calling the <code class="docutils literal notranslate"><span class="pre">train()</span></code> and <code class="docutils literal notranslate"><span class="pre">eval()</span></code>
methods. When using custom groups one can use the
<code class="docutils literal notranslate"><span class="pre">with_transforms(group_name)</span></code> method instead. Defaults to None,
which means that the current transforms will be used to
handle both ‘train’ and ‘test’ groups (just like in standard
<code class="docutils literal notranslate"><span class="pre">torchvision</span></code> datasets).</p></li>
<li><p><strong>initial_transform_group</strong> – The name of the transform group
to be used. Defaults to ‘train’.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="avalanche.training.utils.TransformationConcatDataset.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#avalanche.training.utils.TransformationConcatDataset.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationConcatDataset._get_single_item">
<code class="sig-name descname">_get_single_item</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">idx</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.TransformationConcatDataset._get_single_item" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationConcatDataset._fork_dataset">
<code class="sig-name descname">_fork_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n">TTransformationDataset</span></em><span class="sig-paren">)</span> &#x2192; TTransformationDataset<a class="headerlink" href="#avalanche.training.utils.TransformationConcatDataset._fork_dataset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationConcatDataset._initialize_targets_sequence">
<code class="sig-name descname">_initialize_targets_sequence</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">dataset</span></em><span class="sig-paren">)</span> &#x2192; Sequence<span class="p">[</span>int<span class="p">]</span><a class="headerlink" href="#avalanche.training.utils.TransformationConcatDataset._initialize_targets_sequence" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationConcatDataset._set_original_dataset_transform_group">
<code class="sig-name descname">_set_original_dataset_transform_group</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">group_name</span><span class="p">:</span> <span class="n">str</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#avalanche.training.utils.TransformationConcatDataset._set_original_dataset_transform_group" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationConcatDataset._freeze_original_dataset">
<code class="sig-name descname">_freeze_original_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">group_name</span><span class="p">:</span> <span class="n">str</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#avalanche.training.utils.TransformationConcatDataset._freeze_original_dataset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationConcatDataset._replace_original_dataset_group">
<code class="sig-name descname">_replace_original_dataset_group</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">transform</span><span class="p">:</span> <span class="n">XTransform</span></em>, <em class="sig-param"><span class="n">target_transform</span><span class="p">:</span> <span class="n">YTransform</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#avalanche.training.utils.TransformationConcatDataset._replace_original_dataset_group" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationConcatDataset._add_original_dataset_group">
<code class="sig-name descname">_add_original_dataset_group</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">group_name</span><span class="p">:</span> <span class="n">str</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#avalanche.training.utils.TransformationConcatDataset._add_original_dataset_group" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationConcatDataset._add_groups_from_original_dataset">
<code class="sig-name descname">_add_groups_from_original_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">dataset</span></em>, <em class="sig-param"><span class="n">transform_groups</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#avalanche.training.utils.TransformationConcatDataset._add_groups_from_original_dataset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.training.utils.TransformationConcatDataset._adapt_concat_datasets">
<code class="sig-name descname">_adapt_concat_datasets</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.TransformationConcatDataset._adapt_concat_datasets" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="avalanche.training.utils.TransformationTensorDataset">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">TransformationTensorDataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dataset_x</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>T_co<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">dataset_y</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>SupportsInt<span class="p">]</span></span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">transform</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>T_co<span class="p">]</span><span class="p">, </span>Any<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_transform</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>int<span class="p">]</span><span class="p">, </span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">transform_groups</span><span class="p">:</span> <span class="n">Dict<span class="p">[</span>str<span class="p">, </span>Tuple<span class="p">[</span>XTransform<span class="p">, </span>YTransform<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">initial_transform_group</span><span class="o">=</span><span class="default_value">'train'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.TransformationTensorDataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">TransformationDataset[T_co]</span></code></p>
<p>A Dataset that wraps existing ndarrays, Tensors, lists… to provide
basic Dataset functionalities. Very similar to TensorDataset from PyTorch,
this Dataset also supports transformations, slicing, advanced indexing and
the targets field.</p>
<p>Creates a <code class="docutils literal notranslate"><span class="pre">TransformationTensorDataset</span></code> instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset_x</strong> – An sequence, Tensor or ndarray representing the X
values of the patterns.</p></li>
<li><p><strong>dataset_y</strong> – An sequence, Tensor int or ndarray of integers
representing the Y values of the patterns.</p></li>
<li><p><strong>transform</strong> – A function/transform that takes in a single element
from the <code class="docutils literal notranslate"><span class="pre">dataset_x</span></code> sequence and returns a transformed version.</p></li>
<li><p><strong>target_transform</strong> – A function/transform that takes in the target
and transforms it.</p></li>
<li><p><strong>transform_groups</strong> – A dictionary containing the transform groups.
Transform groups are used to quickly switch between training and
test transformations. This becomes useful when in need to test on
the training dataset as test transformations usually don’t contain
random augmentations. <code class="docutils literal notranslate"><span class="pre">TransformDataset</span></code> natively supports the
‘train’ and ‘test’ groups by calling the <code class="docutils literal notranslate"><span class="pre">train()</span></code> and <code class="docutils literal notranslate"><span class="pre">eval()</span></code>
methods. When using custom groups one can use the
<code class="docutils literal notranslate"><span class="pre">with_transforms(group_name)</span></code> method instead. Defaults to None,
which means that the current transforms will be used to
handle both ‘train’ and ‘test’ groups (just like in standard
<code class="docutils literal notranslate"><span class="pre">torchvision</span></code> datasets).</p></li>
<li><p><strong>initial_transform_group</strong> – The name of the transform group
to be used. Defaults to ‘train’.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.training.utils.concat_datasets_sequentially">
<code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">concat_datasets_sequentially</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset_list</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span><a class="reference internal" href="#avalanche.training.utils.IDatasetWithTargets" title="avalanche.training.utils.IDatasetWithTargets">IDatasetWithTargets</a><span class="p">[</span>T_co<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">test_dataset_list</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span><a class="reference internal" href="#avalanche.training.utils.IDatasetWithTargets" title="avalanche.training.utils.IDatasetWithTargets">IDatasetWithTargets</a><span class="p">[</span>T_co<span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span><a class="reference internal" href="#avalanche.training.utils.TransformationConcatDataset" title="avalanche.training.utils.TransformationConcatDataset">TransformationConcatDataset</a><span class="p">[</span>T_co<span class="p">]</span><span class="p">, </span><a class="reference internal" href="#avalanche.training.utils.TransformationConcatDataset" title="avalanche.training.utils.TransformationConcatDataset">TransformationConcatDataset</a><span class="p">[</span>T_co<span class="p">]</span><span class="p">, </span>List<span class="p">[</span>list<span class="p">]</span><span class="p">]</span><a class="headerlink" href="#avalanche.training.utils.concat_datasets_sequentially" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates a list of datasets. This is completely different from
<code class="xref py py-class docutils literal notranslate"><span class="pre">ConcatDataset</span></code>, in which datasets are merged together without
other processing. Instead, this function re-maps the datasets class IDs.
For instance:
let the dataset[0] contain patterns of 3 different classes,
let the dataset[1] contain patterns of 2 different classes, then class IDs
will be mapped as follows:</p>
<p>dataset[0] class “0” -&gt; new class ID is “0”</p>
<p>dataset[0] class “1” -&gt; new class ID is “1”</p>
<p>dataset[0] class “2” -&gt; new class ID is “2”</p>
<p>dataset[1] class “0” -&gt; new class ID is “3”</p>
<p>dataset[1] class “1” -&gt; new class ID is “4”</p>
<p>… -&gt; …</p>
<p>dataset[-1] class “C-1” -&gt; new class ID is “overall_n_classes-1”</p>
<p>In contrast, using PyTorch ConcatDataset:</p>
<p>dataset[0] class “0” -&gt; ID is “0”</p>
<p>dataset[0] class “1” -&gt; ID is “1”</p>
<p>dataset[0] class “2” -&gt; ID is “2”</p>
<p>dataset[1] class “0” -&gt; ID is “0”</p>
<p>dataset[1] class “1” -&gt; ID is “1”</p>
<p>Note: <code class="docutils literal notranslate"><span class="pre">train_dataset_list</span></code> and <code class="docutils literal notranslate"><span class="pre">test_dataset_list</span></code> must have the same
number of datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset_list</strong> – A list of training datasets</p></li>
<li><p><strong>test_dataset_list</strong> – A list of test datasets</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A concatenated dataset.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.training.utils.as_transformation_dataset">
<code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">as_transformation_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dataset</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#avalanche.training.utils.IDatasetWithTargets" title="avalanche.training.utils.IDatasetWithTargets">IDatasetWithTargets</a><span class="p">[</span>T_co<span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.training.utils.TransformationDataset" title="avalanche.training.utils.TransformationDataset">TransformationDataset</a><span class="p">[</span>T_co<span class="p">]</span><a class="headerlink" href="#avalanche.training.utils.as_transformation_dataset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="avalanche.training.utils.train_test_transformation_datasets">
<code class="sig-prename descclassname">avalanche.training.utils.</code><code class="sig-name descname">train_test_transformation_datasets</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#avalanche.training.utils.IDatasetWithTargets" title="avalanche.training.utils.IDatasetWithTargets">IDatasetWithTargets</a><span class="p">[</span>T_co<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">test_dataset</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#avalanche.training.utils.IDatasetWithTargets" title="avalanche.training.utils.IDatasetWithTargets">IDatasetWithTargets</a><span class="p">[</span>T_co<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">train_transformation</span></em>, <em class="sig-param"><span class="n">test_transformation</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.training.utils.train_test_transformation_datasets" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, ContinualAI Research

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>