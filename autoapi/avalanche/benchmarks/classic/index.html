

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>avalanche.benchmarks.classic &mdash; Avalanche 0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/mystyle.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex/" />
    <link rel="search" title="Search" href="../../../../search/" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../" class="icon icon-home"> Avalanche
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Avalanche API:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../../">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche</span></code></a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../../#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4 current"><a class="reference internal" href="../"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../evaluation/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.evaluation</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../extras/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.extras</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../training/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.training</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../#submodules">Submodules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../constants/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.constants</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../#package-contents">Package Contents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../#avalanche.__version__">__version__</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../">Avalanche</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../">Docs</a> &raquo;</li>
        
      <li><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.classic</span></code></li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../../_sources/autoapi/avalanche/benchmarks/classic/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-avalanche.benchmarks.classic">
<span id="avalanche-benchmarks-classic"></span><h1><a class="reference internal" href="#module-avalanche.benchmarks.classic" title="avalanche.benchmarks.classic"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.classic</span></code></a><a class="headerlink" href="#module-avalanche.benchmarks.classic" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="ccifar10/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.classic.ccifar10</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ccifar100/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.classic.ccifar100</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="cfashion_mnist/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.classic.cfashion_mnist</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="cmnist/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.classic.cmnist</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="core50/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.classic.core50</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ctiny_imagenet/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.classic.ctiny_imagenet</span></code></a></li>
</ul>
</div>
</div>
<div class="section" id="package-contents">
<h2>Package Contents<a class="headerlink" href="#package-contents" title="Permalink to this headline">¶</a></h2>
<div class="section" id="classes">
<h3>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.classic.TinyImagenet" title="avalanche.benchmarks.classic.TinyImagenet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TinyImagenet</span></code></a></p></td>
<td><p>Tiny Imagenet Pytorch Dataset</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.classic.NCGenericScenario" title="avalanche.benchmarks.classic.NCGenericScenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NCGenericScenario</span></code></a></p></td>
<td><p>This class defines a “New Classes” scenario. It is used when creating both</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.classic.NCSingleTaskScenario" title="avalanche.benchmarks.classic.NCSingleTaskScenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code></a></p></td>
<td><p>This class defines a “New Classes” Single Incremental Task scenario based</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code></a></p></td>
<td><p>This class defines a “New Classes” multi task scenario based on a</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.classic.CORe50" title="avalanche.benchmarks.classic.CORe50"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CORe50</span></code></a>(root=None, scenario='nicv2_391', run=0)</p></td>
<td><p>CORe50 continual scenario generator</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id7" title="avalanche.benchmarks.classic.create_nc_single_dataset_sit_scenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_nc_single_dataset_sit_scenario</span></code></a>(train_dataset: IDatasetWithTargets, test_dataset: IDatasetWithTargets, n_batches: int, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, per_batch_classes: Optional[Dict[int, int]] = None, remap_class_ids: bool = False, reproducibility_data: Optional[Dict[str, Any]] = None) → NCSingleTaskScenario</p></td>
<td><p>Creates a “New Classes - Single Incremental Task” scenario given a couple</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id8" title="avalanche.benchmarks.classic.create_nc_single_dataset_multi_task_scenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_nc_single_dataset_multi_task_scenario</span></code></a>(train_dataset: IDatasetWithTargets, test_dataset: IDatasetWithTargets, n_tasks: int, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, per_task_classes: Optional[Dict[int, int]] = None, classes_ids_from_zero_in_each_task: bool = True, reproducibility_data: Optional[Dict[str, Any]] = None) → NCMultiTaskScenario</p></td>
<td><p>Creates a “New Classes - Multi Task” scenario given a couple</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.classic.SplitTinyImageNet" title="avalanche.benchmarks.classic.SplitTinyImageNet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitTinyImageNet</span></code></a>(incremental_steps=10, return_task_id=False, seed=0, fixed_class_order=None, train_transform=_default_train_transform, test_transform=_default_test_transform)</p></td>
<td><p>Creates a CL scenario using the Tiny ImageNet dataset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id7" title="avalanche.benchmarks.classic.create_nc_single_dataset_sit_scenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_nc_single_dataset_sit_scenario</span></code></a>(train_dataset: IDatasetWithTargets, test_dataset: IDatasetWithTargets, n_batches: int, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, per_batch_classes: Optional[Dict[int, int]] = None, remap_class_ids: bool = False, reproducibility_data: Optional[Dict[str, Any]] = None) → NCSingleTaskScenario</p></td>
<td><p>Creates a “New Classes - Single Incremental Task” scenario given a couple</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id8" title="avalanche.benchmarks.classic.create_nc_single_dataset_multi_task_scenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_nc_single_dataset_multi_task_scenario</span></code></a>(train_dataset: IDatasetWithTargets, test_dataset: IDatasetWithTargets, n_tasks: int, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, per_task_classes: Optional[Dict[int, int]] = None, classes_ids_from_zero_in_each_task: bool = True, reproducibility_data: Optional[Dict[str, Any]] = None) → NCMultiTaskScenario</p></td>
<td><p>Creates a “New Classes - Multi Task” scenario given a couple</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.classic.SplitCIFAR10" title="avalanche.benchmarks.classic.SplitCIFAR10"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitCIFAR10</span></code></a>(incremental_steps: int, first_batch_with_half_classes: bool = False, return_task_id=False, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_cifar10_train_transform, test_transform=_default_cifar10_test_transform)</p></td>
<td><p>Creates a CL scenario using the CIFAR10 dataset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id4" title="avalanche.benchmarks.classic._get_cifar10_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_get_cifar10_dataset</span></code></a>(train_transformation, test_transformation)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.classic.concat_datasets_sequentially" title="avalanche.benchmarks.classic.concat_datasets_sequentially"><code class="xref py py-obj docutils literal notranslate"><span class="pre">concat_datasets_sequentially</span></code></a>(train_dataset_list: Sequence[IDatasetWithTargets], test_dataset_list: Sequence[IDatasetWithTargets])</p></td>
<td><p>Concatenates a list of datasets. This is completely different from</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id7" title="avalanche.benchmarks.classic.create_nc_single_dataset_sit_scenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_nc_single_dataset_sit_scenario</span></code></a>(train_dataset: IDatasetWithTargets, test_dataset: IDatasetWithTargets, n_batches: int, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, per_batch_classes: Optional[Dict[int, int]] = None, remap_class_ids: bool = False, reproducibility_data: Optional[Dict[str, Any]] = None) → NCSingleTaskScenario</p></td>
<td><p>Creates a “New Classes - Single Incremental Task” scenario given a couple</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id8" title="avalanche.benchmarks.classic.create_nc_single_dataset_multi_task_scenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_nc_single_dataset_multi_task_scenario</span></code></a>(train_dataset: IDatasetWithTargets, test_dataset: IDatasetWithTargets, n_tasks: int, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, per_task_classes: Optional[Dict[int, int]] = None, classes_ids_from_zero_in_each_task: bool = True, reproducibility_data: Optional[Dict[str, Any]] = None) → NCMultiTaskScenario</p></td>
<td><p>Creates a “New Classes - Multi Task” scenario given a couple</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id4" title="avalanche.benchmarks.classic._get_cifar10_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_get_cifar10_dataset</span></code></a>(train_transformation, test_transformation)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.classic.SplitCIFAR100" title="avalanche.benchmarks.classic.SplitCIFAR100"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitCIFAR100</span></code></a>(incremental_steps: int, first_batch_with_half_classes: bool = False, return_task_id=False, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_cifar100_train_transform, test_transform=_default_cifar100_test_transform)</p></td>
<td><p>Creates a CL scenario using the CIFAR100 dataset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.classic.create_cifar100_with_cifar10_pretrain_benchmark" title="avalanche.benchmarks.classic.create_cifar100_with_cifar10_pretrain_benchmark"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_cifar100_with_cifar10_pretrain_benchmark</span></code></a>(incremental_steps: int, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_cifar100_train_transform, test_transform=_default_cifar100_test_transform) → NCSingleTaskScenario</p></td>
<td><p>Creates a Single Incremental Task (SIT) scenario using the CIFAR100 dataset,</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.classic._get_cifar100_dataset" title="avalanche.benchmarks.classic._get_cifar100_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_get_cifar100_dataset</span></code></a>(train_transformation, test_transformation)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id7" title="avalanche.benchmarks.classic.create_nc_single_dataset_sit_scenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_nc_single_dataset_sit_scenario</span></code></a>(train_dataset: IDatasetWithTargets, test_dataset: IDatasetWithTargets, n_batches: int, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, per_batch_classes: Optional[Dict[int, int]] = None, remap_class_ids: bool = False, reproducibility_data: Optional[Dict[str, Any]] = None) → NCSingleTaskScenario</p></td>
<td><p>Creates a “New Classes - Single Incremental Task” scenario given a couple</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id8" title="avalanche.benchmarks.classic.create_nc_single_dataset_multi_task_scenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_nc_single_dataset_multi_task_scenario</span></code></a>(train_dataset: IDatasetWithTargets, test_dataset: IDatasetWithTargets, n_tasks: int, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, per_task_classes: Optional[Dict[int, int]] = None, classes_ids_from_zero_in_each_task: bool = True, reproducibility_data: Optional[Dict[str, Any]] = None) → NCMultiTaskScenario</p></td>
<td><p>Creates a “New Classes - Multi Task” scenario given a couple</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.classic.create_nc_multi_dataset_multi_task_scenario" title="avalanche.benchmarks.classic.create_nc_multi_dataset_multi_task_scenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_nc_multi_dataset_multi_task_scenario</span></code></a>(train_dataset_list: Sequence[IDatasetWithTargets], test_dataset_list: Sequence[IDatasetWithTargets], shuffle: bool = True, seed: Optional[int] = None, classes_ids_from_zero_in_each_task: bool = True, reproducibility_data: Optional[Dict[str, Any]] = None) → NCMultiTaskScenario</p></td>
<td><p>Creates a “New Classes - Multi Task” scenario given a list of</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.classic.SplitMNIST" title="avalanche.benchmarks.classic.SplitMNIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitMNIST</span></code></a>(incremental_steps: int, return_task_id=False, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_mnist_train_transform, test_transform=_default_mnist_test_transform)</p></td>
<td><p>Creates a CL scenario using the MNIST dataset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.classic.PermutedMNIST" title="avalanche.benchmarks.classic.PermutedMNIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PermutedMNIST</span></code></a>(incremental_steps: int, seed: Optional[int] = None, train_transform=_default_mnist_train_transform, test_transform=_default_mnist_test_transform) → NCMultiTaskScenario</p></td>
<td><p>This helper create a permuted MNIST scenario: where a given number of random</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.classic.RotatedMNIST" title="avalanche.benchmarks.classic.RotatedMNIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RotatedMNIST</span></code></a>(incremental_steps: int, seed: Optional[int] = None, rotations_list: Optional[Sequence[int]] = None, train_transform=_default_mnist_train_transform, test_transform=_default_mnist_test_transform) → NCMultiTaskScenario</p></td>
<td><p>This helper create a rotated MNIST scenario: where a given number of random</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.classic._get_mnist_dataset" title="avalanche.benchmarks.classic._get_mnist_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_get_mnist_dataset</span></code></a>(train_transformation, test_transformation)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id7" title="avalanche.benchmarks.classic.create_nc_single_dataset_sit_scenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_nc_single_dataset_sit_scenario</span></code></a>(train_dataset: IDatasetWithTargets, test_dataset: IDatasetWithTargets, n_batches: int, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, per_batch_classes: Optional[Dict[int, int]] = None, remap_class_ids: bool = False, reproducibility_data: Optional[Dict[str, Any]] = None) → NCSingleTaskScenario</p></td>
<td><p>Creates a “New Classes - Single Incremental Task” scenario given a couple</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id8" title="avalanche.benchmarks.classic.create_nc_single_dataset_multi_task_scenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_nc_single_dataset_multi_task_scenario</span></code></a>(train_dataset: IDatasetWithTargets, test_dataset: IDatasetWithTargets, n_tasks: int, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, per_task_classes: Optional[Dict[int, int]] = None, classes_ids_from_zero_in_each_task: bool = True, reproducibility_data: Optional[Dict[str, Any]] = None) → NCMultiTaskScenario</p></td>
<td><p>Creates a “New Classes - Multi Task” scenario given a couple</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.classic.SplitFMNIST" title="avalanche.benchmarks.classic.SplitFMNIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitFMNIST</span></code></a>(incremental_steps: int, first_batch_with_half_classes: bool = False, return_task_id=False, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_cifar10_train_transform, test_transform=_default_cifar10_test_transform)</p></td>
<td><p>Creates a CL scenario using the Fashion MNIST dataset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.classic._get_fmnist_dataset" title="avalanche.benchmarks.classic._get_fmnist_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_get_fmnist_dataset</span></code></a>(train_transformation, test_transformation)</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt id="avalanche.benchmarks.classic.CORe50">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">CORe50</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">root</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">scenario</span><span class="o">=</span><span class="default_value">'nicv2_391'</span></em>, <em class="sig-param"><span class="n">run</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/classic/core50/#CORe50"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.CORe50" title="Permalink to this definition">¶</a></dt>
<dd><p>CORe50 continual scenario generator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> – Path indicating where to store the dataset and related
metadata. By default they will be stored in
avalanche/datasets/core50/data/.</p></li>
<li><p><strong>scenario</strong> – CORe50 main scanario. I can be chosen between ‘ni’, ‘nc’,
‘nic’, ‘nicv2_79’, ‘nicv2_196’ or ‘nicv2_391.’</p></li>
<li><p><strong>run</strong> – number of run for the scenario. Batch ordering change based
on this parameter (a number between 0 and 9).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>it returns a <code class="xref py py-class docutils literal notranslate"><span class="pre">GenericCLScenario</span></code> instance that can be
iterated.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="avalanche.benchmarks.classic.TinyImagenet">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">TinyImagenet</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_folder</span><span class="o">=</span><span class="default_value">'data'</span></em>, <em class="sig-param"><span class="n">train</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">transform</span><span class="o">=</span><span class="default_value">ToTensor()</span></em>, <em class="sig-param"><span class="n">target_transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">download</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/datasets/tiny_imagenet/tiny_imagenet/#TinyImagenet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.TinyImagenet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.utils.data.Dataset</span></code></p>
<p>Tiny Imagenet Pytorch Dataset</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="field-list simple">
<dt class="field-odd">param string data_folder</dt>
<dd class="field-odd"><p>folder in which to download dataset</p>
</dd>
<dt class="field-even">param boolean train</dt>
<dd class="field-even"><p>True for train set, False for test set</p>
</dd>
<dt class="field-odd">param fun transform</dt>
<dd class="field-odd"><p>Pytorch transformation founction for x</p>
</dd>
<dt class="field-even">param fun target_transform</dt>
<dd class="field-even"><p>Pytorch transformation founction for y</p>
</dd>
<dt class="field-odd">param bool download</dt>
<dd class="field-odd"><p>True for downloading the dataset</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="avalanche.benchmarks.classic.TinyImagenet.download_tinyImageNet">
<code class="sig-name descname">download_tinyImageNet</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/datasets/tiny_imagenet/tiny_imagenet/#TinyImagenet.download_tinyImageNet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.TinyImagenet.download_tinyImageNet" title="Permalink to this definition">¶</a></dt>
<dd><p>Downloads the TintImagenet Dataset</p>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.classic.TinyImagenet.labels2dict">
<code class="sig-name descname">labels2dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/datasets/tiny_imagenet/tiny_imagenet/#TinyImagenet.labels2dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.TinyImagenet.labels2dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns dictionaries to convert class names into progressive ids
and viceversa.
:returns: label2id, id2label: two Python dictionaries.</p>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.classic.TinyImagenet.load_data">
<code class="sig-name descname">load_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">train</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/datasets/tiny_imagenet/tiny_imagenet/#TinyImagenet.load_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.TinyImagenet.load_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Load all images paths and targets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>train</strong> (<em>bool</em>) – True for loading the training set, False for the
test set.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>train_set, test_set: (train_X_paths, train_y).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.classic.TinyImagenet.get_train_images_paths">
<code class="sig-name descname">get_train_images_paths</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">class_name</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/datasets/tiny_imagenet/tiny_imagenet/#TinyImagenet.get_train_images_paths"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.TinyImagenet.get_train_images_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the training set image paths</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>class_name</strong> – names of the classes of the images to be
collected.</p>
</dd>
<dt class="field-even">Returns img_paths</dt>
<dd class="field-even"><p>list of strings (paths)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.classic.TinyImagenet.get_test_images_paths">
<code class="sig-name descname">get_test_images_paths</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">class_name</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/datasets/tiny_imagenet/tiny_imagenet/#TinyImagenet.get_test_images_paths"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.TinyImagenet.get_test_images_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the test set image paths</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>class_name</strong> – names of the classes of the images to be
collected.</p>
</dd>
<dt class="field-even">Returns img_paths</dt>
<dd class="field-even"><p>list of strings (paths)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.classic.TinyImagenet.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/datasets/tiny_imagenet/tiny_imagenet/#TinyImagenet.__len__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.TinyImagenet.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the lenght of the set</p>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.classic.TinyImagenet.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/datasets/tiny_imagenet/tiny_imagenet/#TinyImagenet.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.TinyImagenet.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index-th x, y pattern of the set</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.classic.create_nc_single_dataset_sit_scenario">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">create_nc_single_dataset_sit_scenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">test_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">n_batches</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">per_batch_classes</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>int<span class="p">, </span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">remap_class_ids</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">reproducibility_data</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.classic.NCSingleTaskScenario" title="avalanche.benchmarks.classic.NCSingleTaskScenario">NCSingleTaskScenario</a><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/scenario_creation/#create_nc_single_dataset_sit_scenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.create_nc_single_dataset_sit_scenario" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a “New Classes - Single Incremental Task” scenario given a couple
of train and test datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset</strong> – The training dataset.</p></li>
<li><p><strong>test_dataset</strong> – A list of test dataset.</p></li>
<li><p><strong>n_batches</strong> – The number of batches.</p></li>
<li><p><strong>shuffle</strong> – If True, class order will be shuffled.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, values of <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> and <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to
define the class order. If non-None, <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> and <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameters
will be ignored. Defaults to None.</p></li>
<li><p><strong>per_batch_classes</strong> – Is not None, a dictionary whose keys are
(0-indexed) batch IDs and their values are the number of classes
to include in the respective batches. The dictionary doesn’t
have to contain a key for each batch! All the remaining batches
will contain an equal amount of the remaining classes. The
remaining number of classes must be divisible without remainder
by the remaining number of batches. For instance,
if you want to include 50 classes in the first batch while equally
distributing remaining classes across remaining batches,
just pass the “{0: 50}” dictionary as the <code class="docutils literal notranslate"><span class="pre">per_batch_classes</span></code>
parameter. Defaults to None.</p></li>
<li><p><strong>remap_class_ids</strong> – If True, original class IDs will be
remapped so that they will appear as having an ascending order.
For instance, if the resulting class order after shuffling
(or defined by fixed_class_order) is [23, 34, 11, 7, 6, …] and
remap_class_indexes is True, then all the patterns belonging to
class 23 will appear as belonging to class “0”, class “34” will
be mapped to “1”, class “11” to “2” and so on. This is very
useful when drawing confusion matrices and when dealing with
algorithms with dynamic head expansion. Defaults to False.</p></li>
<li><p><strong>reproducibility_data</strong> – If not None, overrides all the other
scenario definition options. This is usually a dictionary containing
data used to reproduce a specific experiment. One can use the
<code class="docutils literal notranslate"><span class="pre">get_reproducibility_data</span></code> method to get (and even distribute)
the experiment setup so that it can be loaded by passing it as this
parameter. In this way one can be sure that the same specific
experimental setup is being used (for reproducibility purposes).
Beware that, in order to reproduce an experiment, the same train and
test datasets must be used. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code></a> instance initialized for the the
SIT scenario.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.classic.create_nc_single_dataset_multi_task_scenario">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">create_nc_single_dataset_multi_task_scenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">test_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">n_tasks</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">per_task_classes</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>int<span class="p">, </span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">classes_ids_from_zero_in_each_task</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">reproducibility_data</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario">NCMultiTaskScenario</a><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/scenario_creation/#create_nc_single_dataset_multi_task_scenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.create_nc_single_dataset_multi_task_scenario" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a “New Classes - Multi Task” scenario given a couple
of train and test datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset</strong> – The training dataset.</p></li>
<li><p><strong>test_dataset</strong> – A list of test dataset.</p></li>
<li><p><strong>n_tasks</strong> – The number of batches.</p></li>
<li><p><strong>shuffle</strong> – If True, class order will be shuffled.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator. Can
be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, values of shuffle and seed will be used to define the
class order. If non-None, shuffle and seed parameters will be ignored.
Defaults to None.</p></li>
<li><p><strong>per_task_classes</strong> – Is not None, a dictionary whose keys are
(0-indexed) task IDs and their values are the number of classes
to include in the respective batches. The dictionary doesn’t
have to contain a key for each task! All the remaining batches
will contain an equal amount of the remaining classes. The
remaining number of classes must be divisible without remainder
by the remaining number of batches. For instance,
if you want to include 50 classes in the first task while equally
distributing remaining classes across remaining batches,
just pass the “{0: 50}” dictionary as the per_task_classes
parameter. Defaults to None.</p></li>
<li><p><strong>classes_ids_from_zero_in_each_task</strong> – If True, original class IDs will
be mapped to range [0, n_classes_in_task) for each task. If False,
each class will keep its original ID as defined in the input
datasets. Defaults to True.</p></li>
<li><p><strong>reproducibility_data</strong> – If not None, overrides all the other
scenario definition options. This is usually a dictionary containing
data used to reproduce a specific experiment. One can use the
<code class="docutils literal notranslate"><span class="pre">get_reproducibility_data</span></code> method to get (and even distribute)
the experiment setup so that it can be loaded by passing it as this
parameter. In this way one can be sure that the same specific
experimental setup is being used (for reproducibility purposes).
Beware that, in order to reproduce an experiment, the same train and
test datasets must be used. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code></a> instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks.classic._default_train_transform">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">_default_train_transform</code><a class="headerlink" href="#avalanche.benchmarks.classic._default_train_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks.classic._default_test_transform">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">_default_test_transform</code><a class="headerlink" href="#avalanche.benchmarks.classic._default_test_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.classic.SplitTinyImageNet">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">SplitTinyImageNet</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">incremental_steps</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">return_task_id</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">_default_train_transform</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">_default_test_transform</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/classic/ctiny_imagenet/#SplitTinyImageNet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.SplitTinyImageNet" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a CL scenario using the Tiny ImageNet dataset.
If the dataset is not present in the computer the method automatically
download it and store the data in the data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incremental_steps</strong> – The number of incremental steps in the current
scenario.</p></li>
<li><p><strong>return_task_id</strong> – if True, for every step the task id is returned and
the Scenario is Multi Task. This means that the scenario returned
will be of type <code class="docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code>. If false the task index is
not returned (default to 0 for every batch) and the returned scenario
is of type <code class="docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code>.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, value of <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to define the class
order. If non-None, <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter will be ignored.
Defaults to None.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to the training data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default train transformation
will be used.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to the test data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default test transformation
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code></a> instance initialized for the the
MT scenario using CIFAR10 if the parameter <code class="docutils literal notranslate"><span class="pre">return_task_id</span></code> is True,
a <a class="reference internal" href="#avalanche.benchmarks.classic.NCSingleTaskScenario" title="avalanche.benchmarks.classic.NCSingleTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code></a> initialized for the SIT scenario using
CIFAR10 otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="id0">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">create_nc_single_dataset_sit_scenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">test_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">n_batches</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">per_batch_classes</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>int<span class="p">, </span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">remap_class_ids</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">reproducibility_data</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.classic.NCSingleTaskScenario" title="avalanche.benchmarks.classic.NCSingleTaskScenario">NCSingleTaskScenario</a><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/scenario_creation/#create_nc_single_dataset_sit_scenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a “New Classes - Single Incremental Task” scenario given a couple
of train and test datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset</strong> – The training dataset.</p></li>
<li><p><strong>test_dataset</strong> – A list of test dataset.</p></li>
<li><p><strong>n_batches</strong> – The number of batches.</p></li>
<li><p><strong>shuffle</strong> – If True, class order will be shuffled.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, values of <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> and <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to
define the class order. If non-None, <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> and <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameters
will be ignored. Defaults to None.</p></li>
<li><p><strong>per_batch_classes</strong> – Is not None, a dictionary whose keys are
(0-indexed) batch IDs and their values are the number of classes
to include in the respective batches. The dictionary doesn’t
have to contain a key for each batch! All the remaining batches
will contain an equal amount of the remaining classes. The
remaining number of classes must be divisible without remainder
by the remaining number of batches. For instance,
if you want to include 50 classes in the first batch while equally
distributing remaining classes across remaining batches,
just pass the “{0: 50}” dictionary as the <code class="docutils literal notranslate"><span class="pre">per_batch_classes</span></code>
parameter. Defaults to None.</p></li>
<li><p><strong>remap_class_ids</strong> – If True, original class IDs will be
remapped so that they will appear as having an ascending order.
For instance, if the resulting class order after shuffling
(or defined by fixed_class_order) is [23, 34, 11, 7, 6, …] and
remap_class_indexes is True, then all the patterns belonging to
class 23 will appear as belonging to class “0”, class “34” will
be mapped to “1”, class “11” to “2” and so on. This is very
useful when drawing confusion matrices and when dealing with
algorithms with dynamic head expansion. Defaults to False.</p></li>
<li><p><strong>reproducibility_data</strong> – If not None, overrides all the other
scenario definition options. This is usually a dictionary containing
data used to reproduce a specific experiment. One can use the
<code class="docutils literal notranslate"><span class="pre">get_reproducibility_data</span></code> method to get (and even distribute)
the experiment setup so that it can be loaded by passing it as this
parameter. In this way one can be sure that the same specific
experimental setup is being used (for reproducibility purposes).
Beware that, in order to reproduce an experiment, the same train and
test datasets must be used. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code></a> instance initialized for the the
SIT scenario.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="id1">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">create_nc_single_dataset_multi_task_scenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">test_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">n_tasks</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">per_task_classes</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>int<span class="p">, </span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">classes_ids_from_zero_in_each_task</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">reproducibility_data</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario">NCMultiTaskScenario</a><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/scenario_creation/#create_nc_single_dataset_multi_task_scenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id1" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a “New Classes - Multi Task” scenario given a couple
of train and test datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset</strong> – The training dataset.</p></li>
<li><p><strong>test_dataset</strong> – A list of test dataset.</p></li>
<li><p><strong>n_tasks</strong> – The number of batches.</p></li>
<li><p><strong>shuffle</strong> – If True, class order will be shuffled.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator. Can
be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, values of shuffle and seed will be used to define the
class order. If non-None, shuffle and seed parameters will be ignored.
Defaults to None.</p></li>
<li><p><strong>per_task_classes</strong> – Is not None, a dictionary whose keys are
(0-indexed) task IDs and their values are the number of classes
to include in the respective batches. The dictionary doesn’t
have to contain a key for each task! All the remaining batches
will contain an equal amount of the remaining classes. The
remaining number of classes must be divisible without remainder
by the remaining number of batches. For instance,
if you want to include 50 classes in the first task while equally
distributing remaining classes across remaining batches,
just pass the “{0: 50}” dictionary as the per_task_classes
parameter. Defaults to None.</p></li>
<li><p><strong>classes_ids_from_zero_in_each_task</strong> – If True, original class IDs will
be mapped to range [0, n_classes_in_task) for each task. If False,
each class will keep its original ID as defined in the input
datasets. Defaults to True.</p></li>
<li><p><strong>reproducibility_data</strong> – If not None, overrides all the other
scenario definition options. This is usually a dictionary containing
data used to reproduce a specific experiment. One can use the
<code class="docutils literal notranslate"><span class="pre">get_reproducibility_data</span></code> method to get (and even distribute)
the experiment setup so that it can be loaded by passing it as this
parameter. In this way one can be sure that the same specific
experimental setup is being used (for reproducibility purposes).
Beware that, in order to reproduce an experiment, the same train and
test datasets must be used. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code></a> instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks.classic._default_cifar10_train_transform">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">_default_cifar10_train_transform</code><a class="headerlink" href="#avalanche.benchmarks.classic._default_cifar10_train_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks.classic._default_cifar10_test_transform">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">_default_cifar10_test_transform</code><a class="headerlink" href="#avalanche.benchmarks.classic._default_cifar10_test_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.classic.SplitCIFAR10">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">SplitCIFAR10</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">incremental_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">first_batch_with_half_classes</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_task_id</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">_default_cifar10_train_transform</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">_default_cifar10_test_transform</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/classic/ccifar10/#SplitCIFAR10"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.SplitCIFAR10" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a CL scenario using the CIFAR10 dataset.
If the dataset is not present in the computer the method automatically
download it and store the data in the data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incremental_steps</strong> – The number of incremental steps in the current
scenario. If the first step is a “pretrain” step and it contains
half of the classes, the number of incremental steps is the number of
tasks performed after the pretraining task.
The value of this parameter should be a divisor of 10 if
first_task_with_half_classes if false, a divisor of 5 otherwise.</p></li>
<li><p><strong>first_batch_with_half_classes</strong> – A boolean value that indicates if a
first pretraining batch containing half of the classes should be used.
If it’s True, a pretrain batch with half of the classes (5 for
cifar100) is used, and a number of incremental tasks, given by the
parameter incremental_task is constructed. If this paramenter is False
no pretraining task will be used, and the dataset is simply split into
a the number of steps defined by the parameter incremental_steps.
Default to False.</p></li>
<li><p><strong>return_task_id</strong> – if True, for every step the task id is returned and
the Scenario is Multi Task. This means that the scenario returned
will be of type <code class="docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code>. If false the task index is
not returned (default to 0 for every batch) and the returned scenario
is of type <code class="docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code>.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, value of <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to define the class
order. If non-None, <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter will be ignored.
Defaults to None.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to the training data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default train transformation
will be used.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to the test data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default test transformation
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code></a> instance initialized for the the
MT scenario using CIFAR10 if the parameter <code class="docutils literal notranslate"><span class="pre">return_task_id</span></code> is True,
a <a class="reference internal" href="#avalanche.benchmarks.classic.NCSingleTaskScenario" title="avalanche.benchmarks.classic.NCSingleTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code></a> initialized for the SIT scenario using
CIFAR10 otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.classic._get_cifar10_dataset">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">_get_cifar10_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_transformation</span></em>, <em class="sig-param"><span class="n">test_transformation</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.benchmarks.classic._get_cifar10_dataset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="avalanche.benchmarks.classic.NCGenericScenario">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">NCGenericScenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset</span><span class="p">:</span> <span class="n">TrainSetWithTargets</span></em>, <em class="sig-param"><span class="n">test_dataset</span><span class="p">:</span> <span class="n">TestSetWithTargets</span></em>, <em class="sig-param"><span class="n">n_batches</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">per_batch_classes</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>int<span class="p">, </span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">remap_class_indexes</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">reproducibility_data</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/nc_generic_scenario/#NCGenericScenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.NCGenericScenario" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Generic[TrainSetWithTargets,</span> <span class="pre">TestSetWithTargets]</span></code></p>
<p>This class defines a “New Classes” scenario. It is used when creating both
task-oriented and single-incremental-batches (a.k.a. task-free) as
it doesn’t make any difference between them. Once created, an instance
of this class can be iterated in order to obtain the batches/batch sequence
under the form of instances of <code class="xref py py-class docutils literal notranslate"><span class="pre">NCGenericBatchInfo</span></code>.</p>
<p>This class can be used directly. However, we recommend using facilities like
<a class="reference internal" href="../scenarios/new_classes/scenario_creation/#avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_single_dataset_sit_scenario" title="avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_single_dataset_sit_scenario"><code class="xref py py-func docutils literal notranslate"><span class="pre">scenario_creation.create_nc_single_dataset_sit_scenario()</span></code></a>,
<a class="reference internal" href="../scenarios/new_classes/scenario_creation/#avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_single_dataset_multi_task_scenario" title="avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_single_dataset_multi_task_scenario"><code class="xref py py-func docutils literal notranslate"><span class="pre">scenario_creation.create_nc_single_dataset_multi_task_scenario()</span></code></a>,
<a class="reference internal" href="../scenarios/new_classes/scenario_creation/#avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_multi_dataset_sit_scenario" title="avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_multi_dataset_sit_scenario"><code class="xref py py-func docutils literal notranslate"><span class="pre">scenario_creation.create_nc_multi_dataset_sit_scenario()</span></code></a> and
<a class="reference internal" href="../scenarios/new_classes/scenario_creation/#avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_multi_dataset_multi_task_scenario" title="avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_multi_dataset_multi_task_scenario"><code class="xref py py-func docutils literal notranslate"><span class="pre">scenario_creation.create_nc_multi_dataset_multi_task_scenario()</span></code></a>.</p>
<p>Creates a NCGenericScenario instance given the training and test
Datasets and the number of batches.</p>
<p>By default, the number of classes will be automatically detected by
looking at the training Dataset targets field. Classes will be
uniformly distributed across the “n_batches” unless a per_task_classes
argument is specified.</p>
<p>The number of classes must be divisible without remainder by the number
of batches. This also applies when the per_task_classes argument is not
None.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset</strong> – The training dataset. The dataset must contain a
“targets” field. For instance, one can safely use the datasets from
the torchvision package.</p></li>
<li><p><strong>test_dataset</strong> – The test dataset. The dataset must contain a
“targets” field. For instance, one can safely use the datasets from
the torchvision package.</p></li>
<li><p><strong>n_batches</strong> – The number of batches.</p></li>
<li><p><strong>shuffle</strong> – If True, the class order will be shuffled. Defaults to
True.</p></li>
<li><p><strong>seed</strong> – If shuffle is True and seed is not None, the class order
will be shuffled according to the seed. When None, the current
PyTorch random number generator state will be used.
Defaults to None.</p></li>
<li><p><strong>fixed_class_order</strong> – If not None, the class order to use (overrides
the shuffle argument). Very useful for enhancing
reproducibility. Defaults to None.</p></li>
<li><p><strong>per_batch_classes</strong> – Is not None, a dictionary whose keys are
(0-indexed) batch IDs and their values are the number of classes
to include in the respective batches. The dictionary doesn’t
have to contain a key for each batch! All the remaining batches
will contain an equal amount of the remaining classes. The
remaining number of classes must be divisible without remainder
by the remaining number of batches. For instance,
if you want to include 50 classes in the first batch
while equally distributing remaining classes across remaining
batches, just pass the “{0: 50}” dictionary as the
per_batch_classes parameter. Defaults to None.</p></li>
<li><p><strong>remap_class_indexes</strong> – If True, original class IDs will be
remapped so that they will appear as having an ascending order.
For instance, if the resulting class order after shuffling
(or defined by fixed_class_order) is [23, 34, 11, 7, 6, …] and
remap_class_indexes is True, then all the patterns belonging to
class 23 will appear as belonging to class “0”, class “34” will
be mapped to “1”, class “11” to “2” and so on. This is very
useful when drawing confusion matrices and when dealing with
algorithms with dynamic head expansion. Defaults to False.</p></li>
<li><p><strong>reproducibility_data</strong> – If not None, overrides all the other
scenario definition options. This is usually a dictionary containing
data used to reproduce a specific experiment. One can use the
<code class="docutils literal notranslate"><span class="pre">get_reproducibility_data</span></code> method to get (and even distribute)
the experiment setup so that it can be loaded by passing it as this
parameter. In this way one can be sure that the same specific
experimental setup is being used (for reproducibility purposes).
Beware that, in order to reproduce an experiment, the same train and
test datasets must be used. Defaults to None.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="avalanche.benchmarks.classic.NCGenericScenario.get_reproducibility_data">
<code class="sig-name descname">get_reproducibility_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/nc_generic_scenario/#NCGenericScenario.get_reproducibility_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.NCGenericScenario.get_reproducibility_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.classic.NCGenericScenario.classes_in_batch_range">
<code class="sig-name descname">classes_in_batch_range</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">batch_start</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">batch_end</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; List<span class="p">[</span>int<span class="p">]</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/nc_generic_scenario/#NCGenericScenario.classes_in_batch_range"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.NCGenericScenario.classes_in_batch_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a list of classes contained int the given batches. The batches are
defined by range. This means that only the classes in range
[batch_start, batch_end) will be included.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch_start</strong> – The starting batch ID</p></li>
<li><p><strong>batch_end</strong> – The final batch ID. Can be None, which means that all
the remaining batches will be taken.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The classes contained in the required batch range.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.classic.NCGenericScenario.get_class_split">
<code class="sig-name descname">get_class_split</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">batch_id</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/nc_generic_scenario/#NCGenericScenario.get_class_split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.NCGenericScenario.get_class_split" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.classic.concat_datasets_sequentially">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">concat_datasets_sequentially</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset_list</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>IDatasetWithTargets<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">test_dataset_list</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>IDatasetWithTargets<span class="p">]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/training/utils/transform_dataset/#concat_datasets_sequentially"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.concat_datasets_sequentially" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates a list of datasets. This is completely different from
<code class="xref py py-class docutils literal notranslate"><span class="pre">ConcatDataset</span></code>, in which datasets are merged together without
other processing. Instead, this function re-maps the datasets class IDs.
For instance:
let the dataset[0] contain patterns of 3 different classes,
let the dataset[1] contain patterns of 2 different classes, then class IDs
will be mapped as follows:</p>
<p>dataset[0] class “0” -&gt; new class ID is “0”</p>
<p>dataset[0] class “1” -&gt; new class ID is “1”</p>
<p>dataset[0] class “2” -&gt; new class ID is “2”</p>
<p>dataset[1] class “0” -&gt; new class ID is “3”</p>
<p>dataset[1] class “1” -&gt; new classID is “4”</p>
<p>… -&gt; …</p>
<p>dataset[N-1] class “C-1” -&gt; new class ID is “overall_n_classes-1”</p>
<p>In contract, using PyTorch ConcatDataset:</p>
<p>dataset[0] class “0” -&gt; ID is “0”</p>
<p>dataset[0] class “1” -&gt; ID is “1”</p>
<p>dataset[0] class “2” -&gt; ID is “2”</p>
<p>dataset[1] class “0” -&gt; ID is “0”</p>
<p>dataset[1] class “1” -&gt; ID is “1”</p>
<p>Note: <code class="docutils literal notranslate"><span class="pre">train_dataset_list</span></code> and <code class="docutils literal notranslate"><span class="pre">test_dataset_list</span></code> must have the same
number of datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset_list</strong> – A list of training datasets</p></li>
<li><p><strong>test_dataset_list</strong> – A list of test datasets</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A concatenated dataset.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="id2">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">create_nc_single_dataset_sit_scenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">test_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">n_batches</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">per_batch_classes</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>int<span class="p">, </span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">remap_class_ids</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">reproducibility_data</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.classic.NCSingleTaskScenario" title="avalanche.benchmarks.classic.NCSingleTaskScenario">NCSingleTaskScenario</a><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/scenario_creation/#create_nc_single_dataset_sit_scenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id2" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a “New Classes - Single Incremental Task” scenario given a couple
of train and test datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset</strong> – The training dataset.</p></li>
<li><p><strong>test_dataset</strong> – A list of test dataset.</p></li>
<li><p><strong>n_batches</strong> – The number of batches.</p></li>
<li><p><strong>shuffle</strong> – If True, class order will be shuffled.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, values of <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> and <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to
define the class order. If non-None, <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> and <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameters
will be ignored. Defaults to None.</p></li>
<li><p><strong>per_batch_classes</strong> – Is not None, a dictionary whose keys are
(0-indexed) batch IDs and their values are the number of classes
to include in the respective batches. The dictionary doesn’t
have to contain a key for each batch! All the remaining batches
will contain an equal amount of the remaining classes. The
remaining number of classes must be divisible without remainder
by the remaining number of batches. For instance,
if you want to include 50 classes in the first batch while equally
distributing remaining classes across remaining batches,
just pass the “{0: 50}” dictionary as the <code class="docutils literal notranslate"><span class="pre">per_batch_classes</span></code>
parameter. Defaults to None.</p></li>
<li><p><strong>remap_class_ids</strong> – If True, original class IDs will be
remapped so that they will appear as having an ascending order.
For instance, if the resulting class order after shuffling
(or defined by fixed_class_order) is [23, 34, 11, 7, 6, …] and
remap_class_indexes is True, then all the patterns belonging to
class 23 will appear as belonging to class “0”, class “34” will
be mapped to “1”, class “11” to “2” and so on. This is very
useful when drawing confusion matrices and when dealing with
algorithms with dynamic head expansion. Defaults to False.</p></li>
<li><p><strong>reproducibility_data</strong> – If not None, overrides all the other
scenario definition options. This is usually a dictionary containing
data used to reproduce a specific experiment. One can use the
<code class="docutils literal notranslate"><span class="pre">get_reproducibility_data</span></code> method to get (and even distribute)
the experiment setup so that it can be loaded by passing it as this
parameter. In this way one can be sure that the same specific
experimental setup is being used (for reproducibility purposes).
Beware that, in order to reproduce an experiment, the same train and
test datasets must be used. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code></a> instance initialized for the the
SIT scenario.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="id3">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">create_nc_single_dataset_multi_task_scenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">test_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">n_tasks</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">per_task_classes</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>int<span class="p">, </span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">classes_ids_from_zero_in_each_task</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">reproducibility_data</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario">NCMultiTaskScenario</a><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/scenario_creation/#create_nc_single_dataset_multi_task_scenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id3" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a “New Classes - Multi Task” scenario given a couple
of train and test datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset</strong> – The training dataset.</p></li>
<li><p><strong>test_dataset</strong> – A list of test dataset.</p></li>
<li><p><strong>n_tasks</strong> – The number of batches.</p></li>
<li><p><strong>shuffle</strong> – If True, class order will be shuffled.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator. Can
be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, values of shuffle and seed will be used to define the
class order. If non-None, shuffle and seed parameters will be ignored.
Defaults to None.</p></li>
<li><p><strong>per_task_classes</strong> – Is not None, a dictionary whose keys are
(0-indexed) task IDs and their values are the number of classes
to include in the respective batches. The dictionary doesn’t
have to contain a key for each task! All the remaining batches
will contain an equal amount of the remaining classes. The
remaining number of classes must be divisible without remainder
by the remaining number of batches. For instance,
if you want to include 50 classes in the first task while equally
distributing remaining classes across remaining batches,
just pass the “{0: 50}” dictionary as the per_task_classes
parameter. Defaults to None.</p></li>
<li><p><strong>classes_ids_from_zero_in_each_task</strong> – If True, original class IDs will
be mapped to range [0, n_classes_in_task) for each task. If False,
each class will keep its original ID as defined in the input
datasets. Defaults to True.</p></li>
<li><p><strong>reproducibility_data</strong> – If not None, overrides all the other
scenario definition options. This is usually a dictionary containing
data used to reproduce a specific experiment. One can use the
<code class="docutils literal notranslate"><span class="pre">get_reproducibility_data</span></code> method to get (and even distribute)
the experiment setup so that it can be loaded by passing it as this
parameter. In this way one can be sure that the same specific
experimental setup is being used (for reproducibility purposes).
Beware that, in order to reproduce an experiment, the same train and
test datasets must be used. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code></a> instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="avalanche.benchmarks.classic.NCSingleTaskScenario">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">NCSingleTaskScenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nc_generic_scenario</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#avalanche.benchmarks.classic.NCGenericScenario" title="avalanche.benchmarks.classic.NCGenericScenario">NCGenericScenario</a><span class="p">[</span>TrainSetWithTargets<span class="p">, </span>TestSetWithTargets<span class="p">]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/nc_scenario/#NCSingleTaskScenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.NCSingleTaskScenario" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">GenericCLScenario[TrainSetWithTargets,</span> <span class="pre">TestSetWithTargets]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Generic[TrainSetWithTargets,</span> <span class="pre">TestSetWithTargets]</span></code></p>
<p>This class defines a “New Classes” Single Incremental Task scenario based
on a <a class="reference internal" href="#avalanche.benchmarks.classic.NCGenericScenario" title="avalanche.benchmarks.classic.NCGenericScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCGenericScenario</span></code></a> instance. Once created, an instance of this
class can be iterated in order to obtain the batch sequence under
the form of instances of <code class="xref py py-class docutils literal notranslate"><span class="pre">NCBatchInfo</span></code>.</p>
<p>Instances of this class can be created using the constructor directly.
However, we recommend using facilities like:
<a class="reference internal" href="../scenarios/new_classes/scenario_creation/#avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_single_dataset_sit_scenario" title="avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_single_dataset_sit_scenario"><code class="xref py py-func docutils literal notranslate"><span class="pre">scenario_creation.create_nc_single_dataset_sit_scenario()</span></code></a>,
<a class="reference internal" href="../scenarios/new_classes/scenario_creation/#avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_single_dataset_multi_task_scenario" title="avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_single_dataset_multi_task_scenario"><code class="xref py py-func docutils literal notranslate"><span class="pre">scenario_creation.create_nc_single_dataset_multi_task_scenario()</span></code></a>,
<a class="reference internal" href="../scenarios/new_classes/scenario_creation/#avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_multi_dataset_sit_scenario" title="avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_multi_dataset_sit_scenario"><code class="xref py py-func docutils literal notranslate"><span class="pre">scenario_creation.create_nc_multi_dataset_sit_scenario()</span></code></a> and
<a class="reference internal" href="../scenarios/new_classes/scenario_creation/#avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_multi_dataset_multi_task_scenario" title="avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_multi_dataset_multi_task_scenario"><code class="xref py py-func docutils literal notranslate"><span class="pre">scenario_creation.create_nc_multi_dataset_multi_task_scenario()</span></code></a>.</p>
<p>This class acts as a wrapper for <a class="reference internal" href="#avalanche.benchmarks.classic.NCGenericScenario" title="avalanche.benchmarks.classic.NCGenericScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCGenericScenario</span></code></a>, adding the
task label (always “0”) as the output to training/test set related functions
(see: <code class="xref py py-class docutils literal notranslate"><span class="pre">NCBatchInfo</span></code>).</p>
<p>Creates a NC Single Incremental Task scenario given a
<a class="reference internal" href="#avalanche.benchmarks.classic.NCGenericScenario" title="avalanche.benchmarks.classic.NCGenericScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCGenericScenario</span></code></a> instance. That instance will be used as the
batches factory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nc_generic_scenario</strong> – The <a class="reference internal" href="#avalanche.benchmarks.classic.NCGenericScenario" title="avalanche.benchmarks.classic.NCGenericScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCGenericScenario</span></code></a> instance
used to populate this scenario.</p>
</dd>
</dl>
<dl class="py method">
<dt id="avalanche.benchmarks.classic.NCSingleTaskScenario.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">batch_id</span></em><span class="sig-paren">)</span> &#x2192; NCBatchInfo[TrainSetWithTargets,TestSetWithTargets]<a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/nc_scenario/#NCSingleTaskScenario.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.NCSingleTaskScenario.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a steps given its step ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>step_id</strong> – The step ID.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The step instance associated to the given step ID.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.classic.NCSingleTaskScenario.get_reproducibility_data">
<code class="sig-name descname">get_reproducibility_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/nc_scenario/#NCSingleTaskScenario.get_reproducibility_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.NCSingleTaskScenario.get_reproducibility_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the data needed to reproduce this experiment.</p>
<p>This data can be stored using the pickle module or some other mechanism.
It can then be loaded by passing it as the <code class="docutils literal notranslate"><span class="pre">reproducibility_data</span></code>
parameter in the constructor.</p>
<p>Child classes should get the reproducibility dictionary from super class
and then merge their custom data before returning it.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A dictionary containing the data needed to reproduce the
experiment.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="id4">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">_get_cifar10_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_transformation</span></em>, <em class="sig-param"><span class="n">test_transformation</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id4" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks.classic._default_cifar100_train_transform">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">_default_cifar100_train_transform</code><a class="headerlink" href="#avalanche.benchmarks.classic._default_cifar100_train_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks.classic._default_cifar100_test_transform">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">_default_cifar100_test_transform</code><a class="headerlink" href="#avalanche.benchmarks.classic._default_cifar100_test_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.classic.SplitCIFAR100">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">SplitCIFAR100</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">incremental_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">first_batch_with_half_classes</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_task_id</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">_default_cifar100_train_transform</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">_default_cifar100_test_transform</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/classic/ccifar100/#SplitCIFAR100"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.SplitCIFAR100" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a CL scenario using the CIFAR100 dataset.
If the dataset is not present in the computer the method automatically
download it and store the data in the data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incremental_steps</strong> – The number of incremental steps in the current
scenario. If the first step is a “pretrain” step and it contains
half of the classes, the number of incremental steps is the number of
tasks performed after the pretraining task.
The value of this parameter should be a divisor of 100 if
first_task_with_half_classes if false, a divisor of 50 otherwise.</p></li>
<li><p><strong>first_batch_with_half_classes</strong> – A boolean value that indicates if a
first pretraining batch containing half of the classes should be used.
If it’s True, a pretrain batch with half of the classes (50 for
cifar100) is used, and a number of incremental tasks, given by the
parameter incremental_task is constructed. If this paramenter is False
no pretraining task will be used, and the dataset is simply split into
a the number of steps defined by the parameter incremental_steps.
Default to False.</p></li>
<li><p><strong>return_task_id</strong> – if True, for every step the task id is returned and
the Scenario is Multi Task. This means that the scenario returned
will be of type <code class="docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code>. If false the task index is
not returned (default to 0 for every batch) and the returned scenario
is of type <code class="docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code>.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, value of <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to define the class
order. If non-None, <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter will be ignored.
Defaults to None.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to the training data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default train transformation
will be used.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to the test data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default test transformation
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code></a> instance initialized for the the
MT scenario using CIFAR100 if the parameter <code class="docutils literal notranslate"><span class="pre">return_task_id</span></code> is True,
a <a class="reference internal" href="#avalanche.benchmarks.classic.NCSingleTaskScenario" title="avalanche.benchmarks.classic.NCSingleTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code></a> initialized for the SIT scenario using
CIFAR100 otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.classic.create_cifar100_with_cifar10_pretrain_benchmark">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">create_cifar100_with_cifar10_pretrain_benchmark</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">incremental_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">_default_cifar100_train_transform</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">_default_cifar100_test_transform</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.classic.NCSingleTaskScenario" title="avalanche.benchmarks.classic.NCSingleTaskScenario">NCSingleTaskScenario</a><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/classic/ccifar100/#create_cifar100_with_cifar10_pretrain_benchmark"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.create_cifar100_with_cifar10_pretrain_benchmark" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a Single Incremental Task (SIT) scenario using the CIFAR100 dataset,
with a pretrain first batch using CIFAR10.
If the datasets are not present in the computer the method automatically
download them and store the data in the data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incremental_steps</strong> – The number of incremental steps for the
incremental training on cifar100. The first “pretrain” batch using
cifar10 is not included in this number of incremental steps.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order ONLY for the incremental part on cifar100. The classes must be in
range 0-99.
If None, value of <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to define the class
order for the incremental batches on cifar100.
If non-None, <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter will be ignored.
Defaults to None.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to the training data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default train transformation
will be used.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to the test data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default test transformation
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.classic.NCSingleTaskScenario" title="avalanche.benchmarks.classic.NCSingleTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code></a> instance initialized for the the
SIT scenario using CIFAR10 as a pretrain batch zero and CIFAR100 for the
incremental training.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.classic._get_cifar100_dataset">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">_get_cifar100_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_transformation</span></em>, <em class="sig-param"><span class="n">test_transformation</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.benchmarks.classic._get_cifar100_dataset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="id5">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">create_nc_single_dataset_sit_scenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">test_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">n_batches</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">per_batch_classes</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>int<span class="p">, </span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">remap_class_ids</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">reproducibility_data</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.classic.NCSingleTaskScenario" title="avalanche.benchmarks.classic.NCSingleTaskScenario">NCSingleTaskScenario</a><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/scenario_creation/#create_nc_single_dataset_sit_scenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id5" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a “New Classes - Single Incremental Task” scenario given a couple
of train and test datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset</strong> – The training dataset.</p></li>
<li><p><strong>test_dataset</strong> – A list of test dataset.</p></li>
<li><p><strong>n_batches</strong> – The number of batches.</p></li>
<li><p><strong>shuffle</strong> – If True, class order will be shuffled.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, values of <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> and <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to
define the class order. If non-None, <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> and <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameters
will be ignored. Defaults to None.</p></li>
<li><p><strong>per_batch_classes</strong> – Is not None, a dictionary whose keys are
(0-indexed) batch IDs and their values are the number of classes
to include in the respective batches. The dictionary doesn’t
have to contain a key for each batch! All the remaining batches
will contain an equal amount of the remaining classes. The
remaining number of classes must be divisible without remainder
by the remaining number of batches. For instance,
if you want to include 50 classes in the first batch while equally
distributing remaining classes across remaining batches,
just pass the “{0: 50}” dictionary as the <code class="docutils literal notranslate"><span class="pre">per_batch_classes</span></code>
parameter. Defaults to None.</p></li>
<li><p><strong>remap_class_ids</strong> – If True, original class IDs will be
remapped so that they will appear as having an ascending order.
For instance, if the resulting class order after shuffling
(or defined by fixed_class_order) is [23, 34, 11, 7, 6, …] and
remap_class_indexes is True, then all the patterns belonging to
class 23 will appear as belonging to class “0”, class “34” will
be mapped to “1”, class “11” to “2” and so on. This is very
useful when drawing confusion matrices and when dealing with
algorithms with dynamic head expansion. Defaults to False.</p></li>
<li><p><strong>reproducibility_data</strong> – If not None, overrides all the other
scenario definition options. This is usually a dictionary containing
data used to reproduce a specific experiment. One can use the
<code class="docutils literal notranslate"><span class="pre">get_reproducibility_data</span></code> method to get (and even distribute)
the experiment setup so that it can be loaded by passing it as this
parameter. In this way one can be sure that the same specific
experimental setup is being used (for reproducibility purposes).
Beware that, in order to reproduce an experiment, the same train and
test datasets must be used. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code></a> instance initialized for the the
SIT scenario.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="id6">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">create_nc_single_dataset_multi_task_scenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">test_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">n_tasks</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">per_task_classes</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>int<span class="p">, </span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">classes_ids_from_zero_in_each_task</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">reproducibility_data</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario">NCMultiTaskScenario</a><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/scenario_creation/#create_nc_single_dataset_multi_task_scenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id6" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a “New Classes - Multi Task” scenario given a couple
of train and test datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset</strong> – The training dataset.</p></li>
<li><p><strong>test_dataset</strong> – A list of test dataset.</p></li>
<li><p><strong>n_tasks</strong> – The number of batches.</p></li>
<li><p><strong>shuffle</strong> – If True, class order will be shuffled.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator. Can
be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, values of shuffle and seed will be used to define the
class order. If non-None, shuffle and seed parameters will be ignored.
Defaults to None.</p></li>
<li><p><strong>per_task_classes</strong> – Is not None, a dictionary whose keys are
(0-indexed) task IDs and their values are the number of classes
to include in the respective batches. The dictionary doesn’t
have to contain a key for each task! All the remaining batches
will contain an equal amount of the remaining classes. The
remaining number of classes must be divisible without remainder
by the remaining number of batches. For instance,
if you want to include 50 classes in the first task while equally
distributing remaining classes across remaining batches,
just pass the “{0: 50}” dictionary as the per_task_classes
parameter. Defaults to None.</p></li>
<li><p><strong>classes_ids_from_zero_in_each_task</strong> – If True, original class IDs will
be mapped to range [0, n_classes_in_task) for each task. If False,
each class will keep its original ID as defined in the input
datasets. Defaults to True.</p></li>
<li><p><strong>reproducibility_data</strong> – If not None, overrides all the other
scenario definition options. This is usually a dictionary containing
data used to reproduce a specific experiment. One can use the
<code class="docutils literal notranslate"><span class="pre">get_reproducibility_data</span></code> method to get (and even distribute)
the experiment setup so that it can be loaded by passing it as this
parameter. In this way one can be sure that the same specific
experimental setup is being used (for reproducibility purposes).
Beware that, in order to reproduce an experiment, the same train and
test datasets must be used. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code></a> instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.classic.create_nc_multi_dataset_multi_task_scenario">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">create_nc_multi_dataset_multi_task_scenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset_list</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>IDatasetWithTargets<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">test_dataset_list</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>IDatasetWithTargets<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">classes_ids_from_zero_in_each_task</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">reproducibility_data</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario">NCMultiTaskScenario</a><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/scenario_creation/#create_nc_multi_dataset_multi_task_scenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.create_nc_multi_dataset_multi_task_scenario" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a “New Classes - Multi Task” scenario given a list of
datasets and the number of batches. Each dataset will be treated as a task.
This means that the overall number of batches will be
len(train_dataset_list).</p>
<p>Note: train_dataset_list and test_dataset_list must have the same number of
datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset_list</strong> – A list of training datasets</p></li>
<li><p><strong>test_dataset_list</strong> – A list of test datasets</p></li>
<li><p><strong>shuffle</strong> – If True, task order will be shuffled. Defaults to True.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>classes_ids_from_zero_in_each_task</strong> – If True, original class IDs will
be kept as is, that is, in range [0, n_classes_in_task) for each task.
If False, each class ID will be remapped so that each class ID will
appear once across all batches. Defaults to True.
For instance, if the resulting dataset (task) order after shuffling
is [dataset2, dataset3, dataset0, dataset1] and
classes_ids_from_zero_in_each_task is False, then all the classes
belonging to dataset2 will appear as having IDs in range
[0, n_classes_in_dataset2) while classes in dataset3 will appear
as having IDs in range [n_classes_in_dataset2,
n_classes_in_dataset2+n_classes_in_dataset3) and so on.</p></li>
<li><p><strong>reproducibility_data</strong> – If not None, overrides all the other
scenario definition options. This is usually a dictionary containing
data used to reproduce a specific experiment. One can use the
<code class="docutils literal notranslate"><span class="pre">get_reproducibility_data</span></code> method to get (and even distribute)
the experiment setup so that it can be loaded by passing it as this
parameter. In this way one can be sure that the same specific
experimental setup is being used (for reproducibility purposes).
Beware that, in order to reproduce an experiment, the same train and
test datasets must be used. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code></a> instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="avalanche.benchmarks.classic.NCMultiTaskScenario">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">NCMultiTaskScenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nc_generic_scenario</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#avalanche.benchmarks.classic.NCGenericScenario" title="avalanche.benchmarks.classic.NCGenericScenario">NCGenericScenario</a><span class="p">[</span>TrainSetWithTargets<span class="p">, </span>TestSetWithTargets<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">classes_ids_from_zero_in_each_task</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">reproducibility_data</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/nc_scenario/#NCMultiTaskScenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">GenericCLScenario[TrainSetWithTargets,</span> <span class="pre">TestSetWithTargets]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Generic[TrainSetWithTargets,</span> <span class="pre">TestSetWithTargets]</span></code></p>
<p>This class defines a “New Classes” multi task scenario based on a
<a class="reference internal" href="#avalanche.benchmarks.classic.NCGenericScenario" title="avalanche.benchmarks.classic.NCGenericScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCGenericScenario</span></code></a> instance. Once created, an instance of this
class can be iterated in order to obtain the task sequence under
the form of instances of <code class="xref py py-class docutils literal notranslate"><span class="pre">NCTaskInfo</span></code>.</p>
<p>Instances of this class can be created using the constructor directly.
However, we recommend using facilities like:
<a class="reference internal" href="../scenarios/new_classes/scenario_creation/#avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_single_dataset_sit_scenario" title="avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_single_dataset_sit_scenario"><code class="xref py py-func docutils literal notranslate"><span class="pre">scenario_creation.create_nc_single_dataset_sit_scenario()</span></code></a>,
<a class="reference internal" href="../scenarios/new_classes/scenario_creation/#avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_single_dataset_multi_task_scenario" title="avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_single_dataset_multi_task_scenario"><code class="xref py py-func docutils literal notranslate"><span class="pre">scenario_creation.create_nc_single_dataset_multi_task_scenario()</span></code></a>,
<a class="reference internal" href="../scenarios/new_classes/scenario_creation/#avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_multi_dataset_sit_scenario" title="avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_multi_dataset_sit_scenario"><code class="xref py py-func docutils literal notranslate"><span class="pre">scenario_creation.create_nc_multi_dataset_sit_scenario()</span></code></a> and
<a class="reference internal" href="../scenarios/new_classes/scenario_creation/#avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_multi_dataset_multi_task_scenario" title="avalanche.benchmarks.scenarios.new_classes.scenario_creation.create_nc_multi_dataset_multi_task_scenario"><code class="xref py py-func docutils literal notranslate"><span class="pre">scenario_creation.create_nc_multi_dataset_multi_task_scenario()</span></code></a>.</p>
<p>This class acts as a wrapper for <a class="reference internal" href="#avalanche.benchmarks.classic.NCGenericScenario" title="avalanche.benchmarks.classic.NCGenericScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCGenericScenario</span></code></a>, adding the
task label as the output to training/test set related functions
(see: <code class="xref py py-class docutils literal notranslate"><span class="pre">NCTaskInfo</span></code>).</p>
<p>Creates a NC multi task scenario given a <a class="reference internal" href="#avalanche.benchmarks.classic.NCGenericScenario" title="avalanche.benchmarks.classic.NCGenericScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCGenericScenario</span></code></a>
instance. That instance will be used as the batches factory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nc_generic_scenario</strong> – The <a class="reference internal" href="#avalanche.benchmarks.classic.NCGenericScenario" title="avalanche.benchmarks.classic.NCGenericScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCGenericScenario</span></code></a> instance
used to populate this scenario.</p></li>
<li><p><strong>classes_ids_from_zero_in_each_task</strong> – If True, class ids will be
mapped to range [0, n_classes) for each task. Defaults to True.</p></li>
<li><p><strong>reproducibility_data</strong> – If not None, overrides all the other
scenario definition options. This is usually a dictionary containing
data used to reproduce a specific experiment. One can use the
<code class="docutils literal notranslate"><span class="pre">get_reproducibility_data</span></code> method to get (and even distribute)
the experiment setup so that it can be loaded by passing it as this
parameter. In this way one can be sure that the same specific
experimental setup is being used (for reproducibility purposes).
Beware that, in order to reproduce an experiment, the same train and
test datasets must be used. Defaults to None.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="avalanche.benchmarks.classic.NCMultiTaskScenario.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">task_id</span></em><span class="sig-paren">)</span> &#x2192; NCTaskInfo[TrainSetWithTargets, TestSetWithTargets]<a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/nc_scenario/#NCMultiTaskScenario.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.NCMultiTaskScenario.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a steps given its step ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>step_id</strong> – The step ID.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The step instance associated to the given step ID.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.classic.NCMultiTaskScenario.get_reproducibility_data">
<code class="sig-name descname">get_reproducibility_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/nc_scenario/#NCMultiTaskScenario.get_reproducibility_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.NCMultiTaskScenario.get_reproducibility_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the data needed to reproduce this experiment.</p>
<p>This data can be stored using the pickle module or some other mechanism.
It can then be loaded by passing it as the <code class="docutils literal notranslate"><span class="pre">reproducibility_data</span></code>
parameter in the constructor.</p>
<p>Child classes should get the reproducibility dictionary from super class
and then merge their custom data before returning it.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A dictionary containing the data needed to reproduce the
experiment.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.classic.NCMultiTaskScenario.classes_in_task_range">
<code class="sig-name descname">classes_in_task_range</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">task_start</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">task_end</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; List<span class="p">[</span>int<span class="p">]</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/nc_scenario/#NCMultiTaskScenario.classes_in_task_range"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.NCMultiTaskScenario.classes_in_task_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a list of classes contained int the given tasks. The tasks are
defined by range. This means that only the classes in range
[task_start, task_end) will be included.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>task_start</strong> – The starting task ID</p></li>
<li><p><strong>task_end</strong> – The final task ID. Can be None, which means that all
the remaining tasks will be taken.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The classes contained in the required task range.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.classic.NCMultiTaskScenario.get_class_split">
<code class="sig-name descname">get_class_split</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">task_id</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/nc_scenario/#NCMultiTaskScenario.get_class_split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.NCMultiTaskScenario.get_class_split" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks.classic._default_mnist_train_transform">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">_default_mnist_train_transform</code><a class="headerlink" href="#avalanche.benchmarks.classic._default_mnist_train_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks.classic._default_mnist_test_transform">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">_default_mnist_test_transform</code><a class="headerlink" href="#avalanche.benchmarks.classic._default_mnist_test_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.classic.SplitMNIST">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">SplitMNIST</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">incremental_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">return_task_id</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">_default_mnist_train_transform</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">_default_mnist_test_transform</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/classic/cmnist/#SplitMNIST"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.SplitMNIST" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a CL scenario using the MNIST dataset.
This helper create the basic split MNIST scenario, where the 10 classes of
the MNIST dataset are evenly splitted into the given nuber of tasks.
If the dataset is not present in the computer the method automatically
download it and store the data in the data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incremental_steps</strong> – The number of incremental steps in the current
scenario.
The value of this parameter should be a divisor of 10.</p></li>
<li><p><strong>return_task_id</strong> – if True, for every step the task id is returned and
the Scenario is Multi Task. This means that the scenario returned
will be of type <code class="docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code>. If false the task index is
not returned (default to 0 for every batch) and the returned scenario
is of type <code class="docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code>.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, value of <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to define the class
order. If non-None, <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter will be ignored.
Defaults to None.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to the training data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default train transformation
will be used.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to the test data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default test transformation
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code></a> instance initialized for the the
MT split MNIST scenario if the parameter <code class="docutils literal notranslate"><span class="pre">return_task_id</span></code> is True,
a <a class="reference internal" href="#avalanche.benchmarks.classic.NCSingleTaskScenario" title="avalanche.benchmarks.classic.NCSingleTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code></a> initialized for the SIT split MNIST
scenario otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.classic.PermutedMNIST">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">PermutedMNIST</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">incremental_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">_default_mnist_train_transform</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">_default_mnist_test_transform</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario">NCMultiTaskScenario</a><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/classic/cmnist/#PermutedMNIST"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.PermutedMNIST" title="Permalink to this definition">¶</a></dt>
<dd><p>This helper create a permuted MNIST scenario: where a given number of random
pixel permutations is used to permute the MNIST images in
<cite>incremental_steps</cite> different manners, creating an equal number of tasks.
Each task is composed of all the original MNIST 10 classes, but the pixel
in the images are permuted in different ways in every task.
If the dataset is not present in the computer the method automatically
download it and store the data in the data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incremental_steps</strong> – The number of incremental tasks in the current
scenario. It indicates how many different permutations of the MNIST
dataset have to be created.
The value of this parameter should be a divisor of 10.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to the training data
before the random permutation, e.g. a random crop, a normalization or a
concatenation of different transformations (see torchvision.transform
documentation for a comprehensive list of possible transformations).
If no transformation is passed, the default train transformation
will be used.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to the test data
before the random permutation, e.g. a random crop, a normalization or a
concatenation of different transformations (see torchvision.transform
documentation for a comprehensive list of possible transformations).
If no transformation is passed, the default test transformation
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code></a> instance initialized for the the
MT permuted MNIST scenario.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.classic.RotatedMNIST">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">RotatedMNIST</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">incremental_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rotations_list</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">_default_mnist_train_transform</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">_default_mnist_test_transform</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario">NCMultiTaskScenario</a><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/classic/cmnist/#RotatedMNIST"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.RotatedMNIST" title="Permalink to this definition">¶</a></dt>
<dd><p>This helper create a rotated MNIST scenario: where a given number of random
rotations are used to rotate the MNIST images in
<cite>incremental_steps</cite> different manners, creating an equal number of tasks.
Each task is composed of all the original MNIST 10 classes, but the images
are rotated in different ways and using different values in every task.
If the dataset is not present in the computer the method automatically
download it and store the data in the data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incremental_steps</strong> – The number of incremental tasks in the current
scenario. It indicates how many different rotations of the MNIST
dataset have to be created.
The value of this parameter should be a divisor of 10.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>rotations_list</strong> – A list of rotations values in degrees (from -180 to
180) used to define the rotations. The rotation specified in position
0 of the list will be applieed to the task 0, the rotation specified in
position 1 will be applyed to task 1 and so on.
If None, value of <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to define the rotations.
If non-None, <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter will be ignored.
Defaults to None.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to the training data
after the random rotation, e.g. a random crop, a normalization or a
concatenation of different transformations (see torchvision.transform
documentation for a comprehensive list of possible transformations).
If no transformation is passed, the default train transformation
will be used.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to the test data
after the random rotation, e.g. a random crop, a normalization or a
concatenation of different transformations (see torchvision.transform
documentation for a comprehensive list of possible transformations).
If no transformation is passed, the default test transformation
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code></a> instance initialized for the the
MT rotated MNIST scenario.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.classic._get_mnist_dataset">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">_get_mnist_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_transformation</span></em>, <em class="sig-param"><span class="n">test_transformation</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.benchmarks.classic._get_mnist_dataset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="id7">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">create_nc_single_dataset_sit_scenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">test_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">n_batches</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">per_batch_classes</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>int<span class="p">, </span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">remap_class_ids</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">reproducibility_data</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.classic.NCSingleTaskScenario" title="avalanche.benchmarks.classic.NCSingleTaskScenario">NCSingleTaskScenario</a><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/scenario_creation/#create_nc_single_dataset_sit_scenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id7" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a “New Classes - Single Incremental Task” scenario given a couple
of train and test datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset</strong> – The training dataset.</p></li>
<li><p><strong>test_dataset</strong> – A list of test dataset.</p></li>
<li><p><strong>n_batches</strong> – The number of batches.</p></li>
<li><p><strong>shuffle</strong> – If True, class order will be shuffled.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, values of <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> and <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to
define the class order. If non-None, <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> and <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameters
will be ignored. Defaults to None.</p></li>
<li><p><strong>per_batch_classes</strong> – Is not None, a dictionary whose keys are
(0-indexed) batch IDs and their values are the number of classes
to include in the respective batches. The dictionary doesn’t
have to contain a key for each batch! All the remaining batches
will contain an equal amount of the remaining classes. The
remaining number of classes must be divisible without remainder
by the remaining number of batches. For instance,
if you want to include 50 classes in the first batch while equally
distributing remaining classes across remaining batches,
just pass the “{0: 50}” dictionary as the <code class="docutils literal notranslate"><span class="pre">per_batch_classes</span></code>
parameter. Defaults to None.</p></li>
<li><p><strong>remap_class_ids</strong> – If True, original class IDs will be
remapped so that they will appear as having an ascending order.
For instance, if the resulting class order after shuffling
(or defined by fixed_class_order) is [23, 34, 11, 7, 6, …] and
remap_class_indexes is True, then all the patterns belonging to
class 23 will appear as belonging to class “0”, class “34” will
be mapped to “1”, class “11” to “2” and so on. This is very
useful when drawing confusion matrices and when dealing with
algorithms with dynamic head expansion. Defaults to False.</p></li>
<li><p><strong>reproducibility_data</strong> – If not None, overrides all the other
scenario definition options. This is usually a dictionary containing
data used to reproduce a specific experiment. One can use the
<code class="docutils literal notranslate"><span class="pre">get_reproducibility_data</span></code> method to get (and even distribute)
the experiment setup so that it can be loaded by passing it as this
parameter. In this way one can be sure that the same specific
experimental setup is being used (for reproducibility purposes).
Beware that, in order to reproduce an experiment, the same train and
test datasets must be used. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code></a> instance initialized for the the
SIT scenario.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="id8">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">create_nc_single_dataset_multi_task_scenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">test_dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">n_tasks</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">per_task_classes</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>int<span class="p">, </span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">classes_ids_from_zero_in_each_task</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">reproducibility_data</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario">NCMultiTaskScenario</a><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/scenarios/new_classes/scenario_creation/#create_nc_single_dataset_multi_task_scenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id8" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a “New Classes - Multi Task” scenario given a couple
of train and test datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset</strong> – The training dataset.</p></li>
<li><p><strong>test_dataset</strong> – A list of test dataset.</p></li>
<li><p><strong>n_tasks</strong> – The number of batches.</p></li>
<li><p><strong>shuffle</strong> – If True, class order will be shuffled.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator. Can
be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, values of shuffle and seed will be used to define the
class order. If non-None, shuffle and seed parameters will be ignored.
Defaults to None.</p></li>
<li><p><strong>per_task_classes</strong> – Is not None, a dictionary whose keys are
(0-indexed) task IDs and their values are the number of classes
to include in the respective batches. The dictionary doesn’t
have to contain a key for each task! All the remaining batches
will contain an equal amount of the remaining classes. The
remaining number of classes must be divisible without remainder
by the remaining number of batches. For instance,
if you want to include 50 classes in the first task while equally
distributing remaining classes across remaining batches,
just pass the “{0: 50}” dictionary as the per_task_classes
parameter. Defaults to None.</p></li>
<li><p><strong>classes_ids_from_zero_in_each_task</strong> – If True, original class IDs will
be mapped to range [0, n_classes_in_task) for each task. If False,
each class will keep its original ID as defined in the input
datasets. Defaults to True.</p></li>
<li><p><strong>reproducibility_data</strong> – If not None, overrides all the other
scenario definition options. This is usually a dictionary containing
data used to reproduce a specific experiment. One can use the
<code class="docutils literal notranslate"><span class="pre">get_reproducibility_data</span></code> method to get (and even distribute)
the experiment setup so that it can be loaded by passing it as this
parameter. In this way one can be sure that the same specific
experimental setup is being used (for reproducibility purposes).
Beware that, in order to reproduce an experiment, the same train and
test datasets must be used. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code></a> instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py data">
<dt id="id9">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">_default_cifar10_train_transform</code><a class="headerlink" href="#id9" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt id="id10">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">_default_cifar10_test_transform</code><a class="headerlink" href="#id10" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.classic.SplitFMNIST">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">SplitFMNIST</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">incremental_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">first_batch_with_half_classes</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_task_id</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">_default_cifar10_train_transform</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">_default_cifar10_test_transform</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/avalanche/benchmarks/classic/cfashion_mnist/#SplitFMNIST"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.classic.SplitFMNIST" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a CL scenario using the Fashion MNIST dataset.
If the dataset is not present in the computer the method automatically
download it and store the data in the data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incremental_steps</strong> – The number of incremental steps in the current
scenario. If the first step is a “pretrain” step and it contains
half of the classes, the number of incremental steps is the number of
tasks performed after the pretraining task.
The value of this parameter should be a divisor of 10 if
first_task_with_half_classes if false, a divisor of 5 otherwise.</p></li>
<li><p><strong>first_batch_with_half_classes</strong> – A boolean value that indicates if a
first pretraining batch containing half of the classes should be used.
If it’s True, a pretrain batch with half of the classes (5 for
cifar100) is used, and a number of incremental tasks, given by the
parameter incremental_task is constructed. If this paramenter is False
no pretraining task will be used, and the dataset is simply split into
a the number of steps defined by the parameter incremental_steps.
Default to False.</p></li>
<li><p><strong>return_task_id</strong> – if True, for every step the task id is returned and
the Scenario is Multi Task. This means that the scenario returned
will be of type <code class="docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code>. If false the task index is
not returned (default to 0 for every batch) and the returned scenario
is of type <code class="docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code>.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, value of <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to define the class
order. If non-None, <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter will be ignored.
Defaults to None.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to the training data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default train transformation
will be used.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to the test data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default test transformation
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.classic.NCMultiTaskScenario" title="avalanche.benchmarks.classic.NCMultiTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code></a> instance initialized for the the
MT scenario using CIFAR10 if the parameter <code class="docutils literal notranslate"><span class="pre">return_task_id</span></code> is True,
a <a class="reference internal" href="#avalanche.benchmarks.classic.NCSingleTaskScenario" title="avalanche.benchmarks.classic.NCSingleTaskScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code></a> initialized for the SIT scenario using
CIFAR10 otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.classic._get_fmnist_dataset">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">_get_fmnist_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_transformation</span></em>, <em class="sig-param"><span class="n">test_transformation</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.benchmarks.classic._get_fmnist_dataset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks.classic.nc_scenario">
<code class="sig-prename descclassname">avalanche.benchmarks.classic.</code><code class="sig-name descname">nc_scenario</code><a class="headerlink" href="#avalanche.benchmarks.classic.nc_scenario" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, ContinualAI Research

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>