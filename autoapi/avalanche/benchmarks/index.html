

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>avalanche.benchmarks &mdash; Avalanche 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/mystyle.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex/" />
    <link rel="search" title="Search" href="../../../search/" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../" class="icon icon-home" alt="Documentation Home"> Avalanche
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Avalanche API:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche</span></code></a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../evaluation/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.evaluation</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../extras/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.extras</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../training/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.training</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../#package-contents">Package Contents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../#avalanche.__version__">__version__</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../">Avalanche</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../" class="icon icon-home"></a> &raquo;</li>
        
      <li><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks</span></code></li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/autoapi/avalanche/benchmarks/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-avalanche.benchmarks">
<span id="avalanche-benchmarks"></span><h1><a class="reference internal" href="#module-avalanche.benchmarks" title="avalanche.benchmarks"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks</span></code></a><a class="headerlink" href="#module-avalanche.benchmarks" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="classic/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.classic</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="classic/ccifar10/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.classic.ccifar10</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="classic/ccifar100/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.classic.ccifar100</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="classic/ccub200/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.classic.ccub200</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="classic/cfashion_mnist/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.classic.cfashion_mnist</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="classic/cimagenet/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.classic.cimagenet</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="classic/cmnist/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.classic.cmnist</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="classic/core50/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.classic.core50</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="classic/ctiny_imagenet/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.classic.ctiny_imagenet</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="datasets/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.datasets</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="datasets/core50/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.datasets.core50</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="datasets/core50/core50/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.datasets.core50.core50</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="datasets/core50/core50_data/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.datasets.core50.core50_data</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="datasets/tiny_imagenet/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.datasets.tiny_imagenet</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="datasets/tiny_imagenet/tiny_imagenet/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.datasets.tiny_imagenet.tiny_imagenet</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="datasets/cub200/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.datasets.cub200</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="datasets/datasets_from_filelists/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.datasets.datasets_from_filelists</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="datasets/torchvision_wrapper/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.datasets.torchvision_wrapper</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="generators/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.generators</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="generators/scenario_generators/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.generators.scenario_generators</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="scenarios/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.scenarios</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="scenarios/new_classes/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.scenarios.new_classes</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="scenarios/new_classes/nc_scenario/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.scenarios.new_classes.nc_scenario</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="scenarios/new_classes/nc_utils/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.scenarios.new_classes.nc_utils</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scenarios/new_instances/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.scenarios.new_instances</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="scenarios/new_instances/ni_scenario/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.scenarios.new_instances.ni_scenario</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="scenarios/new_instances/ni_utils/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.scenarios.new_instances.ni_utils</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scenarios/generic_cl_scenario/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.scenarios.generic_cl_scenario</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="scenarios/generic_definitions/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.scenarios.generic_definitions</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="scenarios/generic_scenario_creation/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.scenarios.generic_scenario_creation</span></code></a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="utils/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">avalanche.benchmarks.utils</span></code></a></li>
</ul>
</div>
</div>
<div class="section" id="package-contents">
<h2>Package Contents<a class="headerlink" href="#package-contents" title="Permalink to this headline">¶</a></h2>
<div class="section" id="classes">
<h3>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.DatasetPart" title="avalanche.benchmarks.DatasetPart"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DatasetPart</span></code></a></p></td>
<td><p>An enumeration defining the different dataset parts</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.DatasetType" title="avalanche.benchmarks.DatasetType"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DatasetType</span></code></a></p></td>
<td><p>An enumeration defining the different dataset types</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.IStepInfo" title="avalanche.benchmarks.IStepInfo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IStepInfo</span></code></a></p></td>
<td><p>Definition of a learning step. A learning step contains a set of patterns</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.IScenarioStream" title="avalanche.benchmarks.IScenarioStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IScenarioStream</span></code></a></p></td>
<td><p>A scenario stream describes a sequence of incremental steps. Steps are</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.GenericCLScenario" title="avalanche.benchmarks.GenericCLScenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GenericCLScenario</span></code></a></p></td>
<td><p>Base implementation of a Continual Learning scenario. A Continual Learning</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.GenericScenarioStream" title="avalanche.benchmarks.GenericScenarioStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GenericScenarioStream</span></code></a></p></td>
<td><p>Initialize self.  See help(type(self)) for accurate signature.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.GenericStepInfo" title="avalanche.benchmarks.GenericStepInfo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GenericStepInfo</span></code></a></p></td>
<td><p>Definition of a learning step based on a <a class="reference internal" href="#avalanche.benchmarks.GenericCLScenario" title="avalanche.benchmarks.GenericCLScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericCLScenario</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.AbstractStepInfo" title="avalanche.benchmarks.AbstractStepInfo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AbstractStepInfo</span></code></a></p></td>
<td><p>Definition of a learning step. A learning step contains a set of patterns</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.NCScenario" title="avalanche.benchmarks.NCScenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NCScenario</span></code></a></p></td>
<td><p>This class defines a “New Classes” scenario. Once created, an instance</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.NCStepInfo" title="avalanche.benchmarks.NCStepInfo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NCStepInfo</span></code></a></p></td>
<td><p>Defines a “New Classes” step. It defines fields to obtain the current</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.NIScenario" title="avalanche.benchmarks.NIScenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NIScenario</span></code></a></p></td>
<td><p>This class defines a “New Instance” scenario.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.NIStepInfo" title="avalanche.benchmarks.NIStepInfo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NIStepInfo</span></code></a></p></td>
<td><p>Defines a “New Instances” step. It defines fields to obtain the current</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.TinyImagenet" title="avalanche.benchmarks.TinyImagenet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TinyImagenet</span></code></a></p></td>
<td><p>Tiny Imagenet Pytorch Dataset</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.CUB200" title="avalanche.benchmarks.CUB200"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CUB200</span></code></a></p></td>
<td><p>An abstract class representing a <code class="xref py py-class docutils literal notranslate"><span class="pre">Dataset</span></code>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.create_multi_dataset_generic_scenario" title="avalanche.benchmarks.create_multi_dataset_generic_scenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_multi_dataset_generic_scenario</span></code></a>(train_dataset_list: Sequence[IDatasetWithTargets], test_dataset_list: Sequence[IDatasetWithTargets], task_labels: Sequence[int], complete_test_set_only: bool = False) → GenericCLScenario</p></td>
<td><p>Creates a generic scenario given a list of datasets and the respective task</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.create_generic_scenario_from_filelists" title="avalanche.benchmarks.create_generic_scenario_from_filelists"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_generic_scenario_from_filelists</span></code></a>(root: Union[str, Path], train_file_lists: Sequence[Union[str, Path]], test_file_lists: Union[Union[str, Path], Sequence[Union[str, Path]]], task_labels: Sequence[int], complete_test_set_only: bool = False, train_transform=None, train_target_transform=None, test_transform=None, test_target_transform=None) → GenericCLScenario</p></td>
<td><p>Creates a generic scenario given a list of filelists and the respective task</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.create_generic_scenario_from_tensors" title="avalanche.benchmarks.create_generic_scenario_from_tensors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_generic_scenario_from_tensors</span></code></a>(train_data_x: Sequence[Any], train_data_y: Sequence[Sequence[SupportsInt]], test_data_x: Union[Any, Sequence[Any]], test_data_y: Union[Any, Sequence[Sequence[SupportsInt]]], task_labels: Sequence[int], complete_test_set_only: bool = False, train_transform=None, train_target_transform=None, test_transform=None, test_target_transform=None) → GenericCLScenario</p></td>
<td><p>Creates a generic scenario given lists of Tensors and the respective task</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.make_ni_transformation_subset" title="avalanche.benchmarks.make_ni_transformation_subset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_ni_transformation_subset</span></code></a>(dataset: IDatasetWithTargets, transform: Any, target_transform: Any, patterns_indexes: Union[None, Sequence[int]], bucket_classes: bool = False, sort_classes: bool = False, sort_indexes: bool = False) → TransformationSubset</p></td>
<td><p>Creates a subset given the list of patterns to include.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id0" title="avalanche.benchmarks.nc_scenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nc_scenario</span></code></a>(train_dataset: Union[Sequence[IDatasetWithTargets], IDatasetWithTargets], test_dataset: Union[Sequence[IDatasetWithTargets], IDatasetWithTargets], n_steps: int, task_labels: bool, *, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Sequence[int] = None, per_step_classes: Dict[int, int] = None, class_ids_from_zero_from_first_step: bool = False, class_ids_from_zero_in_each_step: bool = False, one_dataset_per_step: bool = False, reproducibility_data: Dict[str, Any] = None) → NCScenario</p></td>
<td><p>This method is the high-level specific scenario generator for the</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.ni_scenario" title="avalanche.benchmarks.ni_scenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ni_scenario</span></code></a>(train_dataset: Union[Sequence[IDatasetWithTargets], IDatasetWithTargets], test_dataset: Union[Sequence[IDatasetWithTargets], IDatasetWithTargets], n_steps: int, *, task_labels: bool = False, shuffle: bool = True, seed: Optional[int] = None, balance_steps: bool = False, min_class_patterns_in_step: int = 0, fixed_step_assignment: Optional[Sequence[Sequence[int]]] = None, reproducibility_data: Optional[Dict[str, Any]] = None) → NIScenario</p></td>
<td><p>This method is the high-level specific scenario generator for the</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.dataset_scenario" title="avalanche.benchmarks.dataset_scenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dataset_scenario</span></code></a>(train_dataset_list: Sequence[IDatasetWithTargets], test_dataset_list: Sequence[IDatasetWithTargets], task_labels: Sequence[int], complete_test_set_only: bool = False) → GenericCLScenario</p></td>
<td><p>Creates a generic scenario given a list of datasets and the respective task</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.filelist_scenario" title="avalanche.benchmarks.filelist_scenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">filelist_scenario</span></code></a>(root: Union[str, Path], train_file_lists: Sequence[Union[str, Path]], test_file_lists: Union[Union[str, Path], Sequence[Union[str, Path]]], task_labels: Sequence[int], complete_test_set_only: bool = False, train_transform=None, train_target_transform=None, test_transform=None, test_target_transform=None) → GenericCLScenario</p></td>
<td><p>Creates a generic scenario given a list of filelists and the respective task</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.tensor_scenario" title="avalanche.benchmarks.tensor_scenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_scenario</span></code></a>(train_data_x: Sequence[Any], train_data_y: Sequence[Sequence[SupportsInt]], test_data_x: Union[Any, Sequence[Any]], test_data_y: Union[Any, Sequence[Sequence[SupportsInt]]], task_labels: Sequence[int], complete_test_set_only: bool = False, train_transform=None, train_target_transform=None, test_transform=None, test_target_transform=None) → GenericCLScenario</p></td>
<td><p>Creates a generic scenario given lists of Tensors and the respective task</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.CORe50" title="avalanche.benchmarks.CORe50"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CORe50</span></code></a>(root=expanduser('~') + '/.avalanche/data/core50/', scenario='nicv2_391', run=0)</p></td>
<td><p>CORe50 continual scenario generator</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id0" title="avalanche.benchmarks.nc_scenario"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nc_scenario</span></code></a>(train_dataset: Union[Sequence[IDatasetWithTargets], IDatasetWithTargets], test_dataset: Union[Sequence[IDatasetWithTargets], IDatasetWithTargets], n_steps: int, task_labels: bool, *, shuffle: bool = True, seed: Optional[int] = None, fixed_class_order: Sequence[int] = None, per_step_classes: Dict[int, int] = None, class_ids_from_zero_from_first_step: bool = False, class_ids_from_zero_in_each_step: bool = False, one_dataset_per_step: bool = False, reproducibility_data: Dict[str, Any] = None) → NCScenario</p></td>
<td><p>This method is the high-level specific scenario generator for the</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.SplitTinyImageNet" title="avalanche.benchmarks.SplitTinyImageNet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitTinyImageNet</span></code></a>(incremental_steps=10, return_task_id=False, seed=0, fixed_class_order=None, train_transform=_default_train_transform, test_transform=_default_test_transform)</p></td>
<td><p>Creates a CL scenario using the Tiny ImageNet dataset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.SplitCIFAR10" title="avalanche.benchmarks.SplitCIFAR10"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitCIFAR10</span></code></a>(incremental_steps: int, first_batch_with_half_classes: bool = False, return_task_id=False, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_cifar10_train_transform, test_transform=_default_cifar10_test_transform)</p></td>
<td><p>Creates a CL scenario using the CIFAR10 dataset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks._get_cifar10_dataset" title="avalanche.benchmarks._get_cifar10_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_get_cifar10_dataset</span></code></a>(train_transformation, test_transformation)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.concat_datasets_sequentially" title="avalanche.benchmarks.concat_datasets_sequentially"><code class="xref py py-obj docutils literal notranslate"><span class="pre">concat_datasets_sequentially</span></code></a>(train_dataset_list: Sequence[IDatasetWithTargets[T_co]], test_dataset_list: Sequence[IDatasetWithTargets[T_co]]) → Tuple[IDatasetWithIntTargets[T_co], IDatasetWithIntTargets[T_co], List[list]]</p></td>
<td><p>Concatenates a list of datasets. This is completely different from</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.SplitCIFAR100" title="avalanche.benchmarks.SplitCIFAR100"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitCIFAR100</span></code></a>(incremental_steps: int, first_batch_with_half_classes: bool = False, return_task_id=False, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_cifar100_train_transform, test_transform=_default_cifar100_test_transform)</p></td>
<td><p>Creates a CL scenario using the CIFAR100 dataset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.SplitCIFAR110" title="avalanche.benchmarks.SplitCIFAR110"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitCIFAR110</span></code></a>(incremental_steps: int, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_cifar100_train_transform, test_transform=_default_cifar100_test_transform) → NCScenario</p></td>
<td><p>Creates a Single Incremental Task (SIT) scenario using the CIFAR100 dataset,</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks._get_cifar100_dataset" title="avalanche.benchmarks._get_cifar100_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_get_cifar100_dataset</span></code></a>(train_transformation, test_transformation)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.SplitMNIST" title="avalanche.benchmarks.SplitMNIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitMNIST</span></code></a>(incremental_steps: int, return_task_id=False, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_mnist_train_transform, test_transform=_default_mnist_test_transform)</p></td>
<td><p>Creates a CL scenario using the MNIST dataset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.PermutedMNIST" title="avalanche.benchmarks.PermutedMNIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PermutedMNIST</span></code></a>(incremental_steps: int, seed: Optional[int] = None, train_transform=_default_mnist_train_transform, test_transform=_default_mnist_test_transform) → NCScenario</p></td>
<td><p>This helper create a permuted MNIST scenario: where a given number of random</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.RotatedMNIST" title="avalanche.benchmarks.RotatedMNIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RotatedMNIST</span></code></a>(incremental_steps: int, seed: Optional[int] = None, rotations_list: Optional[Sequence[int]] = None, train_transform=_default_mnist_train_transform, test_transform=_default_mnist_test_transform) → NCScenario</p></td>
<td><p>This helper create a rotated MNIST scenario: where a given number of random</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks._get_mnist_dataset" title="avalanche.benchmarks._get_mnist_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_get_mnist_dataset</span></code></a>(train_transformation, test_transformation)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.SplitFMNIST" title="avalanche.benchmarks.SplitFMNIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitFMNIST</span></code></a>(incremental_steps: int, first_batch_with_half_classes: bool = False, return_task_id=False, seed: Optional[int] = None, fixed_class_order: Optional[Sequence[int]] = None, train_transform=_default_cifar10_train_transform, test_transform=_default_cifar10_test_transform)</p></td>
<td><p>Creates a CL scenario using the Fashion MNIST dataset.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks._get_fmnist_dataset" title="avalanche.benchmarks._get_fmnist_dataset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_get_fmnist_dataset</span></code></a>(train_transformation, test_transformation)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.ImageNet" title="avalanche.benchmarks.ImageNet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ImageNet</span></code></a>(*args, **kwargs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#avalanche.benchmarks.SplitImageNet" title="avalanche.benchmarks.SplitImageNet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitImageNet</span></code></a>(root, incremental_steps=10, per_step_classes=None, return_task_id=False, seed=0, fixed_class_order=None, train_transform=_default_train_transform, test_transform=_default_test_transform)</p></td>
<td><p>Creates a CL scenario using the Tiny ImageNet dataset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#avalanche.benchmarks.SplitCUB200" title="avalanche.benchmarks.SplitCUB200"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitCUB200</span></code></a>(root, incremental_steps=11, classes_first_batch=100, return_task_id=False, seed=0, fixed_class_order=None, shuffle=False, train_transform=_default_train_transform, test_transform=_default_test_transform)</p></td>
<td><p>Creates a CL scenario using the Tiny ImageNet dataset.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt id="avalanche.benchmarks.DatasetPart">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">DatasetPart</code><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_definitions/#DatasetPart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.DatasetPart" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>An enumeration defining the different dataset parts</p>
<p>Create and return a new object.  See help(type) for accurate signature.</p>
<dl class="py attribute">
<dt id="avalanche.benchmarks.DatasetPart.CURRENT">
<code class="sig-name descname">CURRENT</code><em class="property"> = 1</em><a class="headerlink" href="#avalanche.benchmarks.DatasetPart.CURRENT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.DatasetPart.CUMULATIVE">
<code class="sig-name descname">CUMULATIVE</code><em class="property"> = 2</em><a class="headerlink" href="#avalanche.benchmarks.DatasetPart.CUMULATIVE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.DatasetPart.OLD">
<code class="sig-name descname">OLD</code><em class="property"> = 3</em><a class="headerlink" href="#avalanche.benchmarks.DatasetPart.OLD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.DatasetPart.FUTURE">
<code class="sig-name descname">FUTURE</code><em class="property"> = 4</em><a class="headerlink" href="#avalanche.benchmarks.DatasetPart.FUTURE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.DatasetPart.COMPLETE">
<code class="sig-name descname">COMPLETE</code><em class="property"> = 5</em><a class="headerlink" href="#avalanche.benchmarks.DatasetPart.COMPLETE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="avalanche.benchmarks.DatasetType">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">DatasetType</code><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_definitions/#DatasetType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.DatasetType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>An enumeration defining the different dataset types</p>
<p>Create and return a new object.  See help(type) for accurate signature.</p>
<dl class="py attribute">
<dt id="avalanche.benchmarks.DatasetType.TRAIN">
<code class="sig-name descname">TRAIN</code><em class="property"> = 1</em><a class="headerlink" href="#avalanche.benchmarks.DatasetType.TRAIN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.DatasetType.VALIDATION">
<code class="sig-name descname">VALIDATION</code><em class="property"> = 2</em><a class="headerlink" href="#avalanche.benchmarks.DatasetType.VALIDATION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks.TrainSetWithTargets">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">TrainSetWithTargets</code><a class="headerlink" href="#avalanche.benchmarks.TrainSetWithTargets" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks.TestSetWithTargets">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">TestSetWithTargets</code><a class="headerlink" href="#avalanche.benchmarks.TestSetWithTargets" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="avalanche.benchmarks.IStepInfo">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">IStepInfo</code><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_definitions/#IStepInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.IStepInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol[TScenario,</span> <span class="pre">TScenarioStream]</span></code></p>
<p>Definition of a learning step. A learning step contains a set of patterns
which has become available at a particular time instant. The content and
size of a Step is defined by the specific benchmark that creates the
IStepInfo instance.</p>
<p>For instance, a step of a New Classes scenario will contain all patterns
belonging to a subset of classes of the original training set. A step of a
New Instance scenario will contain patterns from previously seen classes.</p>
<p>Steps of  Single Incremental Task (a.k.a. task-free) scenarios are usually
called “batches” while in Multi Task scenarios a Step is usually associated
to a “task”. Finally, in a Multi Incremental Task scenario the Step may be
composed by patterns from different tasks.</p>
<dl class="py attribute">
<dt id="avalanche.benchmarks.IStepInfo.origin_stream">
<code class="sig-name descname">origin_stream</code><em class="property"> :TScenarioStream</em><a class="headerlink" href="#avalanche.benchmarks.IStepInfo.origin_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>A reference to the original stream from which this step was obtained.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.IStepInfo.scenario">
<code class="sig-name descname">scenario</code><em class="property"> :TScenario</em><a class="headerlink" href="#avalanche.benchmarks.IStepInfo.scenario" title="Permalink to this definition">¶</a></dt>
<dd><p>A reference to the scenario.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.IStepInfo.current_step">
<code class="sig-name descname">current_step</code><em class="property"> :int</em><a class="headerlink" href="#avalanche.benchmarks.IStepInfo.current_step" title="Permalink to this definition">¶</a></dt>
<dd><p>The current step. This is an incremental, 0-indexed, value used to
keep track of the position of current step in the original stream.</p>
<p>Beware that this value only describes the step position in the original
stream and may be unrelated to the order in which the strategy will
receive steps</p>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.IStepInfo.dataset">
<em class="property">property </em><code class="sig-name descname">dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; TransformationDataset<a class="headerlink" href="#avalanche.benchmarks.IStepInfo.dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>The dataset containing the patterns available in this step.</p>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.IStepInfo.task_label">
<em class="property">property </em><code class="sig-name descname">task_label</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#avalanche.benchmarks.IStepInfo.task_label" title="Permalink to this definition">¶</a></dt>
<dd><p>The task label. This value will never have value “None”. However,
for scenarios that don’t produce task labels a placeholder value like 0
is usually set.</p>
</dd></dl>

</dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks.TStepInfo">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">TStepInfo</code><a class="headerlink" href="#avalanche.benchmarks.TStepInfo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks.TScenario">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">TScenario</code><a class="headerlink" href="#avalanche.benchmarks.TScenario" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="avalanche.benchmarks.IScenarioStream">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">IScenarioStream</code><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_definitions/#IScenarioStream"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.IScenarioStream" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol[TScenario,</span> <span class="pre">TStepInfo]</span></code></p>
<p>A scenario stream describes a sequence of incremental steps. Steps are
described as <a class="reference internal" href="#avalanche.benchmarks.IStepInfo" title="avalanche.benchmarks.IStepInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">IStepInfo</span></code></a> instances. They contain a set of patterns
which has become available at a particular time instant along with any
optional, scenario specific, metadata.</p>
<p>Most scenario expose two different streams: the training stream and the test
stream.</p>
<dl class="py attribute">
<dt id="avalanche.benchmarks.IScenarioStream.name">
<code class="sig-name descname">name</code><em class="property"> :str</em><a class="headerlink" href="#avalanche.benchmarks.IScenarioStream.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the stream.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.IScenarioStream.scenario">
<code class="sig-name descname">scenario</code><em class="property"> :TScenario</em><a class="headerlink" href="#avalanche.benchmarks.IScenarioStream.scenario" title="Permalink to this definition">¶</a></dt>
<dd><p>A reference to the scenario this stream belongs to.</p>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.IScenarioStream.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#avalanche.benchmarks.TScenarioStream" title="avalanche.benchmarks.TScenarioStream">TScenarioStream</a></span></em>, <em class="sig-param"><span class="n">step_idx</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>int<span class="p">, </span>slice<span class="p">, </span>Iterable<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; Union<span class="p">[</span><a class="reference internal" href="#avalanche.benchmarks.TStepInfo" title="avalanche.benchmarks.TStepInfo">TStepInfo</a><span class="p">, </span><a class="reference internal" href="#avalanche.benchmarks.TScenarioStream" title="avalanche.benchmarks.TScenarioStream">TScenarioStream</a><span class="p">]</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_definitions/#IScenarioStream.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.IScenarioStream.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a step given its step index (or a stream slice given the step
order).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>step_idx</strong> – An int describing the step index or an iterable/slice
object describing a slice of this stream.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The step instance associated to the given step index or
a sliced stream instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.IScenarioStream.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_definitions/#IScenarioStream.__len__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.IScenarioStream.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks.TScenarioStream">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">TScenarioStream</code><a class="headerlink" href="#avalanche.benchmarks.TScenarioStream" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks.TGenericCLScenario">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">TGenericCLScenario</code><a class="headerlink" href="#avalanche.benchmarks.TGenericCLScenario" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="avalanche.benchmarks.GenericCLScenario">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">GenericCLScenario</code><span class="sig-paren">(</span><em class="sig-param">: TGenericCLScenario, original_train_dataset: TrainSetWithTargets, original_test_dataset: TestSetWithTargets, train_dataset: IDatasetWithTargets, test_dataset: IDatasetWithTargets, train_steps_patterns_assignment: Sequence[Sequence[int]], test_steps_patterns_assignment: Sequence[Sequence[int]], task_labels: Sequence[int], complete_test_set_only: bool = False, reproducibility_data: Optional[Dict[str, Any]] = None, step_factory: Callable[['GenericScenarioStream', int], TStepInfo] = None</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_cl_scenario/#GenericCLScenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.GenericCLScenario" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Generic[TrainSetWithTargets,</span> <span class="pre">TestSetWithTargets,</span> <span class="pre">TStepInfo]</span></code></p>
<p>Base implementation of a Continual Learning scenario. A Continual Learning
scenario is defined by a sequence of steps (batches or tasks depending on
the terminology), with each step containing the training (and test) data
that becomes available at a certain time instant.</p>
<p>From a practical point of view, this means that we usually have to define
two datasets (training and test), and some way to assign the patterns
contained in these datasets to each step.</p>
<p>This assignment is usually made in children classes, with this class serving
as the more general implementation. This class handles the most simple type
of assignment: each step is defined by a list of patterns (identified by
their indexes) contained in that step.</p>
<p>Creates an instance of a Continual Learning scenario.</p>
<p>The scenario is defined by the train and test datasets plus the
assignment of patterns to steps (batches/tasks).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset</strong> – The training dataset.</p></li>
<li><p><strong>test_dataset</strong> – The test dataset.</p></li>
<li><p><strong>train_steps_patterns_assignment</strong> – A list of steps. Each step is
in turn defined by a list of integers describing the pattern index
inside the training dataset.</p></li>
<li><p><strong>test_steps_patterns_assignment</strong> – A list of steps. Each step is
in turn defined by a list of integers describing the pattern index
inside the test dataset.</p></li>
<li><p><strong>task_labels</strong> – The mapping from step IDs to task labels, usually
as a list of integers.</p></li>
<li><p><strong>complete_test_set_only</strong> – If True, only the complete test
set will be returned from test set related methods of the linked
<a class="reference internal" href="#avalanche.benchmarks.GenericStepInfo" title="avalanche.benchmarks.GenericStepInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericStepInfo</span></code></a> instances. This also means that the
<code class="docutils literal notranslate"><span class="pre">test_steps_patterns_assignment</span></code> parameter can be a single element
or even an empty list (in which case, the full set defined by
the <code class="docutils literal notranslate"><span class="pre">test_dataset</span></code> parameter will be returned). The returned
task label for the complete test set will be the first element
of the <code class="docutils literal notranslate"><span class="pre">task_labels</span></code> parameter. Defaults to False, which means
that <code class="docutils literal notranslate"><span class="pre">`train_steps_patterns_assignment</span></code> and
<code class="docutils literal notranslate"><span class="pre">test_steps_patterns_assignment</span></code> parameters must describe an equal
amount of steps.</p></li>
<li><p><strong>reproducibility_data</strong> – If not None, overrides the
<code class="docutils literal notranslate"><span class="pre">train/test_steps_patterns_assignment</span></code> and <code class="docutils literal notranslate"><span class="pre">task_labels</span></code>
parameters. This is usually a dictionary containing data used to
reproduce a specific experiment. One can use the
<code class="docutils literal notranslate"><span class="pre">get_reproducibility_data</span></code> method to get (and even distribute)
the experiment setup so that it can be loaded by passing it as this
parameter. In this way one can be sure that the same specific
experimental setup is being used (for reproducibility purposes).
Beware that, in order to reproduce an experiment, the same train and
test datasets must be used. Defaults to None.</p></li>
<li><p><strong>step_factory</strong> – If not None, a callable that, given the scenario
instance and the step ID, returns a step info instance. This
parameter is usually used in subclasses (when invoking the super
constructor) to specialize the step info class. Defaults to None,
which means that the <a class="reference internal" href="#avalanche.benchmarks.GenericStepInfo" title="avalanche.benchmarks.GenericStepInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericStepInfo</span></code></a> constructor will be
used.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="avalanche.benchmarks.GenericCLScenario.original_train_dataset">
<code class="sig-name descname">original_train_dataset</code><em class="property"> :TrainSetWithTargets</em><a class="headerlink" href="#avalanche.benchmarks.GenericCLScenario.original_train_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>The original training set.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.GenericCLScenario.original_test_dataset">
<code class="sig-name descname">original_test_dataset</code><em class="property"> :TestSetWithTargets</em><a class="headerlink" href="#avalanche.benchmarks.GenericCLScenario.original_test_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>The original test set.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.GenericCLScenario.train_dataset">
<code class="sig-name descname">train_dataset</code><em class="property"> :IDatasetWithTargets</em><a class="headerlink" href="#avalanche.benchmarks.GenericCLScenario.train_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>The training set used to generate the incremental steps.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.GenericCLScenario.test_dataset">
<code class="sig-name descname">test_dataset</code><em class="property"> :IDatasetWithTargets</em><a class="headerlink" href="#avalanche.benchmarks.GenericCLScenario.test_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>The test set used to generate the incremental steps.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.GenericCLScenario.train_steps_patterns_assignment">
<code class="sig-name descname">train_steps_patterns_assignment</code><em class="property"> :Sequence[Sequence[int]]</em><a class="headerlink" href="#avalanche.benchmarks.GenericCLScenario.train_steps_patterns_assignment" title="Permalink to this definition">¶</a></dt>
<dd><p>A list containing which training patterns are assigned to each step.
Patterns are identified by their id w.r.t. the dataset found in the
train_dataset field.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.GenericCLScenario.test_steps_patterns_assignment">
<code class="sig-name descname">test_steps_patterns_assignment</code><em class="property"> :Sequence[Sequence[int]]</em><a class="headerlink" href="#avalanche.benchmarks.GenericCLScenario.test_steps_patterns_assignment" title="Permalink to this definition">¶</a></dt>
<dd><p>A list containing which test patterns are assigned to each step.
Patterns are identified by their id w.r.t. the dataset found in the
test_dataset field</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.GenericCLScenario.task_labels">
<code class="sig-name descname">task_labels</code><em class="property"> :Sequence[int]</em><a class="headerlink" href="#avalanche.benchmarks.GenericCLScenario.task_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>The task label of each step.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.GenericCLScenario.complete_test_set_only">
<code class="sig-name descname">complete_test_set_only</code><em class="property"> :bool</em><a class="headerlink" href="#avalanche.benchmarks.GenericCLScenario.complete_test_set_only" title="Permalink to this definition">¶</a></dt>
<dd><p>If True, only the complete test set will be returned from step info
instances.</p>
<p>This flag is usually set to true in scenarios where having one separate
test set aligned to each training step is impossible or doesn’t make
sense from a semantic point of view.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.GenericCLScenario.n_steps">
<code class="sig-name descname">n_steps</code><em class="property"> :int</em><a class="headerlink" href="#avalanche.benchmarks.GenericCLScenario.n_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of incremental steps this scenario is made of.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.GenericCLScenario.train_stream">
<code class="sig-name descname">train_stream</code><em class="property"> :GenericScenarioStream[TStepInfo, TGenericCLScenario]</em><a class="headerlink" href="#avalanche.benchmarks.GenericCLScenario.train_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>The stream used to obtain the training steps. This stream can be sliced
in order to obtain a subset of this stream.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.GenericCLScenario.test_stream">
<code class="sig-name descname">test_stream</code><em class="property"> :GenericScenarioStream[TStepInfo, TGenericCLScenario]</em><a class="headerlink" href="#avalanche.benchmarks.GenericCLScenario.test_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>The stream used to obtain the test steps. This stream can be sliced
in order to obtain a subset of this stream.</p>
<p>Beware that, in certain scenarios, this stream may contain a single
element. Check the <code class="docutils literal notranslate"><span class="pre">complete_test_set_only</span></code> field for more details.</p>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.GenericCLScenario.get_reproducibility_data">
<code class="sig-name descname">get_reproducibility_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_cl_scenario/#GenericCLScenario.get_reproducibility_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.GenericCLScenario.get_reproducibility_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the data needed to reproduce this experiment.</p>
<p>This data can be stored using the pickle module or some other mechanism.
It can then be loaded by passing it as the <code class="docutils literal notranslate"><span class="pre">reproducibility_data</span></code>
parameter in the constructor.</p>
<p>Child classes should get the reproducibility dictionary from super class
and then merge their custom data before returning it.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A dictionary containing the data needed to reproduce the
experiment.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.GenericCLScenario.get_classes_timeline">
<code class="sig-name descname">get_classes_timeline</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">current_step</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_cl_scenario/#GenericCLScenario.get_classes_timeline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.GenericCLScenario.get_classes_timeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the classes timeline for a this scenario.</p>
<p>Given a step ID, this method returns the classes in this step,
previously seen classes, the cumulative class list and a list
of classes that will be encountered in next steps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>current_step</strong> – The reference step ID.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tuple composed of four lists: the first list contains the
IDs of classes in this step, the second contains IDs of classes seen
in previous steps, the third returns a cumulative list of classes
(that is, the union of the first two list) while the last one
returns a list of classes that will be encountered in next steps.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.GenericCLScenario.classes_in_step">
<em class="property">property </em><code class="sig-name descname">classes_in_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; Sequence<span class="p">[</span>Set<span class="p">[</span>int<span class="p">]</span><span class="p">]</span><a class="headerlink" href="#avalanche.benchmarks.GenericCLScenario.classes_in_step" title="Permalink to this definition">¶</a></dt>
<dd><p>A list that, for each step (identified by its index/ID),
stores a set of the (optionally remapped) IDs of classes of patterns
assigned to that step.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="avalanche.benchmarks.GenericScenarioStream">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">GenericScenarioStream</code><span class="sig-paren">(</span><em class="sig-param">: TGenericScenarioStream</em>, <em class="sig-param">name: str</em>, <em class="sig-param">scenario: TGenericCLScenario</em>, <em class="sig-param">*</em>, <em class="sig-param">slice_ids: List[int] = None</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_cl_scenario/#GenericScenarioStream"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.GenericScenarioStream" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Generic[TStepInfo,</span> <span class="pre">TGenericCLScenario]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">IScenarioStream[TGenericCLScenario,</span> <span class="pre">TStepInfo]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence[TStepInfo]</span></code></p>
<p>Initialize self.  See help(type(self)) for accurate signature.</p>
<dl class="py attribute">
<dt id="avalanche.benchmarks.GenericScenarioStream.slice_ids">
<code class="sig-name descname">slice_ids</code><em class="property"> :Optional[List[int]]</em><a class="headerlink" href="#avalanche.benchmarks.GenericScenarioStream.slice_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes which steps are contained in the current stream slice.
Can be None, which means that this object is the original stream.</p>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.GenericScenarioStream.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_cl_scenario/#GenericScenarioStream.__len__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.GenericScenarioStream.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the number of steps this scenario it’s made of.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of steps in this scenario.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.GenericScenarioStream.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">step_idx</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>int<span class="p">, </span>slice<span class="p">, </span>Iterable<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; Union<span class="p">[</span><a class="reference internal" href="#avalanche.benchmarks.TStepInfo" title="avalanche.benchmarks.TStepInfo">TStepInfo</a><span class="p">, </span><a class="reference internal" href="#avalanche.benchmarks.TScenarioStream" title="avalanche.benchmarks.TScenarioStream">TScenarioStream</a><span class="p">]</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_cl_scenario/#GenericScenarioStream.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.GenericScenarioStream.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a step given its step index (or a stream slice given the step
order).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>step_idx</strong> – An int describing the step index or an iterable/slice
object describing a slice of this stream.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The step instance associated to the given step index or
a sliced stream instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.GenericScenarioStream._create_slice">
<code class="sig-name descname">_create_slice</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n">TGenericScenarioStream</span></em>, <em class="sig-param"><span class="n">steps_slice</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>int<span class="p">, </span>slice<span class="p">, </span>Iterable<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.TScenarioStream" title="avalanche.benchmarks.TScenarioStream">TScenarioStream</a><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_cl_scenario/#GenericScenarioStream._create_slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.GenericScenarioStream._create_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a sliced version of this stream.</p>
<p>In its base version, a shallow copy of this stream is created and
then its <code class="docutils literal notranslate"><span class="pre">slice_ids</span></code> field is adapted.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>steps_slice</strong> – The slice to use.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A sliced version of this stream.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="avalanche.benchmarks.GenericStepInfo">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">GenericStepInfo</code><span class="sig-paren">(</span><em class="sig-param">: TGenericStepInfo, origin_stream: GenericScenarioStream[TGenericStepInfo, TGenericCLScenario], current_step: int</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_cl_scenario/#GenericStepInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.GenericStepInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractStepInfo[TGenericCLScenario,</span> <span class="pre">GenericScenarioStream[TGenericStepInfo,</span> <span class="pre">TGenericCLScenario]]</span></code></p>
<p>Definition of a learning step based on a <a class="reference internal" href="#avalanche.benchmarks.GenericCLScenario" title="avalanche.benchmarks.GenericCLScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericCLScenario</span></code></a>
instance.</p>
<p>This step implementation uses the generic step-patterns assignment defined
in the <a class="reference internal" href="#avalanche.benchmarks.GenericCLScenario" title="avalanche.benchmarks.GenericCLScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericCLScenario</span></code></a> instance. Instances of this class are
usually obtained from a scenario stream.</p>
<p>Creates an instance of a generic step info given the stream from this
step was taken and and the current step ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>origin_stream</strong> – The stream from which this step was obtained.</p></li>
<li><p><strong>current_step</strong> – The current step ID, as an integer.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="avalanche.benchmarks.GenericStepInfo._get_task_label">
<code class="sig-name descname">_get_task_label</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">step</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_cl_scenario/#GenericStepInfo._get_task_label"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.GenericStepInfo._get_task_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the task label given the step ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>step</strong> – The step ID.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The task label of the step.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.GenericStepInfo.dataset">
<em class="property">property </em><code class="sig-name descname">dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; TransformationDataset<a class="headerlink" href="#avalanche.benchmarks.GenericStepInfo.dataset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.GenericStepInfo.task_label">
<em class="property">property </em><code class="sig-name descname">task_label</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#avalanche.benchmarks.GenericStepInfo.task_label" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.GenericStepInfo._is_train">
<code class="sig-name descname">_is_train</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_cl_scenario/#GenericStepInfo._is_train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.GenericStepInfo._is_train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="avalanche.benchmarks.AbstractStepInfo">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">AbstractStepInfo</code><span class="sig-paren">(</span><em class="sig-param">: TStepInfo, origin_stream: TScenarioStream, current_step: int, classes_in_this_step: Sequence[int], previous_classes: Sequence[int], classes_seen_so_far: Sequence[int], future_classes: Optional[Sequence[int]]</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_cl_scenario/#AbstractStepInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.AbstractStepInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">IStepInfo[TScenario,</span> <span class="pre">TScenarioStream]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Definition of a learning step. A learning step contains a set of patterns
which has become available at a particular time instant. The content and
size of a Step is defined by the specific benchmark that creates the
step instance.</p>
<p>For instance, a step of a New Classes scenario will contain all patterns
belonging to a subset of classes of the original training set. A step of a
New Instance scenario will contain patterns from previously seen classes.</p>
<p>Steps of  Single Incremental Task (a.k.a. task-free) scenarios are usually
called “batches” while in Multi Task scenarios a Step is usually associated
to a “task”. Finally, in a Multi Incremental Task scenario the Step may be
composed by patterns from different tasks.</p>
<p>Creates an instance of the abstract step info given the scenario stream,
the current step ID and data about the classes timeline.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>origin_stream</strong> – The stream from which this step was obtained.</p></li>
<li><p><strong>current_step</strong> – The current step ID, as an integer.</p></li>
<li><p><strong>classes_in_this_step</strong> – The list of classes in this step.</p></li>
<li><p><strong>previous_classes</strong> – The list of classes in previous steps.</p></li>
<li><p><strong>classes_seen_so_far</strong> – List of classes of current and previous
steps.</p></li>
<li><p><strong>future_classes</strong> – The list of classes of next steps.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="avalanche.benchmarks.AbstractStepInfo.classes_in_this_step">
<code class="sig-name descname">classes_in_this_step</code><em class="property"> :Sequence[int]</em><a class="headerlink" href="#avalanche.benchmarks.AbstractStepInfo.classes_in_this_step" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of classes in this step</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.AbstractStepInfo.previous_classes">
<code class="sig-name descname">previous_classes</code><em class="property"> :Sequence[int]</em><a class="headerlink" href="#avalanche.benchmarks.AbstractStepInfo.previous_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of classes in previous steps</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.AbstractStepInfo.classes_seen_so_far">
<code class="sig-name descname">classes_seen_so_far</code><em class="property"> :Sequence[int]</em><a class="headerlink" href="#avalanche.benchmarks.AbstractStepInfo.classes_seen_so_far" title="Permalink to this definition">¶</a></dt>
<dd><p>List of classes of current and previous steps</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.AbstractStepInfo.future_classes">
<code class="sig-name descname">future_classes</code><em class="property"> :Optional[Sequence[int]]</em><a class="headerlink" href="#avalanche.benchmarks.AbstractStepInfo.future_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of classes of next steps</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.create_multi_dataset_generic_scenario">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">create_multi_dataset_generic_scenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset_list</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>IDatasetWithTargets<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">test_dataset_list</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>IDatasetWithTargets<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">task_labels</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>int<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">complete_test_set_only</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.GenericCLScenario" title="avalanche.benchmarks.GenericCLScenario">GenericCLScenario</a><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_scenario_creation/#create_multi_dataset_generic_scenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.create_multi_dataset_generic_scenario" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a generic scenario given a list of datasets and the respective task
labels. Each training dataset will be considered as a separate training
step. Contents of the datasets will not be changed, including the targets.</p>
<p>When loading the datasets from a set of fixed filelist, consider using
the <a class="reference internal" href="#avalanche.benchmarks.create_generic_scenario_from_filelists" title="avalanche.benchmarks.create_generic_scenario_from_filelists"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_generic_scenario_from_filelists()</span></code></a> helper method instead.</p>
<p>In its base form, this function accepts a list of test datsets that must
contain the same amount of datasets of the training list.
Those pairs are then used to create the “past”, “cumulative”
(a.k.a. growing) and “future” test sets. However, in certain Continual
Learning scenarios only the concept of “complete” test set makes sense. In
that case, the <code class="docutils literal notranslate"><span class="pre">complete_test_set_only</span></code> should be set to True (see the
parameter description for more info).</p>
<p>Beware that pattern transformations must already be included in the
datasets (when needed).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset_list</strong> – A list of training datasets.</p></li>
<li><p><strong>test_dataset_list</strong> – A list of test datasets.</p></li>
<li><p><strong>task_labels</strong> – A list of task labels. Must contain the same amount of
elements of the <code class="docutils literal notranslate"><span class="pre">train_dataset_list</span></code> parameter. For
Single-Incremental-Task (a.k.a. Task-Free) scenarios, this is usually
a list of zeros. For Multi Task scenario, this is usually a list of
ascending task labels (starting from 0).</p></li>
<li><p><strong>complete_test_set_only</strong> – If True, only the complete test set will
be returned by the scenario. This means that the <code class="docutils literal notranslate"><span class="pre">test_dataset_list</span></code>
parameter must be list with a single element (the complete test set).
Defaults to False, which means that <code class="docutils literal notranslate"><span class="pre">train_dataset_list</span></code> and
<code class="docutils literal notranslate"><span class="pre">test_dataset_list</span></code> must contain the same amount of datasets.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.GenericCLScenario" title="avalanche.benchmarks.GenericCLScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericCLScenario</span></code></a> instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.create_generic_scenario_from_filelists">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">create_generic_scenario_from_filelists</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">root</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>str<span class="p">, </span>Path<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">train_file_lists</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>Union<span class="p">[</span>str<span class="p">, </span>Path<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">test_file_lists</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Union<span class="p">[</span>str<span class="p">, </span>Path<span class="p">]</span><span class="p">, </span>Sequence<span class="p">[</span>Union<span class="p">[</span>str<span class="p">, </span>Path<span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">task_labels</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>int<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">complete_test_set_only</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_target_transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">test_target_transform</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.GenericCLScenario" title="avalanche.benchmarks.GenericCLScenario">GenericCLScenario</a><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_scenario_creation/#create_generic_scenario_from_filelists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.create_generic_scenario_from_filelists" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a generic scenario given a list of filelists and the respective task
labels. A separate dataset will be created for each filelist and each of
those training datasets will be considered a separate training step.
Contents of the datasets will not be changed, including the targets.</p>
<p>In its base form, this function accepts a list of filelists for the test
datsets that must contain the same amount of elements of the training list.
Those pairs of datasets are then used to create the “past”, “cumulative”
(a.k.a. growing) and “future” test sets. However, in certain Continual
Learning scenarios only the concept of “complete” test set makes sense. In
that case, the <code class="docutils literal notranslate"><span class="pre">complete_test_set_only</span></code> should be set to True (see the
parameter description for more info).</p>
<p>This helper functions is the best shot when loading Caffe-style dataset
based on filelists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> – The root path of the dataset.</p></li>
<li><p><strong>train_file_lists</strong> – A list of filelists describing the
paths of the training patterns for each step.</p></li>
<li><p><strong>test_file_lists</strong> – A list of filelists describing the
paths of the test patterns for each step.</p></li>
<li><p><strong>task_labels</strong> – A list of task labels. Must contain the same amount of
elements of the <code class="docutils literal notranslate"><span class="pre">train_file_lists</span></code> parameter. For
Single-Incremental-Task (a.k.a. Task-Free) scenarios, this is usually
a list of zeros. For Multi Task scenario, this is usually a list of
ascending task labels (starting from 0).</p></li>
<li><p><strong>complete_test_set_only</strong> – If True, only the complete test set will
be returned by the scenario. This means that the <code class="docutils literal notranslate"><span class="pre">test_file_lists</span></code>
parameter must be list with a single element (the complete test set).
Alternatively, can be a plain string or <code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code> object.
Defaults to False, which means that <code class="docutils literal notranslate"><span class="pre">train_file_lists</span></code> and
<code class="docutils literal notranslate"><span class="pre">test_file_lists</span></code> must contain the same amount of filelists paths.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to training patterns.
Defaults to None.</p></li>
<li><p><strong>train_target_transform</strong> – The transformation to apply to training
patterns targets. Defaults to None.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to test patterns.
Defaults to None.</p></li>
<li><p><strong>test_target_transform</strong> – The transformation to apply to test
patterns targets. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.GenericCLScenario" title="avalanche.benchmarks.GenericCLScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericCLScenario</span></code></a> instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.create_generic_scenario_from_tensors">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">create_generic_scenario_from_tensors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_data_x</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>Any<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">train_data_y</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>Sequence<span class="p">[</span>SupportsInt<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">test_data_x</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Any<span class="p">, </span>Sequence<span class="p">[</span>Any<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">test_data_y</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Any<span class="p">, </span>Sequence<span class="p">[</span>Sequence<span class="p">[</span>SupportsInt<span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">task_labels</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>int<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">complete_test_set_only</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_target_transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">test_target_transform</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.GenericCLScenario" title="avalanche.benchmarks.GenericCLScenario">GenericCLScenario</a><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/generic_scenario_creation/#create_generic_scenario_from_tensors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.create_generic_scenario_from_tensors" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a generic scenario given lists of Tensors and the respective task
labels. A separate dataset will be created from each Tensor pair (x + y)
and each of those training datasets will be considered a separate
training step. Contents of the datasets will not be changed, including the
targets. Using this helper function is the lower level way to create a
Continual Learning scenario. When possible, consider using higher level
helpers.</p>
<p>In its base form, the test lists must contain the same amount of elements of
the training lists. Those pairs of datasets are then used to create the
“past”, “cumulative” (a.k.a. growing) and “future” test sets.
However, in certain Continual Learning scenarios only the concept of
“complete” test set makes sense. In that case, the
<code class="docutils literal notranslate"><span class="pre">complete_test_set_only</span></code> should be set to True (see the parameter
description for more info).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_data_x</strong> – A list of Tensors (one per step) containing the
patterns of the training sets.</p></li>
<li><p><strong>train_data_y</strong> – A list of Tensors or int lists containing the
labels of the patterns of the training sets. Must contain the same
number of elements of <code class="docutils literal notranslate"><span class="pre">train_datasets_x</span></code>.</p></li>
<li><p><strong>test_data_x</strong> – A Tensor or a list of Tensors (one per step) containing
the patterns of the test sets.</p></li>
<li><p><strong>test_data_y</strong> – A Tensor or a list of Tensors or int lists containing
the labels of the patterns of the test sets. Must contain the same
number of elements of <code class="docutils literal notranslate"><span class="pre">test_datasets_x</span></code>.</p></li>
<li><p><strong>task_labels</strong> – A list of task labels. Must contain the same amount of
elements of the <code class="docutils literal notranslate"><span class="pre">train_datasets_x</span></code> parameter. For
Single-Incremental-Task (a.k.a. Task-Free) scenarios, this is usually
a list of zeros. For Multi Task scenario, this is usually a list of
ascending task labels (starting from 0).</p></li>
<li><p><strong>complete_test_set_only</strong> – If True, only the complete test set will
be returned by the scenario. This means that the <code class="docutils literal notranslate"><span class="pre">test_datasets_x</span></code> and
<code class="docutils literal notranslate"><span class="pre">test_datasets_y</span></code> parameters must be lists with a single element
(the complete test set). Defaults to False, which means that
<code class="docutils literal notranslate"><span class="pre">train_file_lists</span></code> and <code class="docutils literal notranslate"><span class="pre">test_file_lists</span></code> must contain the same
amount of filelists paths.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to training patterns.
Defaults to None.</p></li>
<li><p><strong>train_target_transform</strong> – The transformation to apply to training
patterns targets. Defaults to None.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to test patterns.
Defaults to None.</p></li>
<li><p><strong>test_target_transform</strong> – The transformation to apply to test
patterns targets. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.GenericCLScenario" title="avalanche.benchmarks.GenericCLScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericCLScenario</span></code></a> instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="avalanche.benchmarks.NCScenario">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">NCScenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#avalanche.benchmarks.TrainSetWithTargets" title="avalanche.benchmarks.TrainSetWithTargets">TrainSetWithTargets</a></span></em>, <em class="sig-param"><span class="n">test_dataset</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#avalanche.benchmarks.TestSetWithTargets" title="avalanche.benchmarks.TestSetWithTargets">TestSetWithTargets</a></span></em>, <em class="sig-param"><span class="n">n_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">task_labels</span><span class="p">:</span> <span class="n">bool</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">per_step_classes</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>int<span class="p">, </span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">class_ids_from_zero_from_first_step</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">class_ids_from_zero_in_each_step</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">reproducibility_data</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/new_classes/nc_scenario/#NCScenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.NCScenario" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">GenericCLScenario[TrainSetWithTargets,</span> <span class="pre">TestSetWithTargets,</span> <span class="pre">'NCStepInfo']</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Generic[TrainSetWithTargets,</span> <span class="pre">TestSetWithTargets]</span></code></p>
<p>This class defines a “New Classes” scenario. Once created, an instance
of this class can be iterated in order to obtain the step sequence
under the form of instances of <a class="reference internal" href="#avalanche.benchmarks.NCStepInfo" title="avalanche.benchmarks.NCStepInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">NCStepInfo</span></code></a>.</p>
<p>This class can be used directly. However, we recommend using facilities like
<a class="reference internal" href="generators/#avalanche.benchmarks.generators.nc_scenario" title="avalanche.benchmarks.generators.nc_scenario"><code class="xref py py-func docutils literal notranslate"><span class="pre">avalanche.benchmarks.generators.nc_scenario()</span></code></a>.</p>
<p>Creates a <code class="docutils literal notranslate"><span class="pre">NCGenericScenario</span></code> instance given the training and test
Datasets and the number of steps.</p>
<p>By default, the number of classes will be automatically detected by
looking at the training Dataset <code class="docutils literal notranslate"><span class="pre">targets</span></code> field. Classes will be
uniformly distributed across <code class="docutils literal notranslate"><span class="pre">n_steps</span></code> unless a <code class="docutils literal notranslate"><span class="pre">per_step_classes</span></code>
argument is specified.</p>
<p>The number of classes must be divisible without remainder by the number
of steps. This also applies when the <code class="docutils literal notranslate"><span class="pre">per_step_classes</span></code> argument is
not None.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset</strong> – The training dataset. The dataset must contain a
<code class="docutils literal notranslate"><span class="pre">targets</span></code> field. For instance, one can safely use the datasets
from the torchvision package.</p></li>
<li><p><strong>test_dataset</strong> – The test dataset. The dataset must contain a
<code class="docutils literal notranslate"><span class="pre">targets</span></code> field. For instance, one can safely use the datasets
from the torchvision package.</p></li>
<li><p><strong>n_steps</strong> – The number of steps.</p></li>
<li><p><strong>task_labels</strong> – If True, each step will have an ascending task
label. If False, the task label will be 0 for all the steps.</p></li>
<li><p><strong>shuffle</strong> – If True, the class order will be shuffled. Defaults to
True.</p></li>
<li><p><strong>seed</strong> – If shuffle is True and seed is not None, the class order
will be shuffled according to the seed. When None, the current
PyTorch random number generator state will be used.
Defaults to None.</p></li>
<li><p><strong>fixed_class_order</strong> – If not None, the class order to use (overrides
the shuffle argument). Very useful for enhancing
reproducibility. Defaults to None.</p></li>
<li><p><strong>per_step_classes</strong> – Is not None, a dictionary whose keys are
(0-indexed) step IDs and their values are the number of classes
to include in the respective steps. The dictionary doesn’t
have to contain a key for each step! All the remaining steps
will contain an equal amount of the remaining classes. The
remaining number of classes must be divisible without remainder
by the remaining number of steps. For instance,
if you want to include 50 classes in the first step
while equally distributing remaining classes across remaining
steps, just pass the “{0: 50}” dictionary as the
per_step_classes parameter. Defaults to None.</p></li>
<li><p><strong>class_ids_from_zero_from_first_step</strong> – If True, original class IDs
will be remapped so that they will appear as having an ascending
order. For instance, if the resulting class order after shuffling
(or defined by fixed_class_order) is [23, 34, 11, 7, 6, …] and
class_ids_from_zero_from_first_step is True, then all the patterns
belonging to class 23 will appear as belonging to class “0”,
class “34” will be mapped to “1”, class “11” to “2” and so on.
This is very useful when drawing confusion matrices and when dealing
with algorithms with dynamic head expansion. Defaults to False.
Mutually exclusive with the <code class="docutils literal notranslate"><span class="pre">class_ids_from_zero_in_each_step</span></code>
parameter.</p></li>
<li><p><strong>class_ids_from_zero_in_each_step</strong> – If True, original class IDs
will be mapped to range [0, n_classes_in_step) for each step.
Defaults to False. Mutually exclusive with the
<code class="docutils literal notranslate"><span class="pre">class_ids_from_zero_from_first_step</span> <span class="pre">parameter</span></code>.</p></li>
<li><p><strong>reproducibility_data</strong> – If not None, overrides all the other
scenario definition options. This is usually a dictionary containing
data used to reproduce a specific experiment. One can use the
<code class="docutils literal notranslate"><span class="pre">get_reproducibility_data</span></code> method to get (and even distribute)
the experiment setup so that it can be loaded by passing it as this
parameter. In this way one can be sure that the same specific
experimental setup is being used (for reproducibility purposes).
Beware that, in order to reproduce an experiment, the same train and
test datasets must be used. Defaults to None.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="avalanche.benchmarks.NCScenario.classes_order">
<code class="sig-name descname">classes_order</code><em class="property"> :List[int] = []</em><a class="headerlink" href="#avalanche.benchmarks.NCScenario.classes_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores the class order (remapped class IDs).</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.NCScenario.classes_order_original_ids">
<code class="sig-name descname">classes_order_original_ids</code><em class="property"> :List[int]</em><a class="headerlink" href="#avalanche.benchmarks.NCScenario.classes_order_original_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores the class order (original class IDs)</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.NCScenario.class_mapping">
<code class="sig-name descname">class_mapping</code><em class="property"> :List[int] = []</em><a class="headerlink" href="#avalanche.benchmarks.NCScenario.class_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>class_mapping stores the class mapping so that
mapped_class_id = class_mapping[original_class_id].</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.NCScenario.n_classes_per_step">
<code class="sig-name descname">n_classes_per_step</code><em class="property"> :List[int] = []</em><a class="headerlink" href="#avalanche.benchmarks.NCScenario.n_classes_per_step" title="Permalink to this definition">¶</a></dt>
<dd><p>A list that, for each step (identified by its index/ID),
stores the number of classes assigned to that step.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.NCScenario.original_classes_in_step">
<code class="sig-name descname">original_classes_in_step</code><em class="property"> :List[Set[int]] = []</em><a class="headerlink" href="#avalanche.benchmarks.NCScenario.original_classes_in_step" title="Permalink to this definition">¶</a></dt>
<dd><p>A list that, for each step (identified by its index/ID),
stores a list of the original IDs of classes assigned
to that step.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.NCScenario.class_ids_from_zero_from_first_step">
<code class="sig-name descname">class_ids_from_zero_from_first_step</code><em class="property"> :bool</em><a class="headerlink" href="#avalanche.benchmarks.NCScenario.class_ids_from_zero_from_first_step" title="Permalink to this definition">¶</a></dt>
<dd><p>If True the class IDs have been remapped to start from zero.</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.NCScenario.class_ids_from_zero_in_each_step">
<code class="sig-name descname">class_ids_from_zero_in_each_step</code><em class="property"> :bool</em><a class="headerlink" href="#avalanche.benchmarks.NCScenario.class_ids_from_zero_in_each_step" title="Permalink to this definition">¶</a></dt>
<dd><p>If True the class IDs have been remapped to start from zero in
each step</p>
</dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.NCScenario.n_classes">
<code class="sig-name descname">n_classes</code><em class="property"> :int</em><a class="headerlink" href="#avalanche.benchmarks.NCScenario.n_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of classes</p>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.NCScenario.classes_in_step">
<em class="property">property </em><code class="sig-name descname">classes_in_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; Sequence<span class="p">[</span>Set<span class="p">[</span>int<span class="p">]</span><span class="p">]</span><a class="headerlink" href="#avalanche.benchmarks.NCScenario.classes_in_step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.NCScenario.get_reproducibility_data">
<code class="sig-name descname">get_reproducibility_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/new_classes/nc_scenario/#NCScenario.get_reproducibility_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.NCScenario.get_reproducibility_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.NCScenario.classes_in_step_range">
<code class="sig-name descname">classes_in_step_range</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">step_start</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">step_end</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; List<span class="p">[</span>int<span class="p">]</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/new_classes/nc_scenario/#NCScenario.classes_in_step_range"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.NCScenario.classes_in_step_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a list of classes contained in the given steps. The steps are
defined by range. This means that only the classes in range
[step_start, step_end) will be included.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>step_start</strong> – The starting step ID.</p></li>
<li><p><strong>step_end</strong> – The final step ID. Can be None, which means that all
the remaining steps will be taken.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The classes contained in the required step range.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="avalanche.benchmarks.NCStepInfo">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">NCStepInfo</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">origin_stream</span><span class="p">:</span> <span class="n">GenericScenarioStream[‘NCStepInfo’, NCScenario[TrainSetWithTargets, TestSetWithTargets]]</span></em>, <em class="sig-param"><span class="n">current_step</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/new_classes/nc_scenario/#NCStepInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.NCStepInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">GenericStepInfo[NCScenario[TrainSetWithTargets,</span> <span class="pre">TestSetWithTargets],</span> <span class="pre">GenericScenarioStream['NCStepInfo',</span> <span class="pre">NCScenario[TrainSetWithTargets,</span> <span class="pre">TestSetWithTargets]]]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Generic[TrainSetWithTargets,</span> <span class="pre">TestSetWithTargets]</span></code></p>
<p>Defines a “New Classes” step. It defines fields to obtain the current
dataset and the associated task label. It also keeps a reference to the
stream from which this step was taken.</p>
<p>Creates a <code class="docutils literal notranslate"><span class="pre">NCStepInfo</span></code> instance given the stream from this
step was taken and and the current step ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>origin_stream</strong> – The stream from which this step was obtained.</p></li>
<li><p><strong>current_step</strong> – The current step ID, as an integer.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="avalanche.benchmarks.NCStepInfo.dataset">
<em class="property">property </em><code class="sig-name descname">dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.benchmarks.NCStepInfo.dataset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="avalanche.benchmarks.NIScenario">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">NIScenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#avalanche.benchmarks.TrainSetWithTargets" title="avalanche.benchmarks.TrainSetWithTargets">TrainSetWithTargets</a></span></em>, <em class="sig-param"><span class="n">test_dataset</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#avalanche.benchmarks.TestSetWithTargets" title="avalanche.benchmarks.TestSetWithTargets">TestSetWithTargets</a></span></em>, <em class="sig-param"><span class="n">n_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">task_labels</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">balance_steps</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">min_class_patterns_in_step</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">0</span></em>, <em class="sig-param"><span class="n">fixed_step_assignment</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reproducibility_data</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/new_instances/ni_scenario/#NIScenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.NIScenario" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">GenericCLScenario[TrainSetWithTargets,</span> <span class="pre">TestSetWithTargets,</span> <span class="pre">'NIStepInfo']</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Generic[TrainSetWithTargets,</span> <span class="pre">TestSetWithTargets]</span></code></p>
<p>This class defines a “New Instance” scenario.
Once created, an instance of this class can be iterated in order to obtain
the step sequence under the form of instances of <a class="reference internal" href="#avalanche.benchmarks.NIStepInfo" title="avalanche.benchmarks.NIStepInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">NIStepInfo</span></code></a>.</p>
<p>Instances of this class can be created using the constructor directly.
However, we recommend using facilities like
<a class="reference internal" href="generators/#avalanche.benchmarks.generators.ni_scenario" title="avalanche.benchmarks.generators.ni_scenario"><code class="xref py py-func docutils literal notranslate"><span class="pre">avalanche.benchmarks.generators.ni_scenario()</span></code></a>.</p>
<p>Consider that every method from <a class="reference internal" href="#avalanche.benchmarks.NIStepInfo" title="avalanche.benchmarks.NIStepInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">NIStepInfo</span></code></a> used to retrieve
parts of the test set (past, current, future, cumulative) always return the
complete test set. That is, they behave as the getter for the complete test
set.</p>
<p>Creates a NIScenario instance given the training and test Datasets and
the number of steps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset</strong> – The training dataset. The dataset must contain a
“targets” field. For instance, one can safely use the datasets from
the torchvision package.</p></li>
<li><p><strong>test_dataset</strong> – The test dataset. The dataset must contain a
“targets” field. For instance, one can safely use the datasets from
the torchvision package.</p></li>
<li><p><strong>n_steps</strong> – The number of steps.</p></li>
<li><p><strong>task_labels</strong> – If True, each step will have an ascending task
label. If False, the task label will be 0 for all the steps.
Defaults to False.</p></li>
<li><p><strong>shuffle</strong> – If True, the patterns order will be shuffled. Defaults
to True.</p></li>
<li><p><strong>seed</strong> – If shuffle is True and seed is not None, the class order
will be shuffled according to the seed. When None, the current
PyTorch random number generator state will be used.
Defaults to None.</p></li>
<li><p><strong>balance_steps</strong> – If True, pattern of each class will be equally
spread across all steps. If False, patterns will be assigned to
steps in a complete random way. Defaults to False.</p></li>
<li><p><strong>min_class_patterns_in_step</strong> – The minimum amount of patterns of
every class that must be assigned to every step. Compatible with
the <code class="docutils literal notranslate"><span class="pre">balance_steps</span></code> parameter. An exception will be raised if
this constraint can’t be satisfied. Defaults to 0.</p></li>
<li><p><strong>fixed_step_assignment</strong> – If not None, the pattern assignment
to use. It must be a list with an entry for each step. Each entry
is a list that contains the indexes of patterns belonging to that
step. Overrides the <code class="docutils literal notranslate"><span class="pre">shuffle</span></code>, <code class="docutils literal notranslate"><span class="pre">balance_steps</span></code> and
<code class="docutils literal notranslate"><span class="pre">min_class_patterns_in_step</span></code> parameters.</p></li>
<li><p><strong>reproducibility_data</strong> – If not None, overrides all the other
scenario definition options, including <code class="docutils literal notranslate"><span class="pre">fixed_step_assignment</span></code>.
This is usually a dictionary containing data used to
reproduce a specific experiment. One can use the
<code class="docutils literal notranslate"><span class="pre">get_reproducibility_data</span></code> method to get (and even distribute)
the experiment setup so that it can be loaded by passing it as this
parameter. In this way one can be sure that the same specific
experimental setup is being used (for reproducibility purposes).
Beware that, in order to reproduce an experiment, the same train and
test datasets must be used. Defaults to None.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="avalanche.benchmarks.NIScenario.classes_in_step">
<em class="property">property </em><code class="sig-name descname">classes_in_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; Sequence<span class="p">[</span>Set<span class="p">[</span>int<span class="p">]</span><span class="p">]</span><a class="headerlink" href="#avalanche.benchmarks.NIScenario.classes_in_step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.NIScenario.get_reproducibility_data">
<code class="sig-name descname">get_reproducibility_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span> &#x2192; Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/new_instances/ni_scenario/#NIScenario.get_reproducibility_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.NIScenario.get_reproducibility_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="avalanche.benchmarks.NIStepInfo">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">NIStepInfo</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">origin_stream</span><span class="p">:</span> <span class="n">GenericScenarioStream[‘NIStepInfo’, NIScenario[TrainSetWithTargets, TestSetWithTargets]]</span></em>, <em class="sig-param"><span class="n">current_step</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/new_instances/ni_scenario/#NIStepInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.NIStepInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">GenericStepInfo[NIScenario[TrainSetWithTargets,</span> <span class="pre">TestSetWithTargets],</span> <span class="pre">GenericScenarioStream['NIStepInfo',</span> <span class="pre">NIScenario[TrainSetWithTargets,</span> <span class="pre">TestSetWithTargets]]]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Generic[TrainSetWithTargets,</span> <span class="pre">TestSetWithTargets]</span></code></p>
<p>Defines a “New Instances” step. It defines fields to obtain the current
dataset and the associated task label. It also keeps a reference to the
stream from which this step was taken.</p>
<p>Creates a <code class="docutils literal notranslate"><span class="pre">NIStepInfo</span></code> instance given the stream from this
step was taken and and the current step ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>origin_stream</strong> – The stream from which this step was obtained.</p></li>
<li><p><strong>current_step</strong> – The current step ID, as an integer.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.make_ni_transformation_subset">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">make_ni_transformation_subset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dataset</span><span class="p">:</span> <span class="n">IDatasetWithTargets</span></em>, <em class="sig-param"><span class="n">transform</span><span class="p">:</span> <span class="n">Any</span></em>, <em class="sig-param"><span class="n">target_transform</span><span class="p">:</span> <span class="n">Any</span></em>, <em class="sig-param"><span class="n">patterns_indexes</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>None<span class="p">, </span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">bucket_classes</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">sort_classes</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">sort_indexes</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em><span class="sig-paren">)</span> &#x2192; TransformationSubset<a class="reference internal" href="../../../_modules/avalanche/benchmarks/scenarios/new_instances/ni_utils/#make_ni_transformation_subset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.make_ni_transformation_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a subset given the list of patterns to include.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset</strong> – The original dataset</p></li>
<li><p><strong>transform</strong> – The transform function for patterns. Can be None.</p></li>
<li><p><strong>target_transform</strong> – The transform function for targets. Can be None.</p></li>
<li><p><strong>patterns_indexes</strong> – A list of indexes of patterns to include.
If None, all patterns will be included.</p></li>
<li><p><strong>bucket_classes</strong> – If True, the final Dataset will output patterns by
grouping them by class. Defaults to True.</p></li>
<li><p><strong>sort_classes</strong> – If <code class="docutils literal notranslate"><span class="pre">bucket_classes</span></code> and <code class="docutils literal notranslate"><span class="pre">sort_classes</span></code> are both
True, the final Dataset will output patterns by grouping them by class
and the class groups will be ordered by class ID (ascending). Ignored
if <code class="docutils literal notranslate"><span class="pre">bucket_classes</span></code> is False. Defaults to False.</p></li>
<li><p><strong>sort_indexes</strong> – If True, pattern indexes will be sorted (ascending).
When grouping by class, patterns will be sorted inside their respective
class buckets. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">TransformationSubset</span></code> that includes only the required
patterns, in the order controlled by the <code class="docutils literal notranslate"><span class="pre">bucket_classes</span></code>,
<code class="docutils literal notranslate"><span class="pre">sort_classes</span></code> and <code class="docutils literal notranslate"><span class="pre">sort_indexes</span></code> parameters.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.nc_scenario">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">nc_scenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Sequence<span class="p">[</span>IDatasetWithTargets<span class="p">]</span><span class="p">, </span>IDatasetWithTargets<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">test_dataset</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Sequence<span class="p">[</span>IDatasetWithTargets<span class="p">]</span><span class="p">, </span>IDatasetWithTargets<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">n_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">task_labels</span><span class="p">:</span> <span class="n">bool</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">per_step_classes</span><span class="p">:</span> <span class="n">Dict<span class="p">[</span>int<span class="p">, </span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">class_ids_from_zero_from_first_step</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">class_ids_from_zero_in_each_step</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">one_dataset_per_step</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">reproducibility_data</span><span class="p">:</span> <span class="n">Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.NCScenario" title="avalanche.benchmarks.NCScenario">NCScenario</a><a class="reference internal" href="../../../_modules/avalanche/benchmarks/generators/scenario_generators/#nc_scenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.nc_scenario" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is the high-level specific scenario generator for the
“New Classes” (NC) case. Given a sequence of train and test datasets creates
the continual stream of data as a series of steps. Each step will contain
all the patterns belonging to a certain set of classes and a class won’t be
assigned to more than one step.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">task_labels</span></code> parameter determines if each incremental step has
an increasing task label or if, at the contrary, a default task label “0”
has to be assigned to all steps. This can be useful when differentiating
between Single-Incremental-Task and Multi-Task scenarios.</p>
<p>There are other important parameters that can be specified in order to tweak
the behaviour of the resulting scenario. Please take a few minutes to read
and understand them as they may save you a lot of work.</p>
<p>This generator features an integrated reproducibility mechanism that allows
the user to store and later re-load a scenario. For more info see the
<code class="docutils literal notranslate"><span class="pre">reproducibility_data</span></code> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset</strong> – A list of training datasets, or a single dataset.</p></li>
<li><p><strong>test_dataset</strong> – A list of test datasets, or a single test dataset.</p></li>
<li><p><strong>n_steps</strong> – The number of incremental steps. This is not used when
using multiple train/test datasets with the <code class="docutils literal notranslate"><span class="pre">one_dataset_per_step</span></code>
parameter set to True.</p></li>
<li><p><strong>task_labels</strong> – If True, each step will have an ascending task
label. If False, the task label will be 0 for all the steps.</p></li>
<li><p><strong>shuffle</strong> – If True, the class (or step) order will be shuffled.
Defaults to True.</p></li>
<li><p><strong>seed</strong> – If <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> is True and seed is not None, the class (or
step) order will be shuffled according to the seed. When None, the
current PyTorch random number generator state will be used. Defaults to
None.</p></li>
<li><p><strong>fixed_class_order</strong> – If not None, the class order to use (overrides
the shuffle argument). Very useful for enhancing reproducibility.
Defaults to None.</p></li>
<li><p><strong>per_step_classes</strong> – Is not None, a dictionary whose keys are
(0-indexed) step IDs and their values are the number of classes
to include in the respective steps. The dictionary doesn’t
have to contain a key for each step! All the remaining steps
will contain an equal amount of the remaining classes. The
remaining number of classes must be divisible without remainder
by the remaining number of steps. For instance,
if you want to include 50 classes in the first step
while equally distributing remaining classes across remaining
steps, just pass the “{0: 50}” dictionary as the
per_step_classes parameter. Defaults to None.</p></li>
<li><p><strong>class_ids_from_zero_from_first_step</strong> – If True, original class IDs
will be remapped so that they will appear as having an ascending
order. For instance, if the resulting class order after shuffling
(or defined by fixed_class_order) is [23, 34, 11, 7, 6, …] and
class_ids_from_zero_from_first_step is True, then all the patterns
belonging to class 23 will appear as belonging to class “0”,
class “34” will be mapped to “1”, class “11” to “2” and so on.
This is very useful when drawing confusion matrices and when dealing
with algorithms with dynamic head expansion. Defaults to False.
Mutually exclusive with the <code class="docutils literal notranslate"><span class="pre">class_ids_from_zero_in_each_step</span></code>
parameter.</p></li>
<li><p><strong>class_ids_from_zero_in_each_step</strong> – If True, original class IDs
will be mapped to range [0, n_classes_in_step) for each step.
Defaults to False. Mutually exclusive with the
<code class="docutils literal notranslate"><span class="pre">class_ids_from_zero_from_first_step</span></code> parameter.</p></li>
<li><p><strong>one_dataset_per_step</strong> – available only when multiple train-test
datasets are provided. If True, each dataset will be treated as a step.
Mutually exclusive with the <code class="docutils literal notranslate"><span class="pre">per_step_classes</span></code> and
<code class="docutils literal notranslate"><span class="pre">fixed_class_order</span></code> parameters. Overrides the <code class="docutils literal notranslate"><span class="pre">n_steps</span></code> parameter.
Defaults to False.</p></li>
<li><p><strong>reproducibility_data</strong> – If not None, overrides all the other
scenario definition options. This is usually a dictionary containing
data used to reproduce a specific experiment. One can use the
<code class="docutils literal notranslate"><span class="pre">get_reproducibility_data</span></code> method to get (and even distribute)
the experiment setup so that it can be loaded by passing it as this
parameter. In this way one can be sure that the same specific
experimental setup is being used (for reproducibility purposes).
Beware that, in order to reproduce an experiment, the same train and
test datasets must be used. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code>
instance initialized for the the SIT or MT scenario.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.ni_scenario">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">ni_scenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Sequence<span class="p">[</span>IDatasetWithTargets<span class="p">]</span><span class="p">, </span>IDatasetWithTargets<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">test_dataset</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Sequence<span class="p">[</span>IDatasetWithTargets<span class="p">]</span><span class="p">, </span>IDatasetWithTargets<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">n_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">task_labels</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">balance_steps</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">min_class_patterns_in_step</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">0</span></em>, <em class="sig-param"><span class="n">fixed_step_assignment</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reproducibility_data</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.NIScenario" title="avalanche.benchmarks.NIScenario">NIScenario</a><a class="reference internal" href="../../../_modules/avalanche/benchmarks/generators/scenario_generators/#ni_scenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.ni_scenario" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is the high-level specific scenario generator for the
“New Instances” (NI) case. Given a sequence of train and test datasets
creates the continual stream of data as a series of steps. Each step will
contain patterns belonging to different classes.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">task_labels</span></code> parameter determines if each incremental step has
an increasing task label or if, at the contrary, a default task label “0”
has to be assigned to all steps. This can be useful when differentiating
between Single-Incremental-Task and Multi-Task scenarios.</p>
<p>There are other important parameters that can be specified in order to tweak
the behaviour of the resulting scenario. Please take a few minutes to read
and understand them as they may save you a lot of work.</p>
<p>This generator features an integrated reproducibility mechanism that allows
the user to store and later re-load a scenario. For more info see the
<code class="docutils literal notranslate"><span class="pre">reproducibility_data</span></code> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset</strong> – A list of training datasets, or a single dataset.</p></li>
<li><p><strong>test_dataset</strong> – A list of test datasets, or a single test dataset.</p></li>
<li><p><strong>n_steps</strong> – The number of steps.</p></li>
<li><p><strong>task_labels</strong> – If True, each step will have an ascending task
label. If False, the task label will be 0 for all the steps.</p></li>
<li><p><strong>shuffle</strong> – If True, patterns order will be shuffled.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>balance_steps</strong> – If True, pattern of each class will be equally
spread across all steps. If False, patterns will be assigned to
steps in a complete random way. Defaults to False.</p></li>
<li><p><strong>min_class_patterns_in_step</strong> – The minimum amount of patterns of
every class that must be assigned to every step. Compatible with
the <code class="docutils literal notranslate"><span class="pre">balance_steps</span></code> parameter. An exception will be raised if
this constraint can’t be satisfied. Defaults to 0.</p></li>
<li><p><strong>fixed_step_assignment</strong> – If not None, the pattern assignment
to use. It must be a list with an entry for each step. Each entry
is a list that contains the indexes of patterns belonging to that
step. Overrides the <code class="docutils literal notranslate"><span class="pre">shuffle</span></code>, <code class="docutils literal notranslate"><span class="pre">balance_steps</span></code> and
<code class="docutils literal notranslate"><span class="pre">min_class_patterns_in_step</span></code> parameters.</p></li>
<li><p><strong>reproducibility_data</strong> – If not None, overrides all the other
scenario definition options, including <code class="docutils literal notranslate"><span class="pre">fixed_step_assignment</span></code>.
This is usually a dictionary containing data used to
reproduce a specific experiment. One can use the
<code class="docutils literal notranslate"><span class="pre">get_reproducibility_data</span></code> method to get (and even distribute)
the experiment setup so that it can be loaded by passing it as this
parameter. In this way one can be sure that the same specific
experimental setup is being used (for reproducibility purposes).
Beware that, in order to reproduce an experiment, the same train and
test datasets must be used. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.NIScenario" title="avalanche.benchmarks.NIScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">NIScenario</span></code></a> instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.dataset_scenario">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">dataset_scenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset_list</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>IDatasetWithTargets<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">test_dataset_list</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>IDatasetWithTargets<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">task_labels</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>int<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">complete_test_set_only</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.GenericCLScenario" title="avalanche.benchmarks.GenericCLScenario">GenericCLScenario</a><a class="reference internal" href="../../../_modules/avalanche/benchmarks/generators/scenario_generators/#dataset_scenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.dataset_scenario" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a generic scenario given a list of datasets and the respective task
labels. Each training dataset will be considered as a separate training
step. Contents of the datasets will not be changed, including the targets.</p>
<p>When loading the datasets from a set of fixed file lists, consider using
the <a class="reference internal" href="#avalanche.benchmarks.filelist_scenario" title="avalanche.benchmarks.filelist_scenario"><code class="xref py py-func docutils literal notranslate"><span class="pre">filelist_scenario()</span></code></a> helper method instead.</p>
<p>In its base form, this function accepts a list of test datasets that must
contain the same amount of datasets of the training list.
Those pairs are then used to create the “past”, “cumulative”
(a.k.a. growing) and “future” test sets. However, in certain Continual
Learning scenarios only the concept of “complete” test set makes sense. In
that case, the <code class="docutils literal notranslate"><span class="pre">complete_test_set_only</span></code> should be set to True (see the
parameter description for more info).</p>
<p>Beware that pattern transformations must already be included in the
datasets (when needed).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset_list</strong> – A list of training datasets.</p></li>
<li><p><strong>test_dataset_list</strong> – A list of test datasets.</p></li>
<li><p><strong>task_labels</strong> – A list of task labels. Must contain the same amount of
elements of the <code class="docutils literal notranslate"><span class="pre">train_dataset_list</span></code> parameter. For
Single-Incremental-Task (a.k.a. Task-Free) scenarios, this is usually
a list of zeros. For Multi Task scenario, this is usually a list of
ascending task labels (starting from 0).</p></li>
<li><p><strong>complete_test_set_only</strong> – If True, only the complete test set will
be returned by the scenario. This means that the <code class="docutils literal notranslate"><span class="pre">test_dataset_list</span></code>
parameter must be list with a single element (the complete test set).
Defaults to False, which means that <code class="docutils literal notranslate"><span class="pre">train_dataset_list</span></code> and
<code class="docutils literal notranslate"><span class="pre">test_dataset_list</span></code> must contain the same amount of datasets.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.GenericCLScenario" title="avalanche.benchmarks.GenericCLScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericCLScenario</span></code></a> instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.filelist_scenario">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">filelist_scenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">root</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>str<span class="p">, </span>Path<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">train_file_lists</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>Union<span class="p">[</span>str<span class="p">, </span>Path<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">test_file_lists</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Union<span class="p">[</span>str<span class="p">, </span>Path<span class="p">]</span><span class="p">, </span>Sequence<span class="p">[</span>Union<span class="p">[</span>str<span class="p">, </span>Path<span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">task_labels</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>int<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">complete_test_set_only</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_target_transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">test_target_transform</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.GenericCLScenario" title="avalanche.benchmarks.GenericCLScenario">GenericCLScenario</a><a class="reference internal" href="../../../_modules/avalanche/benchmarks/generators/scenario_generators/#filelist_scenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.filelist_scenario" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a generic scenario given a list of filelists and the respective task
labels. A separate dataset will be created for each filelist and each of
those training datasets will be considered a separate training step.
Contents of the datasets will not be changed, including the targets.</p>
<p>In its base form, this function accepts a list of filelists for the test
datsets that must contain the same amount of elements of the training list.
Those pairs of datasets are then used to create the “past”, “cumulative”
(a.k.a. growing) and “future” test sets. However, in certain Continual
Learning scenarios only the concept of “complete” test set makes sense. In
that case, the <code class="docutils literal notranslate"><span class="pre">complete_test_set_only</span></code> should be set to True (see the
parameter description for more info).</p>
<p>This helper functions is the best shot when loading Caffe-style dataset
based on filelists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> – The root path of the dataset.</p></li>
<li><p><strong>train_file_lists</strong> – A list of filelists describing the
paths of the training patterns for each step.</p></li>
<li><p><strong>test_file_lists</strong> – A list of filelists describing the
paths of the test patterns for each step.</p></li>
<li><p><strong>task_labels</strong> – A list of task labels. Must contain the same amount of
elements of the <code class="docutils literal notranslate"><span class="pre">train_file_lists</span></code> parameter. For
Single-Incremental-Task (a.k.a. Task-Free) scenarios, this is usually
a list of zeros. For Multi Task scenario, this is usually a list of
ascending task labels (starting from 0).</p></li>
<li><p><strong>complete_test_set_only</strong> – If True, only the complete test set will
be returned by the scenario. This means that the <code class="docutils literal notranslate"><span class="pre">test_file_lists</span></code>
parameter must be list with a single element (the complete test set).
Alternatively, can be a plain string or <code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code> object.
Defaults to False, which means that <code class="docutils literal notranslate"><span class="pre">train_file_lists</span></code> and
<code class="docutils literal notranslate"><span class="pre">test_file_lists</span></code> must contain the same amount of filelists paths.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to training patterns.
Defaults to None.</p></li>
<li><p><strong>train_target_transform</strong> – The transformation to apply to training
patterns targets. Defaults to None.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to test patterns.
Defaults to None.</p></li>
<li><p><strong>test_target_transform</strong> – The transformation to apply to test
patterns targets. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.GenericCLScenario" title="avalanche.benchmarks.GenericCLScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericCLScenario</span></code></a> instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.tensor_scenario">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">tensor_scenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_data_x</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>Any<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">train_data_y</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>Sequence<span class="p">[</span>SupportsInt<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">test_data_x</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Any<span class="p">, </span>Sequence<span class="p">[</span>Any<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">test_data_y</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Any<span class="p">, </span>Sequence<span class="p">[</span>Sequence<span class="p">[</span>SupportsInt<span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">task_labels</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>int<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">complete_test_set_only</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_target_transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">test_target_transform</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.GenericCLScenario" title="avalanche.benchmarks.GenericCLScenario">GenericCLScenario</a><a class="reference internal" href="../../../_modules/avalanche/benchmarks/generators/scenario_generators/#tensor_scenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.tensor_scenario" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a generic scenario given lists of Tensors and the respective task
labels. A separate dataset will be created from each Tensor pair (x + y)
and each of those training datasets will be considered a separate
training step. Contents of the datasets will not be changed, including the
targets. Using this helper function is the lower level way to create a
Continual Learning scenario. When possible, consider using higher level
helpers.</p>
<p>In its base form, the test lists must contain the same amount of elements of
the training lists. Those pairs of datasets are then used to create the
“past”, “cumulative” (a.k.a. growing) and “future” test sets.
However, in certain Continual Learning scenarios only the concept of
“complete” test set makes sense. In that case, the
<code class="docutils literal notranslate"><span class="pre">complete_test_set_only</span></code> should be set to True (see the parameter
description for more info).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_data_x</strong> – A list of Tensors (one per step) containing the
patterns of the training sets.</p></li>
<li><p><strong>train_data_y</strong> – A list of Tensors or int lists containing the
labels of the patterns of the training sets. Must contain the same
number of elements of <code class="docutils literal notranslate"><span class="pre">train_datasets_x</span></code>.</p></li>
<li><p><strong>test_data_x</strong> – A Tensor or a list of Tensors (one per step) containing
the patterns of the test sets.</p></li>
<li><p><strong>test_data_y</strong> – A Tensor or a list of Tensors or int lists containing
the labels of the patterns of the test sets. Must contain the same
number of elements of <code class="docutils literal notranslate"><span class="pre">test_datasets_x</span></code>.</p></li>
<li><p><strong>task_labels</strong> – A list of task labels. Must contain the same amount of
elements of the <code class="docutils literal notranslate"><span class="pre">train_datasets_x</span></code> parameter. For
Single-Incremental-Task (a.k.a. Task-Free) scenarios, this is usually
a list of zeros. For Multi Task scenario, this is usually a list of
ascending task labels (starting from 0).</p></li>
<li><p><strong>complete_test_set_only</strong> – If True, only the complete test set will
be returned by the scenario. This means that the <code class="docutils literal notranslate"><span class="pre">test_datasets_x</span></code> and
<code class="docutils literal notranslate"><span class="pre">test_datasets_y</span></code> parameters must be lists with a single element
(the complete test set). Defaults to False, which means that
<code class="docutils literal notranslate"><span class="pre">train_file_lists</span></code> and <code class="docutils literal notranslate"><span class="pre">test_file_lists</span></code> must contain the same
amount of filelists paths.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to training patterns.
Defaults to None.</p></li>
<li><p><strong>train_target_transform</strong> – The transformation to apply to training
patterns targets. Defaults to None.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to test patterns.
Defaults to None.</p></li>
<li><p><strong>test_target_transform</strong> – The transformation to apply to test
patterns targets. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <a class="reference internal" href="#avalanche.benchmarks.GenericCLScenario" title="avalanche.benchmarks.GenericCLScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericCLScenario</span></code></a> instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.CORe50">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">CORe50</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">root</span><span class="o">=</span><span class="default_value">expanduser('~') + '/.avalanche/data/core50/'</span></em>, <em class="sig-param"><span class="n">scenario</span><span class="o">=</span><span class="default_value">'nicv2_391'</span></em>, <em class="sig-param"><span class="n">run</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/classic/core50/#CORe50"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.CORe50" title="Permalink to this definition">¶</a></dt>
<dd><p>CORe50 continual scenario generator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> – Path indicating where to store the dataset and related
metadata. By default they will be stored in
avalanche/datasets/core50/data/.</p></li>
<li><p><strong>scenario</strong> – CORe50 main scanario. I can be chosen between ‘ni’, ‘nc’,
‘nic’, ‘nicv2_79’, ‘nicv2_196’ or ‘nicv2_391.’</p></li>
<li><p><strong>run</strong> – number of run for the scenario. Batch ordering change based
on this parameter (a number between 0 and 9).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>it returns a <a class="reference internal" href="#avalanche.benchmarks.GenericCLScenario" title="avalanche.benchmarks.GenericCLScenario"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericCLScenario</span></code></a> instance that can be
iterated.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="avalanche.benchmarks.TinyImagenet">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">TinyImagenet</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_folder</span><span class="o">=</span><span class="default_value">expanduser('~') + '/.avalanche/data/tinyimagenet/'</span></em>, <em class="sig-param"><span class="n">train</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">transform</span><span class="o">=</span><span class="default_value">ToTensor()</span></em>, <em class="sig-param"><span class="n">target_transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">download</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/datasets/tiny_imagenet/tiny_imagenet/#TinyImagenet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.TinyImagenet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.utils.data.Dataset</span></code></p>
<p>Tiny Imagenet Pytorch Dataset</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="field-list simple">
<dt class="field-odd">param string data_folder</dt>
<dd class="field-odd"><p>folder in which to download dataset</p>
</dd>
<dt class="field-even">param boolean train</dt>
<dd class="field-even"><p>True for train set, False for test set</p>
</dd>
<dt class="field-odd">param fun transform</dt>
<dd class="field-odd"><p>Pytorch transformation founction for x</p>
</dd>
<dt class="field-even">param fun target_transform</dt>
<dd class="field-even"><p>Pytorch transformation founction for y</p>
</dd>
<dt class="field-odd">param bool download</dt>
<dd class="field-odd"><p>True for downloading the dataset</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="avalanche.benchmarks.TinyImagenet.download_tinyImageNet">
<code class="sig-name descname">download_tinyImageNet</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/datasets/tiny_imagenet/tiny_imagenet/#TinyImagenet.download_tinyImageNet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.TinyImagenet.download_tinyImageNet" title="Permalink to this definition">¶</a></dt>
<dd><p>Downloads the TintImagenet Dataset</p>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.TinyImagenet.labels2dict">
<code class="sig-name descname">labels2dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/datasets/tiny_imagenet/tiny_imagenet/#TinyImagenet.labels2dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.TinyImagenet.labels2dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns dictionaries to convert class names into progressive ids
and viceversa.
:returns: label2id, id2label: two Python dictionaries.</p>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.TinyImagenet.load_data">
<code class="sig-name descname">load_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">train</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/datasets/tiny_imagenet/tiny_imagenet/#TinyImagenet.load_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.TinyImagenet.load_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Load all images paths and targets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>train</strong> (<em>bool</em>) – True for loading the training set, False for the
test set.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>train_set, test_set: (train_X_paths, train_y).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.TinyImagenet.get_train_images_paths">
<code class="sig-name descname">get_train_images_paths</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">class_name</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/datasets/tiny_imagenet/tiny_imagenet/#TinyImagenet.get_train_images_paths"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.TinyImagenet.get_train_images_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the training set image paths</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>class_name</strong> – names of the classes of the images to be
collected.</p>
</dd>
<dt class="field-even">Returns img_paths</dt>
<dd class="field-even"><p>list of strings (paths)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.TinyImagenet.get_test_images_paths">
<code class="sig-name descname">get_test_images_paths</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">class_name</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/datasets/tiny_imagenet/tiny_imagenet/#TinyImagenet.get_test_images_paths"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.TinyImagenet.get_test_images_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the test set image paths</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>class_name</strong> – names of the classes of the images to be
collected.</p>
</dd>
<dt class="field-even">Returns img_paths</dt>
<dd class="field-even"><p>list of strings (paths)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.TinyImagenet.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/datasets/tiny_imagenet/tiny_imagenet/#TinyImagenet.__len__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.TinyImagenet.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the lenght of the set</p>
</dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.TinyImagenet.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/datasets/tiny_imagenet/tiny_imagenet/#TinyImagenet.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.TinyImagenet.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index-th x, y pattern of the set</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="id0">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">nc_scenario</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Sequence<span class="p">[</span>IDatasetWithTargets<span class="p">]</span><span class="p">, </span>IDatasetWithTargets<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">test_dataset</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Sequence<span class="p">[</span>IDatasetWithTargets<span class="p">]</span><span class="p">, </span>IDatasetWithTargets<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">n_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">task_labels</span><span class="p">:</span> <span class="n">bool</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">per_step_classes</span><span class="p">:</span> <span class="n">Dict<span class="p">[</span>int<span class="p">, </span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">class_ids_from_zero_from_first_step</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">class_ids_from_zero_in_each_step</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">one_dataset_per_step</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">reproducibility_data</span><span class="p">:</span> <span class="n">Dict<span class="p">[</span>str<span class="p">, </span>Any<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.NCScenario" title="avalanche.benchmarks.NCScenario">NCScenario</a><a class="reference internal" href="../../../_modules/avalanche/benchmarks/generators/scenario_generators/#nc_scenario"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is the high-level specific scenario generator for the
“New Classes” (NC) case. Given a sequence of train and test datasets creates
the continual stream of data as a series of steps. Each step will contain
all the patterns belonging to a certain set of classes and a class won’t be
assigned to more than one step.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">task_labels</span></code> parameter determines if each incremental step has
an increasing task label or if, at the contrary, a default task label “0”
has to be assigned to all steps. This can be useful when differentiating
between Single-Incremental-Task and Multi-Task scenarios.</p>
<p>There are other important parameters that can be specified in order to tweak
the behaviour of the resulting scenario. Please take a few minutes to read
and understand them as they may save you a lot of work.</p>
<p>This generator features an integrated reproducibility mechanism that allows
the user to store and later re-load a scenario. For more info see the
<code class="docutils literal notranslate"><span class="pre">reproducibility_data</span></code> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset</strong> – A list of training datasets, or a single dataset.</p></li>
<li><p><strong>test_dataset</strong> – A list of test datasets, or a single test dataset.</p></li>
<li><p><strong>n_steps</strong> – The number of incremental steps. This is not used when
using multiple train/test datasets with the <code class="docutils literal notranslate"><span class="pre">one_dataset_per_step</span></code>
parameter set to True.</p></li>
<li><p><strong>task_labels</strong> – If True, each step will have an ascending task
label. If False, the task label will be 0 for all the steps.</p></li>
<li><p><strong>shuffle</strong> – If True, the class (or step) order will be shuffled.
Defaults to True.</p></li>
<li><p><strong>seed</strong> – If <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> is True and seed is not None, the class (or
step) order will be shuffled according to the seed. When None, the
current PyTorch random number generator state will be used. Defaults to
None.</p></li>
<li><p><strong>fixed_class_order</strong> – If not None, the class order to use (overrides
the shuffle argument). Very useful for enhancing reproducibility.
Defaults to None.</p></li>
<li><p><strong>per_step_classes</strong> – Is not None, a dictionary whose keys are
(0-indexed) step IDs and their values are the number of classes
to include in the respective steps. The dictionary doesn’t
have to contain a key for each step! All the remaining steps
will contain an equal amount of the remaining classes. The
remaining number of classes must be divisible without remainder
by the remaining number of steps. For instance,
if you want to include 50 classes in the first step
while equally distributing remaining classes across remaining
steps, just pass the “{0: 50}” dictionary as the
per_step_classes parameter. Defaults to None.</p></li>
<li><p><strong>class_ids_from_zero_from_first_step</strong> – If True, original class IDs
will be remapped so that they will appear as having an ascending
order. For instance, if the resulting class order after shuffling
(or defined by fixed_class_order) is [23, 34, 11, 7, 6, …] and
class_ids_from_zero_from_first_step is True, then all the patterns
belonging to class 23 will appear as belonging to class “0”,
class “34” will be mapped to “1”, class “11” to “2” and so on.
This is very useful when drawing confusion matrices and when dealing
with algorithms with dynamic head expansion. Defaults to False.
Mutually exclusive with the <code class="docutils literal notranslate"><span class="pre">class_ids_from_zero_in_each_step</span></code>
parameter.</p></li>
<li><p><strong>class_ids_from_zero_in_each_step</strong> – If True, original class IDs
will be mapped to range [0, n_classes_in_step) for each step.
Defaults to False. Mutually exclusive with the
<code class="docutils literal notranslate"><span class="pre">class_ids_from_zero_from_first_step</span></code> parameter.</p></li>
<li><p><strong>one_dataset_per_step</strong> – available only when multiple train-test
datasets are provided. If True, each dataset will be treated as a step.
Mutually exclusive with the <code class="docutils literal notranslate"><span class="pre">per_step_classes</span></code> and
<code class="docutils literal notranslate"><span class="pre">fixed_class_order</span></code> parameters. Overrides the <code class="docutils literal notranslate"><span class="pre">n_steps</span></code> parameter.
Defaults to False.</p></li>
<li><p><strong>reproducibility_data</strong> – If not None, overrides all the other
scenario definition options. This is usually a dictionary containing
data used to reproduce a specific experiment. One can use the
<code class="docutils literal notranslate"><span class="pre">get_reproducibility_data</span></code> method to get (and even distribute)
the experiment setup so that it can be loaded by passing it as this
parameter. In this way one can be sure that the same specific
experimental setup is being used (for reproducibility purposes).
Beware that, in order to reproduce an experiment, the same train and
test datasets must be used. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code>
instance initialized for the the SIT or MT scenario.</p>
</dd>
</dl>
</dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks._default_train_transform">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">_default_train_transform</code><a class="headerlink" href="#avalanche.benchmarks._default_train_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks._default_test_transform">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">_default_test_transform</code><a class="headerlink" href="#avalanche.benchmarks._default_test_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.SplitTinyImageNet">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">SplitTinyImageNet</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">incremental_steps</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">return_task_id</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">_default_train_transform</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">_default_test_transform</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/classic/ctiny_imagenet/#SplitTinyImageNet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.SplitTinyImageNet" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a CL scenario using the Tiny ImageNet dataset.
If the dataset is not present in the computer the method automatically
download it and store the data in the data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incremental_steps</strong> – The number of incremental steps in the current
scenario.</p></li>
<li><p><strong>return_task_id</strong> – if True, for every step the task id is returned and
the Scenario is Multi Task. This means that the scenario returned
will be of type <code class="docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code>. If false the task index is
not returned (default to 0 for every batch) and the returned scenario
is of type <code class="docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code>.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, value of <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to define the class
order. If non-None, <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter will be ignored.
Defaults to None.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to the training data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default train transformation
will be used.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to the test data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default test transformation
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code> instance initialized for the the
MT scenario using CIFAR10 if the parameter <code class="docutils literal notranslate"><span class="pre">return_task_id</span></code> is True,
a <code class="xref py py-class docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code> initialized for the SIT scenario using
CIFAR10 otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks._default_cifar10_train_transform">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">_default_cifar10_train_transform</code><a class="headerlink" href="#avalanche.benchmarks._default_cifar10_train_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks._default_cifar10_test_transform">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">_default_cifar10_test_transform</code><a class="headerlink" href="#avalanche.benchmarks._default_cifar10_test_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.SplitCIFAR10">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">SplitCIFAR10</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">incremental_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">first_batch_with_half_classes</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_task_id</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">_default_cifar10_train_transform</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">_default_cifar10_test_transform</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/classic/ccifar10/#SplitCIFAR10"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.SplitCIFAR10" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a CL scenario using the CIFAR10 dataset.
If the dataset is not present in the computer the method automatically
download it and store the data in the data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incremental_steps</strong> – The number of incremental steps in the current
scenario. If the first step is a “pretrain” step and it contains
half of the classes, the number of incremental steps is the number of
tasks performed after the pretraining task.
The value of this parameter should be a divisor of 10 if
first_task_with_half_classes if false, a divisor of 5 otherwise.</p></li>
<li><p><strong>first_batch_with_half_classes</strong> – A boolean value that indicates if a
first pretraining batch containing half of the classes should be used.
If it’s True, a pretrain batch with half of the classes (5 for
cifar100) is used, and a number of incremental tasks, given by the
parameter incremental_task is constructed. If this paramenter is False
no pretraining task will be used, and the dataset is simply split into
a the number of steps defined by the parameter incremental_steps.
Default to False.</p></li>
<li><p><strong>return_task_id</strong> – if True, for every step the task id is returned and
the Scenario is Multi Task. This means that the scenario returned
will be of type <code class="docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code>. If false the task index is
not returned (default to 0 for every batch) and the returned scenario
is of type <code class="docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code>.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, value of <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to define the class
order. If non-None, <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter will be ignored.
Defaults to None.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to the training data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default train transformation
will be used.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to the test data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default test transformation
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code> instance initialized for the the
MT scenario using CIFAR10 if the parameter <code class="docutils literal notranslate"><span class="pre">return_task_id</span></code> is True,
a <code class="xref py py-class docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code> initialized for the SIT scenario using
CIFAR10 otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks._get_cifar10_dataset">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">_get_cifar10_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_transformation</span></em>, <em class="sig-param"><span class="n">test_transformation</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.benchmarks._get_cifar10_dataset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.concat_datasets_sequentially">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">concat_datasets_sequentially</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_dataset_list</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>IDatasetWithTargets<span class="p">[</span>T_co<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">test_dataset_list</span><span class="p">:</span> <span class="n">Sequence<span class="p">[</span>IDatasetWithTargets<span class="p">[</span>T_co<span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>IDatasetWithIntTargets<span class="p">[</span>T_co<span class="p">]</span><span class="p">, </span>IDatasetWithIntTargets<span class="p">[</span>T_co<span class="p">]</span><span class="p">, </span>List<span class="p">[</span>list<span class="p">]</span><span class="p">]</span><a class="reference internal" href="../../../_modules/avalanche/training/utils/dataset_utils/#concat_datasets_sequentially"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.concat_datasets_sequentially" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates a list of datasets. This is completely different from
<code class="xref py py-class docutils literal notranslate"><span class="pre">ConcatDataset</span></code>, in which datasets are merged together without
other processing. Instead, this function re-maps the datasets class IDs.
For instance:
let the dataset[0] contain patterns of 3 different classes,
let the dataset[1] contain patterns of 2 different classes, then class IDs
will be mapped as follows:</p>
<p>dataset[0] class “0” -&gt; new class ID is “0”</p>
<p>dataset[0] class “1” -&gt; new class ID is “1”</p>
<p>dataset[0] class “2” -&gt; new class ID is “2”</p>
<p>dataset[1] class “0” -&gt; new class ID is “3”</p>
<p>dataset[1] class “1” -&gt; new class ID is “4”</p>
<p>… -&gt; …</p>
<p>dataset[-1] class “C-1” -&gt; new class ID is “overall_n_classes-1”</p>
<p>In contrast, using PyTorch ConcatDataset:</p>
<p>dataset[0] class “0” -&gt; ID is “0”</p>
<p>dataset[0] class “1” -&gt; ID is “1”</p>
<p>dataset[0] class “2” -&gt; ID is “2”</p>
<p>dataset[1] class “0” -&gt; ID is “0”</p>
<p>dataset[1] class “1” -&gt; ID is “1”</p>
<p>Note: <code class="docutils literal notranslate"><span class="pre">train_dataset_list</span></code> and <code class="docutils literal notranslate"><span class="pre">test_dataset_list</span></code> must have the same
number of datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_dataset_list</strong> – A list of training datasets</p></li>
<li><p><strong>test_dataset_list</strong> – A list of test datasets</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A concatenated dataset.</p>
</dd>
</dl>
</dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks._default_cifar100_train_transform">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">_default_cifar100_train_transform</code><a class="headerlink" href="#avalanche.benchmarks._default_cifar100_train_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks._default_cifar100_test_transform">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">_default_cifar100_test_transform</code><a class="headerlink" href="#avalanche.benchmarks._default_cifar100_test_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.SplitCIFAR100">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">SplitCIFAR100</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">incremental_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">first_batch_with_half_classes</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_task_id</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">_default_cifar100_train_transform</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">_default_cifar100_test_transform</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/classic/ccifar100/#SplitCIFAR100"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.SplitCIFAR100" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a CL scenario using the CIFAR100 dataset.
If the dataset is not present in the computer the method automatically
download it and store the data in the data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incremental_steps</strong> – The number of incremental steps in the current
scenario. If the first step is a “pretrain” step and it contains
half of the classes, the number of incremental steps is the number of
tasks performed after the pretraining task.
The value of this parameter should be a divisor of 100 if
first_task_with_half_classes if false, a divisor of 50 otherwise.</p></li>
<li><p><strong>first_batch_with_half_classes</strong> – A boolean value that indicates if a
first pretraining batch containing half of the classes should be used.
If it’s True, a pretrain batch with half of the classes (50 for
cifar100) is used, and a number of incremental tasks, given by the
parameter incremental_task is constructed. If this paramenter is False
no pretraining task will be used, and the dataset is simply split into
a the number of steps defined by the parameter incremental_steps.
Default to False.</p></li>
<li><p><strong>return_task_id</strong> – if True, for every step the task id is returned and
the Scenario is Multi Task. This means that the scenario returned
will be of type <code class="docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code>. If false the task index is
not returned (default to 0 for every batch) and the returned scenario
is of type <code class="docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code>.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, value of <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to define the class
order. If non-None, <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter will be ignored.
Defaults to None.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to the training data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default train transformation
will be used.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to the test data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default test transformation
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code> instance initialized for the the
MT scenario using CIFAR100 if the parameter <code class="docutils literal notranslate"><span class="pre">return_task_id</span></code> is True,
a <code class="xref py py-class docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code> initialized for the SIT scenario using
CIFAR100 otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.SplitCIFAR110">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">SplitCIFAR110</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">incremental_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">_default_cifar100_train_transform</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">_default_cifar100_test_transform</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.NCScenario" title="avalanche.benchmarks.NCScenario">NCScenario</a><a class="reference internal" href="../../../_modules/avalanche/benchmarks/classic/ccifar100/#SplitCIFAR110"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.SplitCIFAR110" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a Single Incremental Task (SIT) scenario using the CIFAR100 dataset,
with a pretrain first batch using CIFAR10.
If the datasets are not present in the computer the method automatically
download them and store the data in the data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incremental_steps</strong> – The number of incremental steps for the
incremental training on cifar100. The first “pretrain” batch using
cifar10 is not included in this number of incremental steps.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order ONLY for the incremental part on cifar100. The classes must be in
range 0-99.
If None, value of <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to define the class
order for the incremental batches on cifar100.
If non-None, <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter will be ignored.
Defaults to None.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to the training data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default train transformation
will be used.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to the test data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default test transformation
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code> instance initialized for the the
SIT scenario using CIFAR10 as a pretrain batch zero and CIFAR100 for the
incremental training.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks._get_cifar100_dataset">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">_get_cifar100_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_transformation</span></em>, <em class="sig-param"><span class="n">test_transformation</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.benchmarks._get_cifar100_dataset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks._default_mnist_train_transform">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">_default_mnist_train_transform</code><a class="headerlink" href="#avalanche.benchmarks._default_mnist_train_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks._default_mnist_test_transform">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">_default_mnist_test_transform</code><a class="headerlink" href="#avalanche.benchmarks._default_mnist_test_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.SplitMNIST">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">SplitMNIST</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">incremental_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">return_task_id</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">_default_mnist_train_transform</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">_default_mnist_test_transform</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/classic/cmnist/#SplitMNIST"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.SplitMNIST" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a CL scenario using the MNIST dataset.
This helper create the basic split MNIST scenario, where the 10 classes of
the MNIST dataset are evenly splitted into the given nuber of tasks.
If the dataset is not present in the computer the method automatically
download it and store the data in the data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incremental_steps</strong> – The number of incremental steps in the current
scenario.
The value of this parameter should be a divisor of 10.</p></li>
<li><p><strong>return_task_id</strong> – if True, for every step the task id is returned and
the Scenario is Multi Task. This means that the scenario returned
will be of type <code class="docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code>. If false the task index is
not returned (default to 0 for every batch) and the returned scenario
is of type <code class="docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code>.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, value of <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to define the class
order. If non-None, <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter will be ignored.
Defaults to None.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to the training data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default train transformation
will be used.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to the test data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default test transformation
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code> instance initialized for the the
MT split MNIST scenario if the parameter <code class="docutils literal notranslate"><span class="pre">return_task_id</span></code> is True,
a <code class="xref py py-class docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code> initialized for the SIT split MNIST
scenario otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.PermutedMNIST">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">PermutedMNIST</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">incremental_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">_default_mnist_train_transform</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">_default_mnist_test_transform</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.NCScenario" title="avalanche.benchmarks.NCScenario">NCScenario</a><a class="reference internal" href="../../../_modules/avalanche/benchmarks/classic/cmnist/#PermutedMNIST"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.PermutedMNIST" title="Permalink to this definition">¶</a></dt>
<dd><p>This helper create a permuted MNIST scenario: where a given number of random
pixel permutations is used to permute the MNIST images in
<code class="docutils literal notranslate"><span class="pre">incremental_steps</span></code> different manners, creating an equal number of tasks.
Each task is composed of all the original MNIST 10 classes, but the pixel
in the images are permuted in different ways in every task.
If the dataset is not present in the computer the method automatically
download it and store the data in the data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incremental_steps</strong> – The number of incremental tasks in the current
scenario. It indicates how many different permutations of the MNIST
dataset have to be created.
The value of this parameter should be a divisor of 10.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to the training data
before the random permutation, e.g. a random crop, a normalization or a
concatenation of different transformations (see torchvision.transform
documentation for a comprehensive list of possible transformations).
If no transformation is passed, the default train transformation
will be used.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to the test data
before the random permutation, e.g. a random crop, a normalization or a
concatenation of different transformations (see torchvision.transform
documentation for a comprehensive list of possible transformations).
If no transformation is passed, the default test transformation
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code> instance initialized for the the
MT permuted MNIST scenario.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.RotatedMNIST">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">RotatedMNIST</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">incremental_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rotations_list</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">_default_mnist_train_transform</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">_default_mnist_test_transform</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#avalanche.benchmarks.NCScenario" title="avalanche.benchmarks.NCScenario">NCScenario</a><a class="reference internal" href="../../../_modules/avalanche/benchmarks/classic/cmnist/#RotatedMNIST"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.RotatedMNIST" title="Permalink to this definition">¶</a></dt>
<dd><p>This helper create a rotated MNIST scenario: where a given number of random
rotations are used to rotate the MNIST images in
<code class="docutils literal notranslate"><span class="pre">incremental_steps</span></code> different manners, creating an equal number of tasks.
Each task is composed of all the original MNIST 10 classes, but the images
are rotated in different ways and using different values in every task.
If the dataset is not present in the computer the method automatically
download it and store the data in the data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incremental_steps</strong> – The number of incremental tasks in the current
scenario. It indicates how many different rotations of the MNIST
dataset have to be created.
The value of this parameter should be a divisor of 10.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>rotations_list</strong> – A list of rotations values in degrees (from -180 to
180) used to define the rotations. The rotation specified in position
0 of the list will be applieed to the task 0, the rotation specified in
position 1 will be applyed to task 1 and so on.
If None, value of <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to define the rotations.
If non-None, <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter will be ignored.
Defaults to None.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to the training data
after the random rotation, e.g. a random crop, a normalization or a
concatenation of different transformations (see torchvision.transform
documentation for a comprehensive list of possible transformations).
If no transformation is passed, the default train transformation
will be used.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to the test data
after the random rotation, e.g. a random crop, a normalization or a
concatenation of different transformations (see torchvision.transform
documentation for a comprehensive list of possible transformations).
If no transformation is passed, the default test transformation
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code> instance initialized for the the
MT rotated MNIST scenario.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks._get_mnist_dataset">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">_get_mnist_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_transformation</span></em>, <em class="sig-param"><span class="n">test_transformation</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.benchmarks._get_mnist_dataset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.SplitFMNIST">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">SplitFMNIST</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">incremental_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">first_batch_with_half_classes</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_task_id</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">seed</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Sequence<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">_default_cifar10_train_transform</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">_default_cifar10_test_transform</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/classic/cfashion_mnist/#SplitFMNIST"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.SplitFMNIST" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a CL scenario using the Fashion MNIST dataset.
If the dataset is not present in the computer the method automatically
download it and store the data in the data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incremental_steps</strong> – The number of incremental steps in the current
scenario. If the first step is a “pretrain” step and it contains
half of the classes, the number of incremental steps is the number of
tasks performed after the pretraining task.
The value of this parameter should be a divisor of 10 if
first_task_with_half_classes if false, a divisor of 5 otherwise.</p></li>
<li><p><strong>first_batch_with_half_classes</strong> – A boolean value that indicates if a
first pretraining batch containing half of the classes should be used.
If it’s True, a pretrain batch with half of the classes (5 for
cifar100) is used, and a number of incremental tasks, given by the
parameter incremental_task is constructed. If this paramenter is False
no pretraining task will be used, and the dataset is simply split into
a the number of steps defined by the parameter incremental_steps.
Default to False.</p></li>
<li><p><strong>return_task_id</strong> – if True, for every step the task id is returned and
the Scenario is Multi Task. This means that the scenario returned
will be of type <code class="docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code>. If false the task index is
not returned (default to 0 for every batch) and the returned scenario
is of type <code class="docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code>.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, value of <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to define the class
order. If non-None, <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter will be ignored.
Defaults to None.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to the training data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default train transformation
will be used.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to the test data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default test transformation
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code> instance initialized for the the
MT scenario using CIFAR10 if the parameter <code class="docutils literal notranslate"><span class="pre">return_task_id</span></code> is True,
a <code class="xref py py-class docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code> initialized for the SIT scenario using
CIFAR10 otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks._get_fmnist_dataset">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">_get_fmnist_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">train_transformation</span></em>, <em class="sig-param"><span class="n">test_transformation</span></em><span class="sig-paren">)</span><a class="headerlink" href="#avalanche.benchmarks._get_fmnist_dataset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.ImageNet">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">ImageNet</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/datasets/torchvision_wrapper/#ImageNet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.ImageNet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks.normalize">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">normalize</code><a class="headerlink" href="#avalanche.benchmarks.normalize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.SplitImageNet">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">SplitImageNet</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">root</span></em>, <em class="sig-param"><span class="n">incremental_steps</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">per_step_classes</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_task_id</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">_default_train_transform</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">_default_test_transform</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/classic/cimagenet/#SplitImageNet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.SplitImageNet" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a CL scenario using the Tiny ImageNet dataset.
If the dataset is not present in the computer the method automatically
download it and store the data in the data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> – Base path where Imagenet data are stored.</p></li>
<li><p><strong>incremental_steps</strong> – The number of incremental steps in the current
scenario.</p></li>
<li><p><strong>per_step_classes</strong> – Is not None, a dictionary whose keys are
(0-indexed) step IDs and their values are the number of classes
to include in the respective steps. The dictionary doesn’t
have to contain a key for each step! All the remaining steps
will contain an equal amount of the remaining classes. The
remaining number of classes must be divisible without remainder
by the remaining number of steps. For instance,
if you want to include 50 classes in the first step
while equally distributing remaining classes across remaining
steps, just pass the “{0: 50}” dictionary as the
per_step_classes parameter. Defaults to None.</p></li>
<li><p><strong>return_task_id</strong> – if True, for every step the task id is returned and
the Scenario is Multi Task. This means that the scenario returned
will be of type <code class="docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code>. If false the task index is
not returned (default to 0 for every batch) and the returned scenario
is of type <code class="docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code>.</p></li>
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, value of <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to define the class
order. If non-None, <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter will be ignored.
Defaults to None.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to the training data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default train transformation
will be used.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to the test data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default test transformation
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code> instance initialized for the the
MT scenario using CIFAR10 if the parameter <code class="docutils literal notranslate"><span class="pre">return_task_id</span></code> is True,
a <code class="xref py py-class docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code> initialized for the SIT scenario using
CIFAR10 otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py data">
<dt id="avalanche.benchmarks.scenario">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">scenario</code><a class="headerlink" href="#avalanche.benchmarks.scenario" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="avalanche.benchmarks.CUB200">
<em class="property">class </em><code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">CUB200</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">root</span></em>, <em class="sig-param"><span class="n">train</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">transform</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">loader</span><span class="o">=</span><span class="default_value">default_loader</span></em>, <em class="sig-param"><span class="n">download</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/datasets/cub200/#CUB200"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.CUB200" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.utils.data.Dataset</span></code></p>
<p>An abstract class representing a <code class="xref py py-class docutils literal notranslate"><span class="pre">Dataset</span></code>.</p>
<p>All datasets that represent a map from keys to data samples should subclass
it. All subclasses should overwrite <a class="reference internal" href="#avalanche.benchmarks.CUB200.__getitem__" title="avalanche.benchmarks.CUB200.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, supporting fetching a
data sample for a given key. Subclasses could also optionally overwrite
<a class="reference internal" href="#avalanche.benchmarks.CUB200.__len__" title="avalanche.benchmarks.CUB200.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a>, which is expected to return the size of the dataset by many
<code class="xref py py-class docutils literal notranslate"><span class="pre">Sampler</span></code> implementations and the default options
of <code class="xref py py-class docutils literal notranslate"><span class="pre">DataLoader</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">DataLoader</span></code> by default constructs a index
sampler that yields integral indices.  To make it work with a map-style
dataset with non-integral indices/keys, a custom sampler must be provided.</p>
</div>
<dl class="py attribute">
<dt id="avalanche.benchmarks.CUB200.filename">
<code class="sig-name descname">filename</code><em class="property"> = images.tgz</em><a class="headerlink" href="#avalanche.benchmarks.CUB200.filename" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.CUB200.metadata">
<code class="sig-name descname">metadata</code><em class="property"> = lists.tgz</em><a class="headerlink" href="#avalanche.benchmarks.CUB200.metadata" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.CUB200.basefolder">
<code class="sig-name descname">basefolder</code><em class="property"> = images</em><a class="headerlink" href="#avalanche.benchmarks.CUB200.basefolder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="avalanche.benchmarks.CUB200.tgz_md5">
<code class="sig-name descname">tgz_md5</code><em class="property"> = 2bbe304ef1aa3ddb6094aa8f53487cf2</em><a class="headerlink" href="#avalanche.benchmarks.CUB200.tgz_md5" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.CUB200._load_metadata">
<code class="sig-name descname">_load_metadata</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/datasets/cub200/#CUB200._load_metadata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.CUB200._load_metadata" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.CUB200._check_integrity">
<code class="sig-name descname">_check_integrity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/datasets/cub200/#CUB200._check_integrity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.CUB200._check_integrity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.CUB200.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/datasets/cub200/#CUB200.__len__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.CUB200.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="avalanche.benchmarks.CUB200.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">idx</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/datasets/cub200/#CUB200.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.CUB200.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="avalanche.benchmarks.SplitCUB200">
<code class="sig-prename descclassname">avalanche.benchmarks.</code><code class="sig-name descname">SplitCUB200</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">root</span></em>, <em class="sig-param"><span class="n">incremental_steps</span><span class="o">=</span><span class="default_value">11</span></em>, <em class="sig-param"><span class="n">classes_first_batch</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">return_task_id</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">fixed_class_order</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">shuffle</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">train_transform</span><span class="o">=</span><span class="default_value">_default_train_transform</span></em>, <em class="sig-param"><span class="n">test_transform</span><span class="o">=</span><span class="default_value">_default_test_transform</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/avalanche/benchmarks/classic/ccub200/#SplitCUB200"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#avalanche.benchmarks.SplitCUB200" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a CL scenario using the Tiny ImageNet dataset.
If the dataset is not present in the computer the method automatically
download it and store the data in the data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> – Base path where Imagenet data are stored.</p></li>
<li><p><strong>incremental_steps</strong> – The number of incremental steps in the current
scenario.</p></li>
<li><p><strong>classes_first_batch</strong> – Number of classes in the first batch.</p></li>
</ul>
</dd>
</dl>
<p>Usually this is set to 500. Default to None.
:param return_task_id: if True, for every step the task id is returned and</p>
<blockquote>
<div><p>the Scenario is Multi Task. This means that the scenario returned
will be of type <code class="docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code>. If false the task index is
not returned (default to 0 for every batch) and the returned scenario
is of type <code class="docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code>.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seed</strong> – A valid int used to initialize the random number generator.
Can be None.</p></li>
<li><p><strong>fixed_class_order</strong> – A list of class IDs used to define the class
order. If None, value of <code class="docutils literal notranslate"><span class="pre">seed</span></code> will be used to define the class
order. If non-None, <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter will be ignored.
Defaults to None.</p></li>
<li><p><strong>shuffle</strong> – If true, the class order in the incremental steps is
randomly shuffled. Default to false.</p></li>
<li><p><strong>train_transform</strong> – The transformation to apply to the training data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default train transformation
will be used.</p></li>
<li><p><strong>test_transform</strong> – The transformation to apply to the test data,
e.g. a random crop, a normalization or a concatenation of different
transformations (see torchvision.transform documentation for a
comprehensive list of possible transformations).
If no transformation is passed, the default test transformation
will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">NCMultiTaskScenario</span></code> instance initialized for the the
MT scenario using CIFAR10 if the parameter <code class="docutils literal notranslate"><span class="pre">return_task_id</span></code> is True,
a <code class="xref py py-class docutils literal notranslate"><span class="pre">NCSingleTaskScenario</span></code> initialized for the SIT scenario using
CIFAR10 otherwise.</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, ContinualAI Research

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>